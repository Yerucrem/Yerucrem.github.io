[{"content":"DNS详细信息 DNS（域名系统）为我们提供了一种与 Internet 上的设备进行通信的简单方法，而无需记住复数。就像每栋房子都有一个直接向其发送邮件的唯一地址一样，互联网上的每台计算机都有自己唯一的地址来与之通信，称为 IP 地址。IP 地址类似于以下 104.26.10.229,4 组数字，范围从 0 到 255，用句点分隔。当您想访问一个网站时，记住这组复杂的数字并不十分方便，而这正是 DNS 可以提供帮助的地方。因此，您可以记住 tryhackme.com，而不是记住 104.26.10.229。\n域层次结构 TLD （顶级域名） TLD 是域名最右侧的部分。因此，例如，tryhackme.com TLD 是 .com。TLD 有两种类型，gTLD（通用顶级域名）和 ccTLD（国家代码顶级域名）。从历史上看，gTLD 旨在告诉用户域名的用途;例如，.com 用于商业目的，.org 用于组织，.edu 用于教育，.gov 用于政府。ccTLD 用于地理目的，例如 .ca 表示位于加拿大的站点，.co.uk 表示位于英国的站点，依此类推。由于这种需求，涌入了从 .online 、 .club 、 .website 、 .biz 等 新 gTLD 。\n二级域 以 tryhackme.com 为例，.com部分是 TLD，tryhackme 是二级域名。注册域名时，二级域名限制为 63 个字符 + TLD，并且只能使用 a-z 0-9 和连字符（不能以连字符开头或结尾或有连续的连字符）。\n子域 子域位于二级域的左侧，使用句点分隔它;例如，在 name admin.tryhackme.com 中，admin 部分是 subdomain。子域名的创建限制与二级域名相同，限制为 63 个字符，并且只能使用 a-z 0-9 和连字符（不能以连字符开头或结尾，也不能有连续的连字符）。您可以使用多个子域（用句点拆分）来创建更长的名称，例如 jupiter.servers.tryhackme.com。但长度必须保持在 253 个字符或更少。您可以为域名创建的子域数量没有限制。\n","date":"2025-03-19T00:00:00Z","permalink":"https://Yerucrem.github.io/p/dns-%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF/","title":"DNS 详细信息"},{"content":"HTTP协议 什么是 HTTP？（超文本传输协议） HTTP 是您查看网站时使用的工具，由 Tim Berners-Lee 和他的团队在 1989 年至 1991 年间开发。HTTP 是用于与 Web 服务器通信以传输网页数据（无论是 HTML、图像、视频等）的规则集。\n什么是 HTTPS？ （安全超文本传输协议） HTTPS 是 HTTP 的安全版本。 HTTPS 数据是加密的，因此它不仅可以阻止人们看到您接收和发送的数据，还可以确保您正在与正确的 Web 服务器通信，而不是冒充它。\n什么是 URL？（统一资源定位器） 如果您曾经使用过 Internet，那么您以前也使用过 URL。URL 主要是有关如何访问 Internet 上的资源的指令。下图显示了 URL 及其所有功能的外观（它不会在每个请求中使用所有功能）。\nScheme:这指示使用什么协议来访问资源，例如 HTTP、HTTPS、FTP（文件传输协议）。 **User:**某些服务需要身份验证才能登录，您可以在 URL 中输入用户名和密码才能登录。 **Host:**您要访问的服务器的域名或 IP 地址。 **Port:**您要连接的端口，通常为 80 用于 HTTP，443 用于 HTTPS，但这可以托管在 1 - 65535 之间的任何端口上。 **Path:**您尝试访问的资源的文件名或位置。 **Query String:**可以发送到请求路径的额外信息位。例如，/blog？id=1 将告知博客路径您希望接收 ID 为 1 的博客文章。 Fragment: 这是对请求的实际页面上的位置的引用。这通常用于内容较长的页面，并且可以将页面的某个部分直接链接到该页面，因此用户一旦访问该页面即可查看该页面。 提出请求 只需一行 GET / HTTP/1.1 就可以向 Web 服务器发出请求\n但要获得更丰富的 Web 体验，您还需要发送其他数据。这些其他数据以所谓的 headers 形式发送，其中 header 包含额外的信息，以提供给您正在与之通信的 Web 服务器，但我们将在 Header 任务中对此进行更多介绍。\n请求示例：\n1 2 3 4 5 6 7 8 9 10 GET / HTTP/1.1 Host: tryhackme.com User-Agent: Mozilla/5.0 Firefox/87.0 Referer: https://tryhackme.com/ 第 1 行： 此请求将发送 GET 方法（ 在 HTTP 方法 任务中，有更多相关信息），请求带有 / 的主页，并告知 Web 服务器我们使用的是 HTTP 协议版本 1.1。\n第 2 行： 我们告诉 Web 服务器我们希望网站 tryhackme.com\n第 3 行： 我们告诉 Web 服务器我们使用的是 Firefox 版本 87 浏览器\n第 4 行： 我们告诉 Web 服务器，将我们引荐到此网页的网页是 https://tryhackme.com\n**第 5 行：**HTTP 请求始终以空行结尾，以通知 Web 服务器请求已完成。\n响应示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 HTTP/1.1 200 OK Server: nginx/1.15.8 Date: Fri, 09 Apr 2021 13:34:03 GMT Content-Type: text/html Content-Length: 98 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;TryHackMe\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; Welcome To TryHackMe.com \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 第 1 行： HTTP 1.1 是服务器正在使用的 HTTP 协议版本，然后是 HTTP 状态代码（在本例中为“200 Ok”），这告诉我们请求已成功完成。\n第 2 行： 这告诉我们 Web 服务器软件和版本号。\n第 3 行： Web 服务器的当前日期、时间和时区。\n第 4 行： Content-Type 标头告诉客户端将发送哪种信息，例如 HTML、图像、视频、pdf、XML。\n第 5 行： Content-Length 告诉客户端响应多长时间，这样我们就可以确认没有丢失数据\n**第 6 行：**HTTP 响应包含一个空行，用于确认 HTTP 响应的结束。\n第 7-14 行： 已请求的信息，在本例中为主页。\nHTTP方法 GET Request 这用于从 Web 服务器获取信息。\nPOST Request 这用于将数据提交到 Web 服务器并可能创建新记录\nPUT Request 这用于将数据提交到 Web 服务器以更新信息\nDELETE Request 这用于从 Web 服务器中删除信息/记录。\nHTTP 协议状态代码： 在上一个任务中，您了解到，当 HTTP 服务器响应时，第一行始终包含一个状态代码，告知客户端其请求的结果以及可能如何处理该请求。这些状态代码可以分为 5 个不同的范围：\n100-199 - Information Response 100-199 - 信息响应 发送这些请求是为了告诉客户端其请求的第一部分已被接受，他们应该继续发送请求的其余部分。这些代码不再很常见。 200-299 - 成功 此状态代码范围用于告诉客户端其请求成功。 300-399 - 重定向 这些用于将客户端的请求重定向到另一个资源。这可以是不同的网页，也可以是完全不同的网站。 400-499 - Client Errors 400-499 - 客户端错误 用于通知客户端其请求有错误。 500-599 - 服务器错误 这是为服务器端发生的错误保留的，通常表示处理请求的服务器存在相当大的问题。 常见的 HTTP 状态代码： 有很多不同的 HTTP 状态代码，这还不包括应用程序甚至可以定义自己的 HTTP 状态代码，我们将介绍您可能遇到的最常见的 HTTP 响应：\n200 - OK 200 - 正常 请求已成功完成。 201 - Created 201 - 已创建 已创建资源（例如，新用户或新博客文章）。 301 - Moved Permanently 301 - 永久移动 这会将客户的浏览器重定向到新网页，或告诉搜索引擎该页面已移至其他位置并改为查看那里。 302 - Found 302 - 找到 与上述永久重定向类似，但顾名思义，这只是一个临时更改，在不久的将来可能会再次更改。 400 - Bad Request 400 - 错误请求 这会告诉浏览器他们的请求中有错误或缺失。如果请求的 Web 服务器资源需要客户端未发送的特定参数，则有时可以使用此方法。 401 - Not Authorised 401 - 未授权 在您授权 Web 应用程序（通常是使用用户名和密码）之前，您当前不允许查看此资源。 403 - Forbidden 403 - 禁止 无论您是否登录，您都无权查看此资源。 405 - Method Not Allowed 405 - 不允许使用 资源不允许此方法请求，例如，当资源需要 POST 请求时，您向资源 /create-account 发送 GET 请求。 404 - Page Not Found 404 - 未找到页面 您请求的页面/资源不存在。 500 - Internal Service Error 500 - 内部服务错误 服务器在您的请求中遇到了某种错误，它不知道如何正确处理。 503 - Service Unavailable 503 - 服务不可用 此服务器无法处理您的请求，因为它已过载或停机进行维护。 Headers 头 标头是您在发出请求时可以发送到 Web 服务器的附加数据位。\n尽管在发出 HTTP 请求时不严格要求标头，但您会发现很难正确查看网站。\n通用请求标头 这些是从客户端（通常是您的浏览器）发送到服务器的标头。\nHost: 一些 Web 服务器托管多个网站，因此通过提供主机标头，您可以告诉它您需要哪个网站，否则您只会收到服务器的默认网站。\n**User-Agent:**这是您的浏览器软件和版本号，告诉 Web 服务器您的浏览器软件有助于它为您的浏览器正确格式化网站，并且 HTML、JavaScript 和 CSS 的某些元素仅在某些浏览器中可用。\n**Content-Length:**将数据发送到 Web 服务器（例如在表单中）时，内容长度会告知 Web 服务器 Web 请求中预期有多少数据。这样，服务器可以确保它不会丢失任何数据。\n**Accept-Encoding:**告诉 Web 服务器浏览器支持哪些类型的压缩方法，以便可以缩小数据以通过 Internet 传输。\n**Cookie:**发送到服务器以帮助记住您的信息的数据（有关更多信息，请参阅 Cookie 任务）。\n常见响应标头 这些是在请求后从服务器返回给客户端的标头。\n**Set-Cookie:**要存储的信息将在每个请求中发送回 Web 服务器（请参阅 cookie 任务以了解更多信息）。\n**Cache-Control:**在浏览器再次请求响应之前，将响应内容存储在浏览器的缓存中多长时间。\nContent-Type: 这会告诉客户端返回什么类型的数据，即 HTML、CSS、JavaScript、图像、PDF、视频等。使用 content-type 标头，浏览器就可以知道如何处理数据。\n**Content-Encoding:**通过 Internet 发送数据时，使用了什么方法来压缩数据以使其更小。\nCookies 它们只是存储在您计算机上的一小段数据。当您从 Web 服务器收到 “Set-Cookie” 标头时，将保存 Cookie。然后，您发出的每个进一步请求，您都会将 cookie 数据发送回 Web 服务器。由于 HTTP 是无状态的（不会跟踪您以前的请求），因此 cookie 可用于提醒 Web 服务器您是谁、网站的一些个人设置或您以前是否访问过该网站。让我们看一下这个 HTTP 请求示例：\nCookie 可用于多种用途，但最常用于网站身份验证。cookie 值通常不是您可以看到密码的明文字符串，而是令牌（人类不容易猜到的唯一密码）。\n查看您的 Cookie 您可以在浏览器中使用开发人员工具轻松查看浏览器向网站发送的 Cookie。\n打开开发人员工具后，单击“Network”（网络）选项卡。此选项卡将向您显示浏览器请求的所有资源的列表。您可以单击每个选项以接收请求和响应的详细分类。如果您的浏览器发送了 Cookie，您将在请求的“Cookie”选项卡上看到这些 Cookie。\n","date":"2025-03-19T00:00:00Z","permalink":"https://Yerucrem.github.io/p/http-%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF/","title":"HTTP 详细信息"},{"content":"身份验证绕过 用户名枚举 暴力 逻辑缺陷 什么是逻辑缺陷？ 有时身份验证过程包含逻辑缺陷。逻辑缺陷是指应用程序的典型逻辑路径被黑客绕过、规避或纵。逻辑缺陷可以存在于网站的任何区域，但在这种情况下，我们将专注于与身份验证相关的示例。\n逻辑缺陷示例 下面的模拟代码示例检查客户端正在访问的路径的开头是否以 /admin 开头，如果是，则进行进一步检查以查看客户端是否实际上是 admin。如果页面不以 /admin 开头，则会向客户端显示该页面。\n1 2 3 4 5 if( url.substr(0,6) === \u0026#39;/admin\u0026#39;) { # Code to check user is an admin } else { # View Page } 因为上面的 PHP 代码示例使用了三个等号 （===），所以它正在查找字符串的完全匹配项，包括相同的字母大小写。该代码存在逻辑缺陷，因为请求 /adMin 的未经身份验证的用户将不会检查其权限，而是向他们显示页面，从而完全绕过身份验证检查。\n逻辑缺陷实用 我们将检查 Acme IT 支持网站 （http：//MACHINE_IP/customers/reset） 的重置密码 功能。我们看到一个表单，要求提供与我们希望执行密码重置的账户关联的电子邮件地址。如果输入的电子邮件无效，您将收到错误消息Account not found from provided email address\n出于演示目的，我们将使用 email address robert@acmeitsupport.thm被接受。然后，我们会看到表单的下一阶段，该阶段要求提供与此登录电子邮件地址关联的用户名。如果我们输入 robert 作为用户名并按下 Check Username 按钮，您将看到一条确认消息，告知将向 robert@acmeitsupport.thm发送一封密码重置电子邮件。\n在此阶段，您可能想知道此应用程序中的漏洞可能是什么，因为您必须知道电子邮件和用户名，然后将密码链接发送到帐户所有者的电子邮件地址。\n在重置电子邮件过程的第二步中，用户名在 POST 字段中提交到 Web 服务器，电子邮件地址在查询字符串请求中作为 GET 字段发送。\n让我们通过使用 curl 工具手动向 Web 服务器发出请求来说明这一点。\n1 user@tryhackme$ curl \u0026#39;http://MACHINE_IP/customers/reset?email=robert%40acmeitsupport.thm\u0026#39; -H \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; -d \u0026#39;username=robert\u0026#39; 我们使用该标志向请求添加额外的标头。在这种情况下，我们将 设置为 ，这让 Web 服务器知道我们正在发送表单数据，以便它正确理解我们的请求。\n在应用程序中，使用查询字符串检索用户帐户，但稍后，在应用程序逻辑中，使用 PHP 变量 $_REQUEST 中的数据发送密码重置电子邮件。\nPHP$_REQUEST 变量是一个数组，其中包含从查询字符串接收的数据和 POST 数据。如果查询字符串和 POST 数据使用相同的键名称，则此变量的应用程序逻辑优先使用 POST 数据字段而不是查询字符串，因此，如果我们向 POST 表单添加另一个参数，我们可以控制密码重置电子邮件的发送位置。\n1 user@tryhackme$ curl \u0026#39;http://MACHINE_IP/customers/reset?email=robert%40acmeitsupport.thm\u0026#39; -H \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; -d \u0026#39;username=robert\u0026amp;email=attacker@hacker.com\u0026#39; **下一步，您需要在 Acme IT 支持客户部分创建一个帐户，这样做会为您提供一个可用于创建支持票证的唯一电子邮件地址。电子邮件地址的格式为 {username}@customer.acmeitsupport.thm\n现在重新运行 Curl 请求 2，但使用您的 @acmeitsupport。thm 在电子邮件字段中，您将在您的帐户上创建一个票证，其中包含一个链接，用于以 Robert 身份登录。使用 Robert 的帐户，您可以查看他们的支持票证并显示标志。\n1 user@tryhackme:~$ curl \u0026#39;http://MACHINE_IP/customers/reset?email=robert@acmeitsupport.thm\u0026#39; -H \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; -d \u0026#39;username=robert\u0026amp;email={username}@customer.acmeitsupport.thm\u0026#39; Cookie 篡改 在联机会话期间检查和编辑 Web 服务器设置的 Cookie 可能会产生多种结果，例如未经身份验证的访问、访问其他用户帐户或提升的权限。\n纯文本 某些 cookie 的内容可以是纯文本形式，并且它们的作用很明显。例如，如果这些是成功登录后设置的 Cookie：\n1 2 Set-Cookie: logged_in=true; Max-Age=3600; Path=/ Set-Cookie: admin=false; Max-Age=3600; Path=/ 我们看到一个 Cookie （logged_in），它似乎用于控制用户当前是否登录，以及另一个 （admin），它控制访客是否具有管理员权限。使用这个逻辑，如果我们要更改 cookie 的内容并发出请求，我们将能够更改我们的权限。\n首先，我们先请求目标页面：\n1 user@tryhackme$ curl http://MACHINE_IP/cookie-test 我们可以看到我们返回了一条消息：Not Logged In\n现在，我们将发送另一个请求，其中 logged_in Cookie 设置为 true，管理 Cookie 设置为 false：\n1 user@tryhackme$ curl -H \u0026#34;Cookie: logged_in=true; admin=false\u0026#34; http://MACHINE_IP/cookie-test 我们收到消息：Logged In As A User\n最后，我们将发送最后一个请求，将 logged_in 和 admin Cookie 都设置为 true：\n1 user@tryhackme$ curl -H \u0026#34;Cookie: logged_in=true; admin=true\u0026#34; http://MACHINE_IP/cookie-test 这将返回结果：Logged In As An Admin\nHashing 散列法 有时 Cookie 值看起来像一长串随机字符;这些称为哈希，它是原始文本的不可逆表示。以下是您可能会遇到的一些示例：\n原始字符串 ** 哈希方法** 输出 1 md5 c4ca4238a0b923820dcc509a6f75849b 1 sha-256 6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b 1 sha-512 4dff4ea340f0a823f15d3f4f01ab62eae0e5da579ccb851f8db9dfe84c58b2b37b89903a740e1ee172da793a6e79d560e5f7f9bd058a12a280433ed6fa46510a 1 sha1 356a192b7913b04c54574d18c28d46e6395428ab 从上表中可以看出，同一输入字符串的哈希输出可能会因使用的哈希方法而显著不同。即使哈希是不可逆的，但每次都会产生相同的输出，这对我们很有帮助，因为 https://crackstation.net/ 等服务会保留数十亿个哈希及其原始字符串的数据库。\n编码 编码类似于哈希，因为它会创建看似随机的文本字符串，但实际上，编码是可逆的。所以这就引出了一个问题，编码的意义何在？编码使我们能够将二进制数据转换为人类可读的文本，这些文本可以通过仅支持纯文本 ASCII 字符的介质轻松安全地传输。\n常见的编码类型包括 base32 和 base64，前者将二进制数据转换为字符 A-Z 和 2-7，后者使用字符 a-z、A-Z、0-9、+ 和 equals 符号进行转换进行填充。\n以以下数据为例，该数据由 Web 服务器在登录时设置：\n1 Set-Cookie: session=eyJpZCI6MSwiYWRtaW4iOmZhbHNlfQ==; Max-Age=3600; Path=/ 这个字符串 base64 解码的值为 {“id”：1，“admin”： false} ，然后我们可以再次将其编码回 base64 编码，但将 admin 值设置为 true，这现在为我们提供了管理员访问权限。\n","date":"2025-03-19T00:00:00Z","permalink":"https://Yerucrem.github.io/p/%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87/","title":"身份验证绕过"},{"content":"DOM Document Object Model 文档对象模型\n什么是文档对象模型？ \u0026mdash; What is the Document Object Model?\nDOM 是什么？ 想象一下，你有一张房子的建筑蓝图，上面画着房子的每一个部分：墙、门、窗户、屋顶等等。DOM 就像是网页的“蓝图”。当你打开一个网页，浏览器会把网页的 HTML 代码（那些 \u0026lt;html\u0026gt;、\u0026lt;div\u0026gt;、\u0026lt;p\u0026gt; 标签）解析成一个树状结构，这个结构就是 DOM。它把网页里的每一个元素（比如标题、段落、图片）都整理得清清楚楚，让计算机（特别是 JavaScript）能找到它们、操作它们。\n简单来说，DOM 是网页的骨架图，它把网页的内容变成一个个“节点”（node），这些节点就像蓝图上的标记点，互相之间还有父子关系、兄弟关系，形成一个大树。\n1 2 3 4 5 6 7 8 9 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;我的网页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;欢迎\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;这是一个段落。\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在这个 HTML 里，DOM 会把它变成一个树形结构：\n1 2 3 4 5 6 7 8 9 - \u0026lt;html\u0026gt; 是根节点，就像树的树根，整个网页的起点。 - \u0026lt;html\u0026gt; 下面有两个“孩子”：\u0026lt;head\u0026gt; 和 \u0026lt;body\u0026gt;。 - \u0026lt;head\u0026gt; 里有个孩子 \u0026lt;title\u0026gt;，它的内容是“我的网页”。 - \u0026lt;body\u0026gt; 里有两个孩子：\u0026lt;h1\u0026gt;（内容是“欢迎”）和 \u0026lt;p\u0026gt;（内容是“这是一个段落。”）。 这就像一个家庭的家谱：\u0026lt;html\u0026gt; 是爷爷，\u0026lt;head\u0026gt; 和 \u0026lt;body\u0026gt; 是他的两个孩子，\u0026lt;title\u0026gt; 是 \u0026lt;head\u0026gt; 的孩子，\u0026lt;h1\u0026gt; 和 \u0026lt;p\u0026gt; 是 \u0026lt;body\u0026gt; 的孩子。每个节点都是一个“对象”，有自己的属性，比如 \u0026lt;p\u0026gt; 的 innerHTML 属性就是“这是一个段落。”。 DOM 有什么用？ DOM 的牛逼之处在于，它让 JavaScript 能和网页互动。有了 DOM，JavaScript 就像一个装修工人，可以拿着网页的蓝图（DOM）去干活：\n查看：找到某个节点，看看它是什么内容。 修改：比如把 \u0026lt;p\u0026gt; 的文字从“这是一个段落。”改成“这是新段落！”。 添加：在 \u0026lt;body\u0026gt; 里加一个新的 \u0026lt;p\u0026gt; 节点。 删除：把某个节点去掉。 举个例子：你想做一个网页，用户点一个按钮，页面上的文字就变了。你可以用 JavaScript 写代码，通过 DOM 找到那个文字所在的节点，然后改它的内容。比如：\n1 找到 \u0026lt;p\u0026gt; 节点 let paragraph = document.querySelector(\u0026#34;p\u0026#34;); // 修改它的内容 paragraph.innerHTML = \u0026#34;文字被我改啦！\u0026#34;; 再比如，你想做一个待办事项列表，用户点按钮就能添加新任务。这也是通过 DOM 实现的：JavaScript 创建一个新节点（比如 \u0026lt;li\u0026gt;），然后把它加到列表里。\nDOM 是桥梁 所以，DOM 就像是网页（HTML）和 JavaScript 之间的“翻译官”或者“桥梁”。HTML 负责写出网页的内容和结构，DOM 把这些内容变成一个树形结构，JavaScript 通过 DOM 来动态地控制网页，让网页不再是静态的，而是可以互动、有变化的。\n小结 用最简单的话说：\nDOM 是网页的树形蓝图，把每个元素都变成节点。 JavaScript 通过 DOM 操作网页，可以改内容、加东西、删东西。 它让网页变得活起来，能根据用户的操作动态变化。 ","date":"2025-03-18T00:00:00Z","permalink":"https://Yerucrem.github.io/p/dom-%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/","title":"DOM 文档对象模型"},{"content":"SQL注入 SQL 语法不区分大小写。\nSQL基础 SELECT 我们将学习的第一种查询类型是用于从数据库中检索数据的 SELECT 查询。\nselect * from users;\n第一个单词 SELECT 告诉数据库我们想要检索一些数据;* 告诉数据库我们想从表中接收所有列。例如，该表可能包含三列（id、username 和 password）。“from users” 告诉数据库我们想要从名为 users 的表中检索数据。最后，末尾的分号告诉数据库这是查询的结束。\n下一个查询与上述查询类似，但这次，我们不是使用 * 返回数据库表中的所有列，而是只请求 username 和 password 字段。\nselect username,password from users;\n与第一个查询一样，以下查询使用 * 选择器返回所有列，然后 “LIMIT 1” 子句强制数据库仅返回一行数据。将查询更改为 “LIMIT 1,1” 会强制查询跳过第一个结果，然后 “LIMIT 2,1” 会跳过前两个结果，依此类推。您需要记住，第一个数字告诉数据库您希望跳过多少个结果，第二个数字告诉数据库要返回多少行。\nselect * from users LIMIT 1;\nselect * from users where username='admin';\n这只会返回 username 等于 admin 的行。\nselect * from users where username != 'admin';\n这只会返回 username 不 等于 admin 的行。\nselect * from users where username='admin' or username='jon';\n这只会返回用户名等于 admin 或 jon 的行。\nselect * from users where username='admin' and password='p4ssword';\n这只会返回用户名等于 admin 且密码等于 p4ssword 的行.\nlike 使用 like 子句允许您指定不完全匹配，而是以特定字符开头、包含或结尾的数据，方法是选择放置由百分号表示的通配符的位置。\nselect * from users where username like '%n';\n这将返回用户名以字母 n 结尾的任何行。\nselect * from users where username like '%mi%';\n这将返回用户名中包含字符 mi 的任何行。\nUNION UNION 语句将两个或多个 SELECT 语句的结果组合在一起，以从单个或多个表中检索数据;此查询的规则是 UNION 语句必须在每个 SELECT 语句中检索相同数量的列，列必须具有相似的数据类型，并且列顺序必须相同。这听起来可能不是很清楚，所以让我们使用下面的类比。假设一家公司想要为所有客户和供应商创建一个地址列表，以便发布新目录。我们有一个名为 customers 的表，其中包含以下内容：\n另一个表叫 suppliers，内容如下：\n使用以下 SQL 语句，我们可以从两个表中收集结果并将它们放入一个结果集中：\nSELECT name,address,city,postcode from customers UNION SELECT company,address,city,postcode from suppliers;\nINSERT INSERT 语句告诉数据库我们希望在表中插入一行新数据。 “into users” 告诉数据库我们希望将数据插入到哪个表中， “（username，password）” 提供我们提供数据的列，然后 “values （\u0026lsquo;bob\u0026rsquo;，\u0026lsquo;password\u0026rsquo;）”; 提供以前指定的列的数据。\ninsert into users (username,password) values ('bob','password123');\nUPDATE UPDATE 语句告诉数据库我们希望更新表中的一行或多行数据。您使用 “update %tablename% SET” 指定要更新的表，然后选择要更新的一个或多个字段，以逗号分隔的列表，例如 “username=\u0026lsquo;root\u0026rsquo;，password=\u0026lsquo;pass123\u0026rsquo;”，最后，类似于 SELECT 语句，您可以使用 where 子句准确指定要更新的行，例如 “where username=\u0026lsquo;admin;“\nupdate users SET username='root',password='pass123' where username='admin';\nDELETE DELETE 语句告诉数据库我们希望删除一行或多行数据。除了缺少要返回的列之外，此查询的格式与 SELECT 非常相似。您可以使用 where 子句精确指定要删除的数据，并使用 LIMIT 子句指定要删除的行 数。\ndelete from users where username='martin';\ndelete from users;\n由于查询中未使用 WHERE 子句，因此所有数据都已从表中删除。\n基础做题 In-Band SQL Injection 查询库 利用union查询的原理，先确定回显的位置。\n构建 0 UNION SELECT 1,2,3\n可以看到页面情况，有三个回显位置\n构建 0 UNION SELECT 1,2,database()\n可以知道database的名字：sqli_one\n查询表 构建 0 UNION SELECT 1,2,group_concat(table_name) FROM information_schema.tables WHERE table_schema = 'sqli_one'\n在此查询中，需要学习一些新内容。首先，方法 group_concat（） 从多个返回的行中获取指定的列（在我们的例子中为 table_name），并将其放入一个以逗号分隔的字符串中。接下来是 information_schema 数据库;数据库的每个用户都可以访问它，它包含有关该用户有权访问的所有数据库和表的信息。在这个特定的查询中，我们有兴趣列出 sqli_one 数据库中的所有 表，即 article 和 staff_users。\n由于第一级旨在发现 Martin 的密码，因此 staff_users 表是我们感兴趣的。我们可以再次利用 information_schema 数据库，通过以下查询找到此表的结构。\n0 UNION SELECT 1,2,group_concat(column_name) FROM information_schema.columns WHERE table_name = 'staff_users'\n这与前面的 SQL 查询类似。但是，我们要检索的信息已从 table_name 更改为 column_name，我们在 information_schema 数据库中查询的表已从 tables 更改为 columns，并且我们正在搜索 table_name 列值为 staff_users 的任何行\n查询结果为 staff_users 表提供三列：id、password 和 username。我们可以使用以下查询的 username 和 password 列来检索用户的信息。\n0 UNION SELECT 1,2,group_concat(username,':',password SEPARATOR '\u0026lt;br\u0026gt;') FROM staff_users\n同样，我们使用 group_concat 方法将所有行返回到一个字符串中，使其 更易于阅读。我们还添加了 ，\u0026rsquo;：\u0026rsquo;， 以将用户名和密码彼此分开。我们没有用逗号分隔，而是选择了 HTML \u0026lt;br\u0026gt; 标签，该标签强制每个结果位于单独的行上，以便于阅读。\n身份认证绕过盲注 与带内 SQL 注入不同，我们可以直接在屏幕上看到攻击的结果，而盲 SQLi 是指我们几乎没有收到反馈来确认我们注入的查询是否真的成功，这是因为错误消息已被禁用，但无论如何注入仍然有效。您可能会感到惊讶，我们只需要一点点反馈即可成功枚举整个数据库。\n最直接的盲 SQL 注入技术之一是绕过身份验证方法，例如登录表单。在这种情况下，我们对从数据库中检索数据并不那么感兴趣;我们只想通过登录。\n连接到用户数据库的登录表单的开发方式通常使 Web 应用程序对用户名和密码的内容不感兴趣，而更关心两者是否在 users 表中形成匹配的对。简单来说，Web 应用程序会询问数据库，“您有用户名为 bob 的用户，密码为 bob123 吗？ 数据库回答 Yes 或 No （true/false），并且根据该答案，指示 Web 应用程序是否允许您继续。\n考虑到上述信息，没有必要枚举有效的用户名/密码对。我们只需要创建一个以 yes/true 回复的数据库查询。\n实际： SQL 注入示例的第二级显示了这个确切的示例。我们可以在标有 “SQL Query” 的框中看到，对数据库的查询如下：\nselect * from users where username='%username%' and password='%password%' LIMIT 1;\n注意：%username% 和 %password% 值取自登录表单字段。SQL Query （SQL 查询） 框中的初始值将为空，因为这些字段当前为空。\n要将其转换为始终返回 true 的查询，我们可以在 password 字段中输入以下内容：\n' OR 1=1;--\n这会将 SQL 查询转换为以下内容：\nselect * from users where username='' and password='' OR 1=1;\n因为 1=1 是 true 语句，并且我们使用了 OR 运算符，所以这将始终导致查询返回 true，这满足 Web 应用程序逻辑，即数据库找到了有效的用户名/密码组合，并且应该允许访问。\n基于布尔盲注 基于布尔值的 SQL 注入是指我们从注入尝试中收到的响应，可以是 true/false、yes/no、on/off、1/0 或任何只能有两个结果的响应。该结果确认了我们的 SQL Injection payload 成功或失败。在第一次检查时，您可能会觉得这种有限的回答无法提供太多信息。不过，仅通过这两个响应，就可以枚举整个数据库结构和内容。\n实际： 览器正文包含 {“taken”：true}。此 API 端点复制了许多订阅表单上的常见功能，该功能检查用户名是否已注册，以提示用户选择不同的用户名。 由于 taken 的值设置为 true，因此我们可以假设用户名 admin 已注册。我们可以通过将模拟浏览器地址栏中的用户名从 admin 更改为 admin123 来确认这一点，按下 Enter 键后，你会看到所采用的值 现在已更改为 false\nselect * from users where username = '%username%' LIMIT 1;\n我们唯一可以控制的输入是查询字符串中的用户名，我们必须使用它来执行 SQL 注入。将用户名保持为 admin123，我们可以开始附加到此内容以尝试使数据库确认 true 内容，将 taken 字段的状态从 false 更改为 true。\n与前面的级别一样，我们的第一个任务是建立 users\u0026rsquo; 表中的列数，这可以通过使用 UNION 语句来实现。将 username 值更改为以下内容：\nadmin123' UNION SELECT 1;-- 由于 Web 应用程序已使用取为 false 的值 进行响应，因此我们可以确认这是不正确的列值。 继续添加更多列，直到我们得到 true 的 taken 值 。您可以通过将 username 设置为以下值来确认答案为三列：\nadmin123' UNION SELECT 1,2,3;-- 在我们已经确定了列数，我们可以进行数据库的枚举。我们的第一个任务是发现数据库名称。我们可以通过使用内置的 database（） 方法，然后使用 like 运算符来尝试查找将返回 true 状态的结果。\n尝试以下 username 值，看看会发生什么：\nadmin123' UNION SELECT 1,2,3 where database() like '%';--\n我们得到一个 true 响应，因为在 like 运算符中，我们只有 % 的值 ，它将匹配任何内容，因为它是通配符值。如果我们将通配符运算符更改为 **a%，**您将看到响应返回 false，这确认数据库名称不以字母 a 开头。我们可以循环遍历所有字母、数字和字符，例如 - 和 _，直到找到匹配项。如果您将以下内容作为 username 值发送，您将收到一个 true 响应，确认数据库名称以字母 s 开头\nadmin123' UNION SELECT 1,2,3 where database() like 's%';--\n现在，您继续 数据库名称的下一个字符，直到找到另一个真实的响应，例如，\u0026lsquo;sa%\u0026rsquo;、\u0026lsquo;sb%\u0026rsquo;、\u0026lsquo;sc%\u0026rsquo; 等。继续此过程，直到发现数据库名称的所有字符，即 sqli_three\n我们已经建立了数据库名称，现在我们可以通过使用 information_schema 数据库使用类似的方法使用它来枚举表名。尝试将 username 设置为以下值：\nadmin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name like 'a%';--\n此查询在 tables 表中的 information_schema 数据库中 查找数据库名称与 sqli_three 匹配 且表名称以字母 a 开头的结果。 由于上述查询导致 false 响应，我们可以确认 sqli_three 数据库中没有以字母 a 开头的表。和以前一样，您需要在字母、数字和字符之间循环，直到找到正匹配项。\n您最终会在 sqli_three 数据库中发现一个名为 users 的表，您可以通过运行以下 username payload 来确认该表：\nadmin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name='users';--\n最后，我们现在需要枚举 users 表中的列名 ，以便我们可以正确地搜索登录凭据。 同样，我们可以使用 information_schema 数据库和我们已经获得的信息来查询它的列名。使用下面的有效负载，我们搜索 columns 表，其中 database 等于 sqli_three，表名称为 users，列名称以字母 a 开头。\nadmin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%';\n同样， 您需要在字母、数字和字符之间循环，直到找到匹配项。由于您要查找多个结果，因此每次找到新的列名称时，都必须将其添加到有效负载中，以避免发现相同的结果。例如，找到名为 id 的列后，将其附加到原始有效负载中（如下所示）。\nadmin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%' and COLUMN_NAME !='id';\n重复此过程 3 次，您将发现列的 ID、用户名和密码。现在，您可以使用它来查询 users 表以获取登录凭据。首先，您需要找到一个有效的用户名，您可以使用下面的有效负载：\nadmin123' UNION SELECT 1,2,3 from users where username like 'a%\nadmin123' UNION SELECT 1,2,3 from users where username='admin' and password like 'a%\n基于时间的盲注 基于时间的盲目 SQL 注入与上述基于 布尔值的盲注非常相似，因为发送的请求相同，但这次没有明显的查询是错还是对的指示。相反，正确查询的指标基于查询完成所需的时间。此时间延迟是使用内置方法（如 SLEEP（x） 和 UNION 语句引入的。SLEEP（） 方法只会在成功的 UNION SELECT 语句后执行。\n实际： 因此，例如，在尝试建立表中的列数时，您将使用以下查询：\nadmin123' UNION SELECT SLEEP(5);--\n如果响应时间没有暂停，则我们知道查询不成功，因此与之前的任务一样，我们添加另一列：\nadmin123' UNION SELECT SLEEP(5),2;--\n有效负载应产生 5 秒的延迟，确认 UNION 语句成功执行，并且有两列。\n按照布尔盲注的步骤，只是更改一下前面的语句，要改成sleep()形式\n最后得到admin：4961\n","date":"2025-03-18T00:00:00Z","permalink":"https://Yerucrem.github.io/p/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","title":"SQL注入基础"},{"content":"XSS THM 做题记录 Level One: 看到一个表单，要您输入的姓名，输入姓名后，该表单将在下面的一行中显示，例如：\n如果查看 Page Source，将看到姓名反映在代码中：\n我们将尝试输入以下 JavaScript Payload，而不是输入姓名： \u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt;\n现在，当单击输入按钮时，将收到一个带有字符串 THM 的警报弹出窗口，页面源代码将如下所示：\nLevel Two： 与上一个级别一样，系统将再次要求您输入的姓名。这一次，当单击 enter 时，姓名将反映在 input 标签中：\n查看页面源，可以看到姓名反映在 input 标签的 value 属性中：\n如果要尝试前面的 JavaScript 有效负载，它将不起作用，因为无法从 input 标签内部运行它。相反，我们需要先转义 input 标签，以便 payload 可以正常运行。可以使用以下有效负载执行此作：\n\u0026quot;\u0026gt;\u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt;\n有效负载的重要部分是“\u0026gt;”，它关闭 value 参数，然后关闭 input 标记。\n现在，这会正确关闭 input 标记并允许 JavaScript 有效负载运行：\nLevel Three: 看到另一个表单，询问名字，与上一级一样，名字会反映在 HTML 标签中，这次是 textarea 标签。\n我们必须使用以下有效负载，以略微不同的方式转义 textarea 标签和输入 1（在 Level Two 中）：\n\u0026lt;/textarea\u0026gt;\u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt;\n上述有效负载的重要部分是 \u0026lt;/textarea\u0026gt;，它会导致 textarea 元素关闭，以便脚本运行。\nLevel Four: 在表单中输入姓名，会在页面上看到它。此级别看起来类似于 1 级，但在检查页面源代码时，会看到名字反映在一些 JavaScript 代码中。\n必须转义现有的 JavaScript 命令，以便能够运行代码;可以使用以下有效负载 ';alert（'THM'）;// 从下面的屏幕截图中可以看到，它将执行代码。' 关闭指定名称的字段，然后 ;表示当前命令的结束，末尾的 则``使它后面的任何内容成为注释，而不是可执行代码。\nLevel Five: 现在，此级别看起来与级别 1 相同，并且名字也会反映在同一个位置。但是，如果尝试有效负载 \u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt; ，它将不起作用。当查看页面源代码时，将了解原因。\nscript 会从有效负载中删除，这是因为有一个过滤器可以去除任何具有潜在危险的单词。\n当一个单词从字符串中删除时，你可以尝试一个有用的技巧。\n尝试输入有效负载 \u0026lt;sscriptcript\u0026gt;alert('THM');\u0026lt;/sscriptcript\u0026gt; 并单击输入按钮，将看到一个带有字符串 THM 的警报弹出窗口。\nLevel Six: 与第二级类似，我们必须从 input 标签的 value 属性中转义，我们可以尝试 \u0026quot;\u0026gt;\u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt; ，但这似乎不起作用。让我们检查一下页面源代码，看看为什么这不起作用。\n可以看到 \u0026lt; 和 \u0026gt; 字符从我们的 payload 中被过滤掉，从而阻止我们转义 IMG 标签。为了绕过过滤器，我们可以利用 IMG 标签的其他属性，比如 onload 事件。onload 事件将在 src 属性中指定的图像加载到网页后执行您选择的代码。\n让我们更改 payload 以反映这一点 /images/cat.jpg\u0026quot; onload=\u0026quot;alert('THM'); ，然后查看页面源，您将看到这将如何工作。\nPolyglots: XSS 多语言是一串文本，可以一站式转义属性、标签和绕过过滤器。可以在刚刚完成的所有 6 个级别上使用以下多语言，并且它会成功执行代码。\n1 jaVasCript:/*-/*`/*\\`/*\u0026#39;/*\u0026#34;/**/(/* */onerror=alert(\u0026#39;THM\u0026#39;) )//%0D%0A%0d%0a//\u0026lt;/stYle/\u0026lt;/titLe/\u0026lt;/teXtarEa/\u0026lt;/scRipt/--!\u0026gt;\\x3csVg/\u0026lt;sVg/oNloAd=alert(\u0026#39;THM\u0026#39;)//\u0026gt;\\x3e ","date":"2025-03-18T00:00:00Z","permalink":"https://Yerucrem.github.io/p/%E5%85%B3%E4%BA%8Exss%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%A9%E7%94%A8/","title":"关于XSS基础的利用"},{"content":"自动部署 参考 【Hugo】Hugo + Github 免费部署自己的博客\n首次部署 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main 更新 在dev目录下\n1 2 3 4 5 git init git add . git commit -m \u0026#34;update\u0026#34; git branch -M main git push ","date":"2025-03-18T00:00:00Z","permalink":"https://Yerucrem.github.io/p/%E5%88%A9%E7%94%A8github%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","title":"利用github实现自动部署"},{"content":"命令注入 分类 命令注入主要可以通过以下两种方式之一进行检测：\n盲命令注入 详细命令注入 方法 描述 盲 这种类型的注入是在测试有效负载时应用程序没有直接输出的地方。您必须调查应用程序的行为，以确定您的有效负载是否成功。 详细 这种类型的注入是测试有效负载后从应用程序获得直接反馈的地方。例如，运行 whoami 命令以查看应用程序在哪个用户下运行。Web 应用程序将直接在页面上输出用户名。 有用的有效载荷 Linux 有效载荷 描述 whoami 查看应用程序在哪个用户下运行。 ls 列出当前目录的内容。您也许能够找到配置文件、环境文件（令牌和应用程序密钥）等文件，以及更多有价值的内容。 ping 此命令将调用应用程序以挂起。这在测试应用程序是否进行盲命令注入时非常有用。 sleep 这是测试应用程序盲目命令注入时的另一个有用有效负载，其中计算机未安装 ping。 nc Netcat 可用于在易受攻击的应用程序上生成反向 shell。您可以使用此立足点在目标计算机上导航，以获取其他服务、文件或提升权限的潜在方法。 windows 有效载荷 描述 whoami 查看应用程序在哪个用户下运行。 dir 列出当前目录的内容。您也许能够找到配置文件、环境文件（令牌和应用程序密钥）等文件，以及更多有价值的内容。 ping 此命令将调用应用程序以挂起。这在测试应用程序是否进行盲命令注入时非常有用。 timeout 此命令还将调用应用程序以挂起。如果未安装 ping 命令，则它还可用于测试应用程序是否进行盲命令注入。 ","date":"2025-03-18T00:00:00Z","permalink":"https://Yerucrem.github.io/p/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","title":"命令注入基础"}]