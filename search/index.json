[{"content":"DOM Document Object Model 文档对象模型\n什么是文档对象模型？ \u0026mdash; What is the Document Object Model?\nDOM 是什么？ 想象一下，你有一张房子的建筑蓝图，上面画着房子的每一个部分：墙、门、窗户、屋顶等等。DOM 就像是网页的“蓝图”。当你打开一个网页，浏览器会把网页的 HTML 代码（那些 \u0026lt;html\u0026gt;、\u0026lt;div\u0026gt;、\u0026lt;p\u0026gt; 标签）解析成一个树状结构，这个结构就是 DOM。它把网页里的每一个元素（比如标题、段落、图片）都整理得清清楚楚，让计算机（特别是 JavaScript）能找到它们、操作它们。\n简单来说，DOM 是网页的骨架图，它把网页的内容变成一个个“节点”（node），这些节点就像蓝图上的标记点，互相之间还有父子关系、兄弟关系，形成一个大树。\n1 2 3 4 5 6 7 8 9 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;我的网页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;欢迎\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;这是一个段落。\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在这个 HTML 里，DOM 会把它变成一个树形结构：\n1 2 3 4 5 6 7 8 9 - \u0026lt;html\u0026gt; 是根节点，就像树的树根，整个网页的起点。 - \u0026lt;html\u0026gt; 下面有两个“孩子”：\u0026lt;head\u0026gt; 和 \u0026lt;body\u0026gt;。 - \u0026lt;head\u0026gt; 里有个孩子 \u0026lt;title\u0026gt;，它的内容是“我的网页”。 - \u0026lt;body\u0026gt; 里有两个孩子：\u0026lt;h1\u0026gt;（内容是“欢迎”）和 \u0026lt;p\u0026gt;（内容是“这是一个段落。”）。 这就像一个家庭的家谱：\u0026lt;html\u0026gt; 是爷爷，\u0026lt;head\u0026gt; 和 \u0026lt;body\u0026gt; 是他的两个孩子，\u0026lt;title\u0026gt; 是 \u0026lt;head\u0026gt; 的孩子，\u0026lt;h1\u0026gt; 和 \u0026lt;p\u0026gt; 是 \u0026lt;body\u0026gt; 的孩子。每个节点都是一个“对象”，有自己的属性，比如 \u0026lt;p\u0026gt; 的 innerHTML 属性就是“这是一个段落。”。 DOM 有什么用？ DOM 的牛逼之处在于，它让 JavaScript 能和网页互动。有了 DOM，JavaScript 就像一个装修工人，可以拿着网页的蓝图（DOM）去干活：\n查看：找到某个节点，看看它是什么内容。 修改：比如把 \u0026lt;p\u0026gt; 的文字从“这是一个段落。”改成“这是新段落！”。 添加：在 \u0026lt;body\u0026gt; 里加一个新的 \u0026lt;p\u0026gt; 节点。 删除：把某个节点去掉。 举个例子：你想做一个网页，用户点一个按钮，页面上的文字就变了。你可以用 JavaScript 写代码，通过 DOM 找到那个文字所在的节点，然后改它的内容。比如：\n1 找到 \u0026lt;p\u0026gt; 节点 let paragraph = document.querySelector(\u0026#34;p\u0026#34;); // 修改它的内容 paragraph.innerHTML = \u0026#34;文字被我改啦！\u0026#34;; 再比如，你想做一个待办事项列表，用户点按钮就能添加新任务。这也是通过 DOM 实现的：JavaScript 创建一个新节点（比如 \u0026lt;li\u0026gt;），然后把它加到列表里。\nDOM 是桥梁 所以，DOM 就像是网页（HTML）和 JavaScript 之间的“翻译官”或者“桥梁”。HTML 负责写出网页的内容和结构，DOM 把这些内容变成一个树形结构，JavaScript 通过 DOM 来动态地控制网页，让网页不再是静态的，而是可以互动、有变化的。\n小结 用最简单的话说：\nDOM 是网页的树形蓝图，把每个元素都变成节点。 JavaScript 通过 DOM 操作网页，可以改内容、加东西、删东西。 它让网页变得活起来，能根据用户的操作动态变化。 ","date":"2025-03-18T00:00:00Z","permalink":"https://Yerucrem.github.io/p/dom-%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/","title":"DOM 文档对象模型"},{"content":"SQL注入 SQL 语法不区分大小写。\nSQL基础 SELECT 我们将学习的第一种查询类型是用于从数据库中检索数据的 SELECT 查询。\nselect * from users;\n第一个单词 SELECT 告诉数据库我们想要检索一些数据;* 告诉数据库我们想从表中接收所有列。例如，该表可能包含三列（id、username 和 password）。“from users” 告诉数据库我们想要从名为 users 的表中检索数据。最后，末尾的分号告诉数据库这是查询的结束。\n下一个查询与上述查询类似，但这次，我们不是使用 * 返回数据库表中的所有列，而是只请求 username 和 password 字段。\nselect username,password from users;\n与第一个查询一样，以下查询使用 * 选择器返回所有列，然后 “LIMIT 1” 子句强制数据库仅返回一行数据。将查询更改为 “LIMIT 1,1” 会强制查询跳过第一个结果，然后 “LIMIT 2,1” 会跳过前两个结果，依此类推。您需要记住，第一个数字告诉数据库您希望跳过多少个结果，第二个数字告诉数据库要返回多少行。\nselect * from users LIMIT 1;\nselect * from users where username='admin';\n这只会返回 username 等于 admin 的行。\nselect * from users where username != 'admin';\n这只会返回 username 不 等于 admin 的行。\nselect * from users where username='admin' or username='jon';\n这只会返回用户名等于 admin 或 jon 的行。\nselect * from users where username='admin' and password='p4ssword';\n这只会返回用户名等于 admin 且密码等于 p4ssword 的行.\nlike 使用 like 子句允许您指定不完全匹配，而是以特定字符开头、包含或结尾的数据，方法是选择放置由百分号表示的通配符的位置。\nselect * from users where username like '%n';\n这将返回用户名以字母 n 结尾的任何行。\nselect * from users where username like '%mi%';\n这将返回用户名中包含字符 mi 的任何行。\nUNION UNION 语句将两个或多个 SELECT 语句的结果组合在一起，以从单个或多个表中检索数据;此查询的规则是 UNION 语句必须在每个 SELECT 语句中检索相同数量的列，列必须具有相似的数据类型，并且列顺序必须相同。这听起来可能不是很清楚，所以让我们使用下面的类比。假设一家公司想要为所有客户和供应商创建一个地址列表，以便发布新目录。我们有一个名为 customers 的表，其中包含以下内容：\n另一个表叫 suppliers，内容如下：\n使用以下 SQL 语句，我们可以从两个表中收集结果并将它们放入一个结果集中：\nSELECT name,address,city,postcode from customers UNION SELECT company,address,city,postcode from suppliers;\nINSERT INSERT 语句告诉数据库我们希望在表中插入一行新数据。 “into users” 告诉数据库我们希望将数据插入到哪个表中， “（username，password）” 提供我们提供数据的列，然后 “values （\u0026lsquo;bob\u0026rsquo;，\u0026lsquo;password\u0026rsquo;）”; 提供以前指定的列的数据。\ninsert into users (username,password) values ('bob','password123');\nUPDATE UPDATE 语句告诉数据库我们希望更新表中的一行或多行数据。您使用 “update %tablename% SET” 指定要更新的表，然后选择要更新的一个或多个字段，以逗号分隔的列表，例如 “username=\u0026lsquo;root\u0026rsquo;，password=\u0026lsquo;pass123\u0026rsquo;”，最后，类似于 SELECT 语句，您可以使用 where 子句准确指定要更新的行，例如 “where username=\u0026lsquo;admin;“\nupdate users SET username='root',password='pass123' where username='admin';\nDELETE DELETE 语句告诉数据库我们希望删除一行或多行数据。除了缺少要返回的列之外，此查询的格式与 SELECT 非常相似。您可以使用 where 子句精确指定要删除的数据，并使用 LIMIT 子句指定要删除的行 数。\ndelete from users where username='martin';\ndelete from users;\n由于查询中未使用 WHERE 子句，因此所有数据都已从表中删除。\n基础做题 In-Band SQL Injection 查询库 利用union查询的原理，先确定回显的位置。\n构建 0 UNION SELECT 1,2,3\n可以看到页面情况，有三个回显位置\n构建 0 UNION SELECT 1,2,database()\n可以知道database的名字：sqli_one\n查询表 构建 0 UNION SELECT 1,2,group_concat(table_name) FROM information_schema.tables WHERE table_schema = 'sqli_one'\n在此查询中，需要学习一些新内容。首先，方法 group_concat（） 从多个返回的行中获取指定的列（在我们的例子中为 table_name），并将其放入一个以逗号分隔的字符串中。接下来是 information_schema 数据库;数据库的每个用户都可以访问它，它包含有关该用户有权访问的所有数据库和表的信息。在这个特定的查询中，我们有兴趣列出 sqli_one 数据库中的所有 表，即 article 和 staff_users。\n由于第一级旨在发现 Martin 的密码，因此 staff_users 表是我们感兴趣的。我们可以再次利用 information_schema 数据库，通过以下查询找到此表的结构。\n0 UNION SELECT 1,2,group_concat(column_name) FROM information_schema.columns WHERE table_name = 'staff_users'\n这与前面的 SQL 查询类似。但是，我们要检索的信息已从 table_name 更改为 column_name，我们在 information_schema 数据库中查询的表已从 tables 更改为 columns，并且我们正在搜索 table_name 列值为 staff_users 的任何行\n查询结果为 staff_users 表提供三列：id、password 和 username。我们可以使用以下查询的 username 和 password 列来检索用户的信息。\n0 UNION SELECT 1,2,group_concat(username,':',password SEPARATOR '\u0026lt;br\u0026gt;') FROM staff_users\n同样，我们使用 group_concat 方法将所有行返回到一个字符串中，使其 更易于阅读。我们还添加了 ，\u0026rsquo;：\u0026rsquo;， 以将用户名和密码彼此分开。我们没有用逗号分隔，而是选择了 HTML \u0026lt;br\u0026gt; 标签，该标签强制每个结果位于单独的行上，以便于阅读。\n身份认证绕过盲注 与带内 SQL 注入不同，我们可以直接在屏幕上看到攻击的结果，而盲 SQLi 是指我们几乎没有收到反馈来确认我们注入的查询是否真的成功，这是因为错误消息已被禁用，但无论如何注入仍然有效。您可能会感到惊讶，我们只需要一点点反馈即可成功枚举整个数据库。\n最直接的盲 SQL 注入技术之一是绕过身份验证方法，例如登录表单。在这种情况下，我们对从数据库中检索数据并不那么感兴趣;我们只想通过登录。\n连接到用户数据库的登录表单的开发方式通常使 Web 应用程序对用户名和密码的内容不感兴趣，而更关心两者是否在 users 表中形成匹配的对。简单来说，Web 应用程序会询问数据库，“您有用户名为 bob 的用户，密码为 bob123 吗？ 数据库回答 Yes 或 No （true/false），并且根据该答案，指示 Web 应用程序是否允许您继续。\n考虑到上述信息，没有必要枚举有效的用户名/密码对。我们只需要创建一个以 yes/true 回复的数据库查询。\n实际： SQL 注入示例的第二级显示了这个确切的示例。我们可以在标有 “SQL Query” 的框中看到，对数据库的查询如下：\nselect * from users where username='%username%' and password='%password%' LIMIT 1;\n注意：%username% 和 %password% 值取自登录表单字段。SQL Query （SQL 查询） 框中的初始值将为空，因为这些字段当前为空。\n要将其转换为始终返回 true 的查询，我们可以在 password 字段中输入以下内容：\n' OR 1=1;--\n这会将 SQL 查询转换为以下内容：\nselect * from users where username='' and password='' OR 1=1;\n因为 1=1 是 true 语句，并且我们使用了 OR 运算符，所以这将始终导致查询返回 true，这满足 Web 应用程序逻辑，即数据库找到了有效的用户名/密码组合，并且应该允许访问。\n基于布尔盲注 基于布尔值的 SQL 注入是指我们从注入尝试中收到的响应，可以是 true/false、yes/no、on/off、1/0 或任何只能有两个结果的响应。该结果确认了我们的 SQL Injection payload 成功或失败。在第一次检查时，您可能会觉得这种有限的回答无法提供太多信息。不过，仅通过这两个响应，就可以枚举整个数据库结构和内容。\n实际： 览器正文包含 {“taken”：true}。此 API 端点复制了许多订阅表单上的常见功能，该功能检查用户名是否已注册，以提示用户选择不同的用户名。 由于 taken 的值设置为 true，因此我们可以假设用户名 admin 已注册。我们可以通过将模拟浏览器地址栏中的用户名从 admin 更改为 admin123 来确认这一点，按下 Enter 键后，你会看到所采用的值 现在已更改为 false\nselect * from users where username = '%username%' LIMIT 1;\n我们唯一可以控制的输入是查询字符串中的用户名，我们必须使用它来执行 SQL 注入。将用户名保持为 admin123，我们可以开始附加到此内容以尝试使数据库确认 true 内容，将 taken 字段的状态从 false 更改为 true。\n与前面的级别一样，我们的第一个任务是建立 users\u0026rsquo; 表中的列数，这可以通过使用 UNION 语句来实现。将 username 值更改为以下内容：\nadmin123' UNION SELECT 1;-- 由于 Web 应用程序已使用取为 false 的值 进行响应，因此我们可以确认这是不正确的列值。 继续添加更多列，直到我们得到 true 的 taken 值 。您可以通过将 username 设置为以下值来确认答案为三列：\nadmin123' UNION SELECT 1,2,3;-- 在我们已经确定了列数，我们可以进行数据库的枚举。我们的第一个任务是发现数据库名称。我们可以通过使用内置的 database（） 方法，然后使用 like 运算符来尝试查找将返回 true 状态的结果。\n尝试以下 username 值，看看会发生什么：\nadmin123' UNION SELECT 1,2,3 where database() like '%';--\n我们得到一个 true 响应，因为在 like 运算符中，我们只有 % 的值 ，它将匹配任何内容，因为它是通配符值。如果我们将通配符运算符更改为 **a%，**您将看到响应返回 false，这确认数据库名称不以字母 a 开头。我们可以循环遍历所有字母、数字和字符，例如 - 和 _，直到找到匹配项。如果您将以下内容作为 username 值发送，您将收到一个 true 响应，确认数据库名称以字母 s 开头\nadmin123' UNION SELECT 1,2,3 where database() like 's%';--\n现在，您继续 数据库名称的下一个字符，直到找到另一个真实的响应，例如，\u0026lsquo;sa%\u0026rsquo;、\u0026lsquo;sb%\u0026rsquo;、\u0026lsquo;sc%\u0026rsquo; 等。继续此过程，直到发现数据库名称的所有字符，即 sqli_three\n我们已经建立了数据库名称，现在我们可以通过使用 information_schema 数据库使用类似的方法使用它来枚举表名。尝试将 username 设置为以下值：\nadmin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name like 'a%';--\n此查询在 tables 表中的 information_schema 数据库中 查找数据库名称与 sqli_three 匹配 且表名称以字母 a 开头的结果。 由于上述查询导致 false 响应，我们可以确认 sqli_three 数据库中没有以字母 a 开头的表。和以前一样，您需要在字母、数字和字符之间循环，直到找到正匹配项。\n您最终会在 sqli_three 数据库中发现一个名为 users 的表，您可以通过运行以下 username payload 来确认该表：\nadmin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name='users';--\n最后，我们现在需要枚举 users 表中的列名 ，以便我们可以正确地搜索登录凭据。 同样，我们可以使用 information_schema 数据库和我们已经获得的信息来查询它的列名。使用下面的有效负载，我们搜索 columns 表，其中 database 等于 sqli_three，表名称为 users，列名称以字母 a 开头。\nadmin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%';\n同样， 您需要在字母、数字和字符之间循环，直到找到匹配项。由于您要查找多个结果，因此每次找到新的列名称时，都必须将其添加到有效负载中，以避免发现相同的结果。例如，找到名为 id 的列后，将其附加到原始有效负载中（如下所示）。\nadmin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%' and COLUMN_NAME !='id';\n重复此过程 3 次，您将发现列的 ID、用户名和密码。现在，您可以使用它来查询 users 表以获取登录凭据。首先，您需要找到一个有效的用户名，您可以使用下面的有效负载：\nadmin123' UNION SELECT 1,2,3 from users where username like 'a%\nadmin123' UNION SELECT 1,2,3 from users where username='admin' and password like 'a%\n基于时间的盲注 基于时间的盲目 SQL 注入与上述基于 布尔值的盲注非常相似，因为发送的请求相同，但这次没有明显的查询是错还是对的指示。相反，正确查询的指标基于查询完成所需的时间。此时间延迟是使用内置方法（如 SLEEP（x） 和 UNION 语句引入的。SLEEP（） 方法只会在成功的 UNION SELECT 语句后执行。\n因此，例如，在尝试建立表中的列数时，您将使用以下查询：\nadmin123' UNION SELECT SLEEP(5);--\n如果响应时间没有暂停，则我们知道查询不成功，因此与之前的任务一样，我们添加另一列：\nadmin123' UNION SELECT SLEEP(5),2;--\n有效负载应产生 5 秒的延迟，确认 UNION 语句成功执行，并且有两列。\n按照布尔盲注的步骤，只是更改一下前面的语句，要改成sleep()形式\n最后得到admin：4961\n","date":"2025-03-18T00:00:00Z","permalink":"https://Yerucrem.github.io/p/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","title":"SQL注入基础"},{"content":"XSS THM 做题记录 Level One: 看到一个表单，要您输入的姓名，输入姓名后，该表单将在下面的一行中显示，例如：\n如果查看 Page Source，将看到姓名反映在代码中：\n我们将尝试输入以下 JavaScript Payload，而不是输入姓名： \u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt;\n现在，当单击输入按钮时，将收到一个带有字符串 THM 的警报弹出窗口，页面源代码将如下所示：\nLevel Two： 与上一个级别一样，系统将再次要求您输入的姓名。这一次，当单击 enter 时，姓名将反映在 input 标签中：\n查看页面源，可以看到姓名反映在 input 标签的 value 属性中：\n如果要尝试前面的 JavaScript 有效负载，它将不起作用，因为无法从 input 标签内部运行它。相反，我们需要先转义 input 标签，以便 payload 可以正常运行。可以使用以下有效负载执行此作：\n\u0026quot;\u0026gt;\u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt;\n有效负载的重要部分是“\u0026gt;”，它关闭 value 参数，然后关闭 input 标记。\n现在，这会正确关闭 input 标记并允许 JavaScript 有效负载运行：\nLevel Three: 看到另一个表单，询问名字，与上一级一样，名字会反映在 HTML 标签中，这次是 textarea 标签。\n我们必须使用以下有效负载，以略微不同的方式转义 textarea 标签和输入 1（在 Level Two 中）：\n\u0026lt;/textarea\u0026gt;\u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt;\n上述有效负载的重要部分是 \u0026lt;/textarea\u0026gt;，它会导致 textarea 元素关闭，以便脚本运行。\nLevel Four: 在表单中输入姓名，会在页面上看到它。此级别看起来类似于 1 级，但在检查页面源代码时，会看到名字反映在一些 JavaScript 代码中。\n必须转义现有的 JavaScript 命令，以便能够运行代码;可以使用以下有效负载 ';alert（'THM'）;// 从下面的屏幕截图中可以看到，它将执行代码。' 关闭指定名称的字段，然后 ;表示当前命令的结束，末尾的 则``使它后面的任何内容成为注释，而不是可执行代码。\nLevel Five: 现在，此级别看起来与级别 1 相同，并且名字也会反映在同一个位置。但是，如果尝试有效负载 \u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt; ，它将不起作用。当查看页面源代码时，将了解原因。\nscript 会从有效负载中删除，这是因为有一个过滤器可以去除任何具有潜在危险的单词。\n当一个单词从字符串中删除时，你可以尝试一个有用的技巧。\n尝试输入有效负载 \u0026lt;sscriptcript\u0026gt;alert('THM');\u0026lt;/sscriptcript\u0026gt; 并单击输入按钮，将看到一个带有字符串 THM 的警报弹出窗口。\nLevel Six: 与第二级类似，我们必须从 input 标签的 value 属性中转义，我们可以尝试 \u0026quot;\u0026gt;\u0026lt;script\u0026gt;alert('THM');\u0026lt;/script\u0026gt; ，但这似乎不起作用。让我们检查一下页面源代码，看看为什么这不起作用。\n可以看到 \u0026lt; 和 \u0026gt; 字符从我们的 payload 中被过滤掉，从而阻止我们转义 IMG 标签。为了绕过过滤器，我们可以利用 IMG 标签的其他属性，比如 onload 事件。onload 事件将在 src 属性中指定的图像加载到网页后执行您选择的代码。\n让我们更改 payload 以反映这一点 /images/cat.jpg\u0026quot; onload=\u0026quot;alert('THM'); ，然后查看页面源，您将看到这将如何工作。\nPolyglots: XSS 多语言是一串文本，可以一站式转义属性、标签和绕过过滤器。可以在刚刚完成的所有 6 个级别上使用以下多语言，并且它会成功执行代码。\n1 jaVasCript:/*-/*`/*\\`/*\u0026#39;/*\u0026#34;/**/(/* */onerror=alert(\u0026#39;THM\u0026#39;) )//%0D%0A%0d%0a//\u0026lt;/stYle/\u0026lt;/titLe/\u0026lt;/teXtarEa/\u0026lt;/scRipt/--!\u0026gt;\\x3csVg/\u0026lt;sVg/oNloAd=alert(\u0026#39;THM\u0026#39;)//\u0026gt;\\x3e ","date":"2025-03-18T00:00:00Z","permalink":"https://Yerucrem.github.io/p/%E5%85%B3%E4%BA%8Exss%E5%9F%BA%E7%A1%80%E7%9A%84%E5%88%A9%E7%94%A8/","title":"关于XSS基础的利用"},{"content":"自动部署 参考 【Hugo】Hugo + Github 免费部署自己的博客\n首次部署 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main 更新 1 2 3 4 5 git init git add . git commit -m \u0026#34;update\u0026#34; git branch -M main git push ","date":"2025-03-18T00:00:00Z","permalink":"https://Yerucrem.github.io/p/%E5%88%A9%E7%94%A8github%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","title":"利用github实现自动部署"},{"content":"命令注入 分类 命令注入主要可以通过以下两种方式之一进行检测：\n盲命令注入 详细命令注入 方法 描述 盲 这种类型的注入是在测试有效负载时应用程序没有直接输出的地方。您必须调查应用程序的行为，以确定您的有效负载是否成功。 详细 这种类型的注入是测试有效负载后从应用程序获得直接反馈的地方。例如，运行 whoami 命令以查看应用程序在哪个用户下运行。Web 应用程序将直接在页面上输出用户名。 有用的有效载荷 Linux 有效载荷 描述 whoami 查看应用程序在哪个用户下运行。 ls 列出当前目录的内容。您也许能够找到配置文件、环境文件（令牌和应用程序密钥）等文件，以及更多有价值的内容。 ping 此命令将调用应用程序以挂起。这在测试应用程序是否进行盲命令注入时非常有用。 sleep 这是测试应用程序盲目命令注入时的另一个有用有效负载，其中计算机未安装 ping。 nc Netcat 可用于在易受攻击的应用程序上生成反向 shell。您可以使用此立足点在目标计算机上导航，以获取其他服务、文件或提升权限的潜在方法。 windows 有效载荷 描述 whoami 查看应用程序在哪个用户下运行。 dir 列出当前目录的内容。您也许能够找到配置文件、环境文件（令牌和应用程序密钥）等文件，以及更多有价值的内容。 ping 此命令将调用应用程序以挂起。这在测试应用程序是否进行盲命令注入时非常有用。 timeout 此命令还将调用应用程序以挂起。如果未安装 ping 命令，则它还可用于测试应用程序是否进行盲命令注入。 ","date":"2025-03-18T00:00:00Z","permalink":"https://Yerucrem.github.io/p/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","title":"命令注入基础"},{"content":"","date":"2025-03-11T00:00:00Z","permalink":"https://Yerucrem.github.io/p/%E5%85%B6%E4%B8%80/","title":"其一"}]